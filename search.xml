<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://www.wulai.me/2016/07/22/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[linux 如何显示一个文件的某几行(中间几行)]]></title>
      <url>http://www.wulai.me/2016/07/06/linux-e5-a6-82-e4-bd-95-e6-98-be-e7-a4-ba-e4-b8-80-e4-b8-aa-e6-96-87-e4-bb-b6-e7-9a-84-e6-9f-90-e5-87-a0-e8-a1-8c-e4-b8-ad-e9-97-b4-e5-87-a0-e8-a1-8c/</url>
      <content type="html"><![CDATA[<h3 id="1、从第3000行开始，显示1000行。即显示3000-3999行"><a href="#1、从第3000行开始，显示1000行。即显示3000-3999行" class="headerlink" title="1、从第3000行开始，显示1000行。即显示3000~3999行"></a>1、从第3000行开始，显示1000行。即显示3000~3999行</h3><pre><code>cat filename | tail -n +3000 | head -n 1000
</code></pre><h3 id="2、显示1000行到3000行"><a href="#2、显示1000行到3000行" class="headerlink" title="2、显示1000行到3000行"></a>2、显示1000行到3000行</h3><pre><code>cat filename| head -n 3000 | tail -n +1000
</code></pre><p><code>*注意两种方法的顺序</code></p>
<blockquote>
<p> 分解：<br>        tail -n 1000：显示最后1000行<br>        tail -n +1000：从1000行开始显示，显示1000行以后的<br>        head -n 1000：显示前面1000行</p>
</blockquote>
<h3 id="3、用sed命令"><a href="#3、用sed命令" class="headerlink" title="3、用sed命令"></a>3、用sed命令</h3><pre><code>sed -n &apos;5,10p&apos; filename
</code></pre><p>这样你就可以只查看文件的第5行到第10行。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Docker - dial tcp: lookup index.docker.io: no such host - Solution]]></title>
      <url>http://www.wulai.me/2016/06/28/docker-dial-tcp-lookup-index-docker-io-no-such-host-solution/</url>
      <content type="html"><![CDATA[<h2 id="1-Symptoms"><a href="#1-Symptoms" class="headerlink" title="1. Symptoms"></a>1. Symptoms</h2><p>While using Docker a user is unable to perform tasks such as pull new image or search for new images while the following error message appears:</p>
<pre><code># docker pull debian:8
Pulling repository debian
FATA[0053] Get https://index.docker.io/v1/repositories/library/debian/images: dial tcp: lookup index.docker.io: no such host
</code></pre><h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h2><p>While this is a randomly occurring error it is frequently linked to a DNS resolution query by docker services. First, make sure you are running up to date docker installation. If this does not resolve your issue then try to resolve this error by restarting your docker service:</p>
<pre><code># service docker restart
Redirecting to /bin/systemctl restart  docker.service
</code></pre><p>In case that you are unable to restart your docker service at a present time you my try to temporarily resolve this issue by including the IP address of the host in question eg. <code>index.docker.io</code> to your <code>/etc/hosts</code> file. Resolve the IP address:</p>
<pre><code># dig index.docker.io +noall +answer +nocomments

DiG 9.9.4-P2-RedHat-9.9.4-18.P2.fc20
index.docker.io +noall +answer +nocomments
;; global options: +cmd
index.docker.io.        30      IN      A       162.242.195.84
</code></pre><p>Next, include the IP address to your system’s <code>/etc/hosts</code> file:</p>
<pre><code># echo &apos;162.242.195.84 index.docker.io&apos;  /etc/hosts
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[svn local obstruction, incoming add upon merge]]></title>
      <url>http://www.wulai.me/2016/05/24/svn-local-obstruction-incoming-add-upon-merge/</url>
      <content type="html"><![CDATA[<p>If you’ve found this entry, you probably ran into your first SVN Tree conflict. This is also called an ‘evil twin conflict’ in some other revision control systems.</p>
<p>The message generated by svn merge or later svn stat operations will look something like this:</p>
<pre><code>A     C web-app/images/widget.png
        local obstruction, incoming add upon merge

Summary of conflicts:
  Tree conflicts: 1
</code></pre><h2 id="The-Cause"><a href="#The-Cause" class="headerlink" title="The Cause"></a>The Cause</h2><p>This special conflict message is created when the same file has been added to both the place your merging from as well as the place your merging to since the last merge. Since these evil twins both have completely different histories and no common state (as would exist if the image had been added before you branched), svn is totally unable to provide you advice. This is why you will see no <code>merge-left</code> or <code>merge-right</code> files.</p>
<h2 id="The-Solution"><a href="#The-Solution" class="headerlink" title="The Solution"></a>The Solution</h2><p>In the example above the same binary file has been added to both a branch and a trunk. Since the image is identical, the solution was simply to pick one. I picked the working copy.</p>
<pre><code>svn resolve --accept working ./web-app/images/widget.png
</code></pre><p>Another possible case is that two totally different files have been checked in with the same name and path. In this case, you’re going to need to rename one version and refactor the rest of your code to accommodate that name change. SVN has no easy way to do this so you’ll need to do it manually.</p>
<p>The last case is that the same file has been created but you need a super set of the functionality provided by both versions. Again, SVN does not offer any speedy tools for this so you’ll simply need to do a manual merger.</p>
<h3 id="一次修复所有的错误信息"><a href="#一次修复所有的错误信息" class="headerlink" title="一次修复所有的错误信息"></a>一次修复所有的错误信息</h3><pre><code>svn st | awk &apos;{if ( $1 == &quot;C&quot;) { print $2}}&apos; | xargs svn resolve --accept working
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[查找大文件夹]]></title>
      <url>http://www.wulai.me/2016/05/20/e6-9f-a5-e6-89-be-e5-a4-a7-e6-96-87-e4-bb-b6-e5-a4-b9/</url>
      <content type="html"><![CDATA[<pre><code>cd \
du -h --max-depth=1|grep G|sort -n
</code></pre><p>找到最大的那个目录后进入该目录</p>
<p>再运行</p>
<pre><code>du -h --max-depth=1|grep G|-n
</code></pre><p>如果没有结果可以运行</p>
<pre><code>du -h --max-depth=1|grep M|sort -n
</code></pre><p>找出来以后看是否有用的文件</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Git常用命令备忘]]></title>
      <url>http://www.wulai.me/2016/05/19/git-e5-b8-b8-e7-94-a8-e5-91-bd-e4-bb-a4-e5-a4-87-e5-bf-98/</url>
      <content type="html"><![CDATA[<h2 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h2><pre><code>git config --global user.name &quot;robbin&quot;   
git config --global user.email &quot;fankai@gmail.com&quot;
git config --global color.ui true
git config --global alias.co checkout
git config --global alias.ci commit
git config --global alias.st status
git config --global alias.br branch
git config --global core.editor &quot;mate -w&quot;    # 设置Editor使用textmate
git config -l  # 列举所有配置
</code></pre><p>用户的git配置文件<code>~/.gitconfig</code></p>
<h2 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h2><p>查看、添加、提交、删除、找回，重置修改文件</p>
<pre><code>git help command  # 显示command的help
git show            # 显示某次提交的内容
git show $id

git co  -- file   # 抛弃工作区修改
git co  .           # 抛弃工作区修改

git add file      # 将工作文件修改提交到本地暂存区
git add .           # 将所有修改过的工作文件提交暂存区

git rm file       # 从版本库中删除文件
git rm file --cached  # 从版本库中删除文件，但不删除文件

git reset file    # 从暂存区恢复到工作文件
git reset -- .      # 从暂存区恢复到工作文件
git reset --hard    # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改

git ci file
git ci .
git ci -a           # 将git add, git rm和git ci等操作都合并在一起做
git ci -am &quot;some comments&quot;
git ci --amend      # 修改最后一次提交记录

git revert $id    # 恢复某次提交的状态，恢复动作本身也创建了一次提交对象
git revert HEAD     # 恢复最后一次提交的状态
</code></pre><h2 id="查看文件diff"><a href="#查看文件diff" class="headerlink" title="查看文件diff"></a>查看文件diff</h2><pre><code>git diff file     # 比较当前文件和暂存区文件差异
git diff
git diff $id1 $id2   # 比较两次提交之间的差异
git diff branch1..branch2 # 在两个分支之间比较
git diff --staged   # 比较暂存区和版本库差异
git diff --cached   # 比较暂存区和版本库差异
git diff --stat     # 仅仅比较统计信息
</code></pre><h2 id="查看提交记录"><a href="#查看提交记录" class="headerlink" title="查看提交记录"></a>查看提交记录</h2><pre><code>git log
git log file      # 查看该文件每次提交记录
git log -p file   # 查看每次详细修改内容的diff
git log -p -2       # 查看最近两次详细修改内容的diff
git log --stat      # 查看提交统计信息
</code></pre><h2 id="tig"><a href="#tig" class="headerlink" title="tig"></a>tig</h2><p>Mac上可以使用tig代替diff和log， <code>brew install tig</code></p>
<h2 id="Git-本地分支管理"><a href="#Git-本地分支管理" class="headerlink" title="Git 本地分支管理"></a>Git 本地分支管理</h2><p>查看、切换、创建和删除分支</p>
<pre><code>git br -r           # 查看远程分支
git br new_branch # 创建新的分支
git br -v           # 查看各个分支最后提交信息
git br --merged     # 查看已经被合并到当前分支的分支
git br --no-merged  # 查看尚未被合并到当前分支的分支

git co branch     # 切换到某个分支
git co -b new_branch # 创建新的分支，并且切换过去
git co -b new_branch branch  # 基于branch创建新的new_branch

git co $id          # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除
git co $id -b new_branch  # 把某次历史提交记录checkout出来，创建成一个分支

git br -d branch  # 删除某个分支
git br -D branch  # 强制删除某个分支 (未被合并的分支被删除的时候需要强制)
</code></pre><h2 id="分支合并和rebase"><a href="#分支合并和rebase" class="headerlink" title="分支合并和rebase"></a>分支合并和rebase</h2><pre><code>git merge branch               # 将branch分支合并到当前分支
git merge origin/master --no-ff  # 不要Fast-Foward合并，这样可以生成merge提交

git rebase master branch       # 将master rebase到branch，相当于：
git co branch
git rebase master
git co master  
git merge branch
</code></pre><h2 id="Git补丁管理-方便在多台机器上开发同步时用"><a href="#Git补丁管理-方便在多台机器上开发同步时用" class="headerlink" title="Git补丁管理(方便在多台机器上开发同步时用)"></a>Git补丁管理(方便在多台机器上开发同步时用)</h2><pre><code>git merge branch               # 将branch分支合并到当前分支
git merge origin/master --no-ff  # 不要Fast-Foward合并，这样可以生成merge提交

git rebase master branch       # 将master rebase到branch，相当于：
git co branch  git rebase master  git co master  git merge branch
</code></pre><h2 id="Git补丁管理-方便在多台机器上开发同步时用-1"><a href="#Git补丁管理-方便在多台机器上开发同步时用-1" class="headerlink" title="Git补丁管理(方便在多台机器上开发同步时用)"></a>Git补丁管理(方便在多台机器上开发同步时用)</h2><pre><code>&lt;pre&gt;`git diff  ../sync.patch         # 生成补丁
git apply ../sync.patch          # 打补丁
git apply --check ../sync.patch  # 测试补丁能否成功
`&lt;/pre&gt;
</code></pre><h2 id="Git暂存管理"><a href="#Git暂存管理" class="headerlink" title="Git暂存管理"></a>Git暂存管理</h2><pre><code>git stash                        # 暂存
git stash list                   # 列所有stash
git stash apply                  # 恢复暂存的内容
git stash drop                   # 删除暂存区
</code></pre><h2 id="Git远程分支管理"><a href="#Git远程分支管理" class="headerlink" title="Git远程分支管理"></a>Git远程分支管理</h2><pre><code>git pull                         # 抓取远程仓库所有分支更新并合并到本地
git pull --no-ff                 # 抓取远程仓库所有分支更新并合并到本地，不要快进合并
git fetch origin                 # 抓取远程仓库更新
git merge origin/master          # 将远程主分支合并到本地当前分支
git co --track origin/branch     # 跟踪某个远程分支创建相应的本地分支
git co -b local_branch origin/remote_branch  # 基于远程分支创建本地分支，功能同上

git push                         # push所有分支
git push origin master           # 将本地主分支推到远程主分支
git push -u origin master        # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)
git push origin local_branch   # 创建远程分支， origin是远程仓库名
git push origin local_branch:remote_branch  # 创建远程分支
git push origin :remote_branch  #先删除本地分支(git br -d branch)，然后再push删除远程分支
</code></pre><h2 id="Git远程仓库管理"><a href="#Git远程仓库管理" class="headerlink" title="Git远程仓库管理"></a>Git远程仓库管理</h2><pre><code>git remote -v                    # 查看远程服务器地址和仓库名称
git remote show origin           # 查看远程服务器仓库状态
git remote add origin git@github:robbin/robbin_site.git         # 添加远程仓库地址
git remote set-url origin git@github.com:robbin/robbin_site.git # 设置远程仓库地址(用于修改远程仓库地址)
git remote rm repository       # 删除远程仓库
</code></pre><h2 id="创建远程仓库"><a href="#创建远程仓库" class="headerlink" title="创建远程仓库"></a>创建远程仓库</h2><pre><code>git clone --bare robbin_site robbin_site.git  # 用带版本的项目创建纯版本仓库
scp -r my_project.git git@git.csdn.net:~      # 将纯仓库上传到服务器上

mkdir robbin_site.git  cd robbin_site.git  git --bare init # 在服务器创建纯仓库
git remote add origin git@github.com:robbin/robbin_site.git    # 设置远程仓库地址
git push -u origin master                                      # 客户端首次提交
git push -u origin develop  # 首次将本地develop分支提交到远程develop分支，并且track

git remote set-head origin master   # 设置远程仓库的HEAD指向master分支

也可以命令设置跟踪远程库和本地库

git branch --set-upstream master origin/master
git branch --set-upstream develop origin/develop
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[traceroute 输出说明]]></title>
      <url>http://www.wulai.me/2016/05/19/traceroute-e8-be-93-e5-87-ba-e8-af-b4-e6-98-8e/</url>
      <content type="html"><![CDATA[<p>In Cisco routers, the codes for a traceroute command reply are:</p>
<pre><code>! -- success
* -- time out
N -- network unreachable
H -- host unreachable
P -- protocol unreachable
A -- admin denied
Q -- source quench received (congestion)
? -- unknown (any other ICMP message)
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[如何调试PHP的Core之获取基本信息]]></title>
      <url>http://www.wulai.me/2016/05/14/e5-a6-82-e4-bd-95-e8-b0-83-e8-af-95php-e7-9a-84core-e4-b9-8b-e8-8e-b7-e5-8f-96-e5-9f-ba-e6-9c-ac-e4-bf-a1-e6-81-af/</url>
      <content type="html"><![CDATA[<p>  作者: Laruence(   )<br>  本文地址: <a href="http://www.laruence.com/2011/06/23/2057.html" target="_blank" rel="external">http://www.laruence.com/2011/06/23/2057.html</a><br>  转载请注明出处</p>
<p>其实一直想写这个系列, 但是一想到这个话题的宽泛性, 我就有点感觉无法组织.</p>
<p>今天我也不打算全部讲如何调试一个PHP的Core文件, 也不会介绍什么是Coredump, 选择一个相对比较简单的方向来介绍, 那就是如何从PHP的Core文件中获取一些对我们重演这个Core有帮助的信息.</p>
<p>在这个过程中, 会涉及到对PHP的函数调用, PHP的传参, PHP的一些全局变量的知识, 这些知识在我之前的文章中都有过涉及, 大家可以翻阅: 深入理解PHP原理之函数 深入理解PHP原理之变量作用域等等.</p>
<p>首先, 让我们生成一个供我们举例子的Core文件:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">recurse</span><span class="params">($num)</span> </span>&#123;</div><div class="line">      recurse(++$num);</div><div class="line">&#125;</div><div class="line"></div><div class="line">recurse(<span class="number">0</span>);</div></pre></td></tr></table></figure>
<p>运行这个PHP文件:</p>
<pre><code>$ php test.php
Segmentation fault (core dumped)
</code></pre><p>这个PHP因为无线递归, 会导致爆栈, 从而造成 segment fault而在PHP的当前工作目录产生Coredump文件(如果你的系统没有产生Coredump文件, 那请查询ulimit的相关设置).</p>
<pre><code>$ ulimit -c unlimited
$ php test.php
</code></pre><p>好, 现在, 让我们删除掉这个test.php, 忘掉上面的代码, 我们现在仅有的是这个Core文件, 任务是, 找出这个Core产生的原因, 以及发生时候的状态.</p>
<p>首先, 让我们用gdb打开这个core文件:</p>
<pre><code>$ gdb php -c core.31656
</code></pre><p>会看到很多的信息, 首先让我们注意这段:</p>
<pre><code>Core was generated by `php test.php&apos;.
Program terminated with signal 11, Segmentation fault.
</code></pre><p>他告诉我们Core发生的原因:”Segmentation fault”.</p>
<p>一般来说, 这种Core是最常见的, 解引用空指针, double free, 以及爆栈等等, 都会触发SIGSEGV, 继而默认的产生Coredump.</p>
<p>现在让我们看看Core发生时刻的堆栈:</p>
<pre><code>#0  execute (op_array=0xdc9a70) at /home/laruence/package/php-5.2.14/Zend/zend_vm_execute.h:53
53          memset(EX(CVs), 0, sizeof(zval**) * op_array-&amp;gt;last_var);
(gdb) bt
#0  execute (op_array=0xdc9a70) at /home/laruence/package/php-5.2.14/Zend/zend_vm_execute.h:53
#1  0x00000000006ea263 in zend_do_fcall_common_helper_SPEC (execute_data=0x7fbf400210) at /home/laruence/package/php-5.2.14/Zend/zend_vm_execute.h:234
#2  0x00000000006e9f61 in execute (op_array=0xdc9a70) at /home/laruence/package/php-5.2.14/Zend/zend_vm_execute.h:92
#3  0x00000000006ea263 in zend_do_fcall_common_helper_SPEC (execute_data=0x7fbf400440) at /home/laruence/package/php-5.2.14/Zend/zend_vm_execute.h:234
#4  0x00000000006e9f61 in execute (op_array=0xdc9a70) at /home/laruence/package/php-5.2.14/Zend/zend_vm_execute.h:92
#5  0x00000000006ea263 in zend_do_fcall_common_helper_SPEC (execute_data=0x7fbf400670) at /home/laruence/package/php-5.2.14/Zend/zend_vm_execute.h:234
.....
</code></pre><p>不停的按回车, 可以看到堆栈很深, 不停的是zend_do_fcall_common_helper_SPEC和execute的重复, 那么这基本就能断定是因为产生了无穷大的递归(不能一定说是无穷递归, 比如我之前文章中介绍深悉正则(pcre)最大回溯/递归限制). 从而造成爆栈产生的Core.</p>
<p>Ok, 那么现在让我们看看, Core发生在PHP的什么函数中, 在PHP中, 对于FCALL_* Opcode的handler来说, execute_data代表了当前函数调用的一个State, 这个State中包含了信息:</p>
<pre><code>(gdb)f 1
#1  0x00000000006ea263 in zend_do_fcall_common_helper_SPEC (execute_data=0x7fbf400210) at /home/laruence/package/php-5.2.14/Zend/zend_vm_execute.h:234
234               zend_execute(EG(active_op_array) TSRMLS_CC);
(gdb) p execute_data-&amp;gt;function_state.function-&amp;gt;common-&amp;gt;function_name
$3 = 0x2a95b65a78 &quot;recurse&quot;
(gdb) p execute_data-&amp;gt;function_state.function-&amp;gt;op_array-&amp;gt;filename
$4 = 0x2a95b632a0 &quot;/home/laruence/test.php&quot;
(gdb) p execute_data-&amp;gt;function_state.function-&amp;gt;op_array-&amp;gt;line_start
$5 = 2
</code></pre><p>现在我们得到, 在调用的PHP函数是recurse, 这个函数定义在/home/laruence/test.php的第二行</p>
<p>经过重复验证几个frame, 我们可以看出, 一直是在重复调用这个PHP函数.</p>
<p>要注意的是, 为了介绍查看执行信息的原理, 我才采用原生的gdb的print来查看, 其实我们还可以使用PHP源代码中提供的.gdbinit(gdb命令编写脚本), 来简单的获取到上面的信息:</p>
<pre><code>(gdb) source /home/laruence/package/php-5.2.14/.gdbinit
(gdb) zbacktrace
[0xbf400210] recurse() /home/laruence/test.php:3
[0xbf400440] recurse() /home/laruence/test.php:3
[0xbf400670] recurse() /home/laruence/test.php:3
[0xbf4008a0] recurse() /home/laruence/test.php:3
[0xbf400ad0] recurse() /home/laruence/test.php:3
[0xbf400d00] recurse() /home/laruence/test.php:3
[0xbf400f30] recurse() /home/laruence/test.php:3
[0xbf401160] recurse() /home/laruence/test.php:3
.....
</code></pre><p>关于.gdbinit, 是一段小小的脚本文件, 定义了一些方便我们去调试PHP的Core, 大家也可以用文本编辑器打开, 看看里面定义的一些快捷的命令, 一般来说, 我常用的有:</p>
<pre><code>zbacktrace
print_ht**系列
zmemcheck
</code></pre><p>OK, 回归正题, 我们现在知道, 问题发生在/home/laruence/test.php的recurse函数的递归调用上了.</p>
<p>现在, 让我们来看看, 在调用这个函数的时候的参数是什么?</p>
<p>PHP的参数传递是依靠一个全局Stack来完成的, 也就是EG(argument_stack), EG在非多线程情况下就是executor_globals, 它保持了很多执行状态. 而argument_statck就是参数的传递栈, 保存着对应PHP函数调用层数相当的调用参数.</p>
<p>要注意的是, 这个PHP函数调用堆栈(层数)不和gdb所看到的backtrace简单的一一对应, 所以参数也不能直接和gdb的backtrace对应起来, 需要单独分析:</p>
<pre><code>//先看看, 最后一次函数调用的参数数目是多少
(gdb) p (int )*(executor_globals-&amp;gt;argument_stack-&amp;gt;top_element - 2)
$13 = 1

//再看看, 最后一次函数调用的参数是什么
(gdb)  p **(zval **)(executor_globals-&amp;gt;argument_stack-&amp;gt;top_element - 3)
$2 = {value = {lval = 22445, dval = 1.1089303420906779e-319, str = {val = 0x57ad &amp;lt;Address 0x57ad out of bounds&amp;gt;, len = 7}, ht = 0x57ad, obj = {handle = 22445, handlers = 0x7}},
  refcount = 2, type = 1 &apos;\001&apos;, is_ref = 0 &apos;\0&apos;}
</code></pre><p>好, 我们现在得到, 最后一次调用的参数是一个整数, 数值是22445</p>
<p>到了这一步, 我们就得到了这个Core发生的时刻的PHP层面的相关信息, 接下来, 就可以交给对应的PHP开发工程师来排查, 这个参数下, 可能造成的无穷大递归的原因, 从而修复这个问题..</p>
<p>后记: 调试PHP的Core是一个需要丰富经验的过程, 也许我今天介绍的这个例子太简单, 但是只要经常去挑战, 在遇到不懂的相关的知识的时候, 勇于去追根究底, 我相信大家终都可以成PHP Core杀手..</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[知道这20个正则表达式，能让你少写1,000行代码]]></title>
      <url>http://www.wulai.me/2016/04/27/e7-9f-a5-e9-81-93-e8-bf-9920-e4-b8-aa-e6-ad-a3-e5-88-99-e8-a1-a8-e8-be-be-e5-bc-8f-ef-bc-8c-e8-83-bd-e8-ae-a9-e4-bd-a0-e5-b0-91-e5-86-991000-e8-a1-8c-e4-bb-a3-e7-a0-81/</url>
      <content type="html"><![CDATA[<p>正则表达式，一个十分古老而又强大的文本处理工具，仅仅用一段非常简短的表达式语句，便能够快速实现一个非常复杂的业务逻辑。熟练地掌握正则表达式的话，能够使你的开发效率得到极大的提升。</p>
<p>正则表达式经常被用于字段或任意字符串的校验，如下面这段校验基本日期格式的JavaScript代码：</p>
<pre><code>var reg = /^(\\d{1,4})(-|\\/)(\\d{1,2})\\2(\\d{1,2})$/;
var r = fieldValue.match(reg);             
if(r==null)alert(&apos;Date format error!&apos;);
</code></pre><p>下面是技匠整理的，在前端开发中经常使用到的20个正则表达式。</p>
<p>1、校验密码强度    密码的强度必须是包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间。</p>
<pre><code>^(?=. \\d)(?=. [a-z])(?=. [A-Z]).{8,10}$
</code></pre><p>2、校验中文    字符串仅能是中文。</p>
<pre><code>[\\u4e00-\\u9fa5]{0,}$
</code></pre><p>3、由数字、26个英文字母或下划线组成的字符串</p>
<pre><code>^\\w+$
</code></pre><p>4、校验E-Mail 地址    同密码一样，下面是E-mail地址合规性的正则检查语句。</p>
<pre><code>[\\w!#$% &apos; +/=?^_`{|}~-]+(?:\\.[\\w!#$% &apos; +/=?^_`{|}~-]+) @(?:[\\w](?:[\\w-] [\\w])?\\.)+[\\w](?:[\\w-] [\\w])?
</code></pre><p>5、校验身份证号码</p>
<p>下面是身份证号码的正则校验。15 或 18位。</p>
<p>15位：</p>
<pre><code>^[1-9]\\d{7}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}$
</code></pre><p>18位：</p>
<pre><code>^[1-9]\\d{5}[1-9]\\d{3}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}([0-9]|X)$
</code></pre><p>6、校验日期    “yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。</p>
<pre><code>^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$
</code></pre><p>7、校验金额    金额校验，精确到2位小数。</p>
<pre><code>^[0-9]+(.[0-9]{2})?$
</code></pre><p>8、校验手机号    下面是国内 13、15、18开头的手机号正则表达式。</p>
<pre><code>^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$
</code></pre><p>9、判断IE的版本    IE目前还没被完全取代，很多页面还是需要做版本兼容，下面是IE版本检查的表达式。</p>
<pre><code>^. MSIE [5-8](?:\\.[0-9]+)?(?!. Trident\\/[5-9]\\.0). $
</code></pre><p>10、校验IP-v4地址    IP4 正则语句。</p>
<pre><code>\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b
</code></pre><p>11、校验IP-v6地址    IP6 正则语句。</p>
<pre><code>(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))
</code></pre><p>12、检查URL的前缀    应用开发中很多时候需要区分请求是HTTPS还是HTTP，通过下面的表达式可以取出一个url的前缀然后再逻辑判断。</p>
<pre><code>if (!s.match(/^[a-zA-Z]+:\\/\\//))
{
    s = &apos;http://&apos; + s;
}
</code></pre><p>13、提取URL链接    下面的这个表达式可以筛选出一段文本中的URL。<br>    ^(f|ht){1}(tp|tps):&#92;/&#92;/([&#92;w-]+&#92;.)+[&#92;w-]+(&#92;/[&#92;w- ./?% =] )?</p><p></p>
<p>14、文件路径及扩展名校验    验证文件路径和扩展名</p>
<pre><code>^([a-zA-Z]\\:|\\\\)\\\\([^\\\\]+\\\\) [^\\/: ?&quot;&amp;lt;&amp;gt;|]+\\.txt(l)?$
</code></pre><p>15、提取Color Hex Codes    有时需要抽取网页中的颜色代码，可以使用下面的表达式。</p>
<pre><code>\\#([a-fA-F]|[0-9]){3,6}
</code></pre><p>16、提取网页图片    假若你想提取网页中所有图片信息，可以利用下面的表达式。</p>
<pre><code>[img][^\\&amp;gt;] [src]  =  [\\&quot;\\&apos;]{0,1}([^\\&quot;\\&apos;\\ &amp;gt;] )
</code></pre><p>17、提取页面超链接    提取html中的超链接。</p>
<pre><code>(&amp;lt;a\\s (?!. \\brel=)[^&amp;gt;] )(href=&quot;https?://)((?!(?:(?:www\\.)?&apos;.implode(&apos;|(?:www\\.)?&apos;, $follow_list).&apos;))[^&quot;]+)&quot;((?!. \\brel=)[^&amp;gt;] )(?:[^&amp;gt;] )&amp;gt;
</code></pre><p>18、精炼CSS    通过下面的表达式，可以搜索相同属性值的CSS，从而达到精炼代码的目的。</p>
<pre><code>^\\s [a-zA-Z\\-]+\\s [:]{1}\\s[a-zA-Z0-9\\s.#]+[;]{1}
</code></pre><p>19、抽取注释    如果你需要移除HMTL中的注释，可以使用如下的表达式。</p>
<pre><code>&amp;lt;!--(. ?)--&amp;gt;
</code></pre><p>20、匹配HTML标签    通过下面的表达式可以匹配出HTML中的标签。</p>
<pre><code>&lt;pre&gt;`&amp;lt;/?\\w+((\\s+\\w+(\\s =\\s (?:&quot;. ?&quot;|&apos;. ?&apos;|[\\^&apos;&quot;&amp;gt;\\s]+))?)+\\s |\\s )/?&amp;gt;
</code></pre><h2 id="正则表达式的相关语法"><a href="#正则表达式的相关语法" class="headerlink" title="正则表达式的相关语法"></a>正则表达式的相关语法</h2><p></p><p>下面是我找到的一张非常不错的正则表达式 Cheat Sheet，可以用来快速查找相关语法。<br><img src="http://res.hillock.com.cn/web/reg1" alt="正则表达图"></p>
<h2 id="学习正则表达式"><a href="#学习正则表达式" class="headerlink" title="学习正则表达式"></a>学习正则表达式</h2><p>我在网上看到了一篇相当不错的正则表达式快速学习指南，有兴趣继续深入学习的同学可以参考。<br><img src="http://res.hillock.com.cn/web/reg2" alt="图像"></p>
<h2 id="正则表达式在线测试工具"><a href="#正则表达式在线测试工具" class="headerlink" title="正则表达式在线测试工具"></a>正则表达式在线测试工具</h2><p>regex101是一个非常不错的正则表达式在线测试工具，你可以直接在线测试你的正则表达式哦。</p>
<p><img src="http://res.hillock.com.cn/web/reg3" alt="学习正则表达"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[linux ll命令列出文件制定的属性]]></title>
      <url>http://www.wulai.me/2016/04/25/linux-ll-e5-91-bd-e4-bb-a4-e5-88-97-e5-87-ba-e6-96-87-e4-bb-b6-e5-88-b6-e5-ae-9a-e7-9a-84-e5-b1-9e-e6-80-a7/</url>
      <content type="html"><![CDATA[<p><code>ll -Sh *.mp4 | grep ^[^d] | awk &#39;{print $5,$9;}&#39;</code></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[［转］应用数据静态化架构高性能单页Web应用]]></title>
      <url>http://www.wulai.me/2016/04/12/ef-bc-bb-e8-bd-ac-ef-bc-bd-e5-ba-94-e7-94-a8-e6-95-b0-e6-8d-ae-e9-9d-99-e6-80-81-e5-8c-96-e6-9e-b6-e6-9e-84-e9-ab-98-e6-80-a7-e8-83-bd-e5-8d-95-e9-a1-b5web-e5-ba-94-e7-94-a8/</url>
      <content type="html"><![CDATA[<p>在电商网站中，单页Web是非常常见的一种形式，比如首页、频道页、广告页等都属于单页应用。而这种页面是由模板+数据组成。传统的构建方式一般通过静态化实现。而这种方式的灵活性并不是很好，比如页面模板部分变更了需要重新全部生成。因此最好能有一种实现方式是可以实时动态渲染，以支持模板的多变性。另外也要考虑好如下几个问题：</p>
<li><br>1、动态化模板渲染支持；<br>2、数据和模板的多版本化：生产版本、灰度版本和预发布版本；<br>3、版本回滚问题，假设当前发布的生产版本出问题了如何快速的回滚到上一个版本；<br>4、异常问题，假设渲染模板时遇到了异常情况（比如获取Redis出问题了），如何处理；<br>5、灰度发布问题，比如切20%量给灰度版本；<br>6、预发布问题，目的是在正式环境测试数据和模板的正确性。<br> </li>

<p><strong>整体架构</strong></p>
<p>静态化页面的方案如下图所示：<br><img src="http://res.hillock.com.cn/web/640" alt="［转］应用数据静态化架构高性能单页Web应用" title="［转］应用数据静态化架构高性能单页Web应用"></p>
<p>直接将生成的静态页推送到相关服务器即可。使用这种方式要考虑文件操作的原子化问题（即从老版本切换到新版本如何做到文件操作原子化）。</p>
<p>而动态化方案的整体架构如下图所示，分为三大系统：CMS系统、控制系统和前端展示系统。<br><img src="http://res.hillock.com.cn/web/6402" alt="［转］应用数据静态化架构高性能单页Web应用" title="［转］应用数据静态化架构高性能单页Web应用"></p>
<p>###CMS系统<br>1、在CMS系统可以配置页面的模板和数据；<br>1.1、模板动态在CMS系统中维护，即模板不是一个静态文件，而是存储在CMS中的一条数据，最终发布到“发布数据存储Redis”中，前端展示系统从Redis中获取该模板进行渲染，从而前端展示系统更换了模板也不需要重启，纯动态维护模板数据；<br>2、原始数据存储到“元数据存储Mysql”中即可，比如频道页一般需要：前端访问的URL、分类、轮播图、商品楼层数据等；这些数据按照相应的维度存储在CMS系统中；<br>3、提供发布到“发布数据存储Redis”的控制，将CMS系统中的原始数据和模板数据组装成聚合数据（JSON存储）同步到“发布数据存储Redis”，以便前端展示系统获取进行展示；此处提供三个发布按钮：正式版本、灰度版本和预发布版本。</p>
<p>目前存在如下几个问题：<br>1、用户如访问<a href="http://channel.jd.com/fashion.html怎么定位到对应的聚合数据呢？" target="_blank" rel="external">http://channel.jd.com/fashion.html怎么定位到对应的聚合数据呢？</a> 我们可以在CMS元数据中定义URL作为KEY，如果没有URL，则使用ID作为KEY，或者自动生成一个URL。<br>2、多版本如何存储呢？ 使用Redis的Hash结构存储即可，KEY为URL（比如<a href="http://channel.jd.com/fashion.html），字段按照维度存储：正式版本使用当前时间戳存储（这样前端系统可以根据时间戳排序然后获取最新的版本）、预发布版本使用“predeploy”作为字段，灰度版本使用“abVersion”作为字段即可，这样就区分开了多版本。" target="_blank" rel="external">http://channel.jd.com/fashion.html），字段按照维度存储：正式版本使用当前时间戳存储（这样前端系统可以根据时间戳排序然后获取最新的版本）、预发布版本使用“predeploy”作为字段，灰度版本使用“abVersion”作为字段即可，这样就区分开了多版本。</a><br>3、灰度版本如何控制呢？这个通过控制系统的开关来控制如何灰度；<br>4、如何访问预发布版本呢？比如在URL参数总带上predeploy=true，另外可以限定只有内网可以访问或者访问时带上访问密码，比如pwd=absdfedwqdqw。<br>5、模板变更的历史数据校验问题？比如模板变更了，但是使用历史数据渲染该模板会出现问题，即模板要兼容历史数据的；此处的方案不存在这个问题，因为每次存储时是当时的模板快照，即数据快照和模板快照推送到“发布数据存储Redis”中。</p>
<p><strong>前端展示系统</strong><br>1、获取当前URL，使用URL作为KEY首先从本机“发布数据存储Redis”获取数据；<br>2、如果没有数据或者异常则从主“发布数据存储Redis”获取；<br>3、如果主“发布数据存储Redis”也发生了异常，那么会直接调用CMS系统暴露的API直接从元数据存储Mysql中获取数据进行处理。</p>
<p>展示系统的伪代码</p>
<pre><code>Java代码  
--1、加载Lua模块库  
local template = require(&quot;resty.template&quot;)  
template.load = function(s) return s end  

--2、动态获取模板  
local myTemplate = &quot;&amp;lt;html&amp;gt;{* title *}&amp;lt;/html&amp;gt;&quot;  
--3、动态获取数据  
local data = {title = &quot;iphone6s&quot;}  

--4、渲染模板  
local func = template.compile(myTemplate)  
local content = func(data)  

--5、通过ngx API输出内容  
ngx.say(content)  
即模板和数据都是动态获取的，然后使用动态获取的模板和数据进行渲染。
</code></pre><p>此处假设最新版本的模板或数据有问题怎么办？这个可以从流程上避免：1、首先进行预发布版本发布，测试人员验证没问题后；2、接着发布灰度版本，在灰度时自动去掉CDN功能（即不设置页面的缓存时间），发布验证OK；3、发布正式版本即可；正式版本发布的5分钟内是不设置页面缓存的，这样就可以防止发版时遇到问题，但是问题版本已经在CDN上给全部用户造成问题。当然这个流程很麻烦，可以按照自己的场景进行简化。</p>
<p>控制系统<br>控制系统用于版本降级和灰度发布的，当然可以把这个功能放在CMS系统中实现。<br>版本降级：假设当前线上的版本遇到问题了，想要快速切换回上一个版本，可以使用控制系统实现，选中其中一个历史版本然后通知给前端展示系统即可，使用URL和当前版本的字段即可，这样前端展示系统就可以自动切换到选中的那个版本；当问题修复后，再删除该降级配置即切换回最新版本。<br>灰度发布：在控制系统控制哪些URL需要灰度发布和灰度发布的比例，同版本降级类似将相关的数据推送到前端展示系统即可，当不想灰度发布时删除相关数据即可。</p>
<p>数据和模板动态化</p>
<p>我们将数据和模板都进行动态化存储，这样可以在CMS进行数据和模板的变更；实现了前端和后端开发人员的分离；前端开发人员进行CMS数据配置和模板开发，而后端开发人员只进行系统的维护。另外因为模板的动态化存储，每次发布新的模板不需要老重启前端展示系统，后端开发人员更好地得到了解放。</p>
<p>模板和数据可以是一对多的关系，即一个模板可以被多个数据使用。假设模板发生变更后，我们可以批量推送模板关联的数据，首先进行预发布版本的发布，测试人员进行验证，验证没问题即可发布正式版本。</p>
<p>多版本机制</p>
<p>我们将数据和模板分为多版本后，可以实现：<br>预发布版本：更容易让测试人员在实际环境进行验证；<br>灰度版本：只需要简单的开关控制，就可以进行A/B测试；<br>正式版本：存储多个历史正式版本，假设最新的正式版本出现问题，可以非常快速的切换回之前的版本。</p>
<p>异常问题</p>
<p>其中一个担心就是本机从“发布数据存储Redis”和主“发布数据存储Redis”都挂了，那么我们直接调用CMS系统暴露的HTTP服务直接从元数据存储Mysql获取数据。</p>
<p>另外一个担心是数据和模板获取到了，但是渲染模板出错了，比如遇到500、503；解决方案是：使用上一个版本的数据进行渲染。</p>
<p>另外还一种问题是数据和模板都没问题，但是因为一些疏忽，渲染出来的页面错乱了或者有些区域出现了空白；对于这种问题没有很好的解决方案；可以根据自己的场景定义异常扫描库，扫描当前版本有异常就发警告给相关人员，并自动降级到上一个版本。</p>
<p>来源：开涛的博客</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CentOS下将MySQL 5.1升级到MySQL 5.5]]></title>
      <url>http://www.wulai.me/2016/04/01/centos-e4-b8-8b-e5-b0-86mysql-5-1-e5-8d-87-e7-ba-a7-e5-88-b0mysql-5-5/</url>
      <content type="html"><![CDATA[<p>mysql 5.5已经出来有一段时间，性能有明显提升，特别是对多核CPU的支持与TPS性能的提升。上周博主介绍了linux下编译安装mysql 5.5的步骤，安装不出意外基本没有问题。不过可能很多朋友和我一样一直用的是mysql 5.1，现在想把数据库升级成5.5了。博主根据实际操作，记录这次升级操作。</p>
<p>mysql基础信息</p>
<p>1、安装目录<br><code>[root@vm-199~]# /usr/local/mysql</code><br>2、配置文件<br><code>[root@vm-199~]# /etc/my.cnf</code><br>3、数据目录<br><code>[root@vm-199~]# /data/mysql</code><br>4、启动脚本<br><code>[root@vm-199~]# /etc/init.d/mysql</code></p>
<p>备份数据和安装、配置文件</p>
<p><code>[root@vm-199~]# mysqldump -uroot -p –all-databases &amp;lt;/root/zhangnq/mysql5.1/mysql_dbk_20140217.sql
[root@vm-199~]# tar czvf mysql_5.1.60_full.tar.gz /usr/local/mysql
[root@vm-199~]# tar czvf mysql_5.1.60_data_full.tar.gz /data/mysql
[root@vm-199~]# cp /etc/my.cnf  ./</code></p>
<p>数据备份好后关闭mysql数据库，<code>/etc/init.d/mysql stop</code>，删除/usr/local/mysql文件。</p>
<p>安装mysql 5.5</p>
<p>具体可以参考这篇文章《Linux下编译安装Mysql-5.5的简单步骤》（<a href="http://www.sijitao.net/1563.html），安装目录、数据目录和5.1的一样，都是/usr/local/mysql" target="_blank" rel="external">http://www.sijitao.net/1563.html），安装目录、数据目录和5.1的一样，都是/usr/local/mysql</a> 。</p>
<p>更新配置文件</p>
<p><code>[root@vm-199 mysql-5.5.35]# cp support-files/my-huge.cnf /etc/my.cnf</code></p>
<p>在配置文件中添加数据目录，datadir = /data/mysql 。</p>
<p>启动mysql 5.5，执行更新程序并重启mysql</p>
<p><code>[root@vm-199 mysql-5.5.35]# /etc/init.d/mysql start
[root@vm-199 mysql-5.5.35]# /usr/local/mysql/bin/mysql_upgrade
Looking for &#39;mysql&#39; as: /usr/local/mysql/bin/mysql
Looking for &#39;mysqlcheck&#39; as: /usr/local/mysql/bin/mysqlcheck
Running &#39;mysqlcheck&#39; with connection arguments: &#39;--port=3306&#39; &#39;--socket=/tmp/mysqld.sock&#39;
Running &#39;mysqlcheck&#39; with connection arguments: &#39;--port=3306&#39; &#39;--socket=/tmp/mysqld.sock&#39;
mydb.t1 OK
mydb.t2 OK
mysql.columns_priv OK
mysql.db OK
mysql.event OK
mysql.func OK
mysql.general_log OK
mysql.help_category OK
mysql.help_keyword OK
mysql.help_relation OK
mysql.help_topic OK
mysql.host OK
mysql.ndb_binlog_index OK
mysql.plugin OK
mysql.proc OK
mysql.procs_priv OK
mysql.proxies_priv OK
mysql.servers OK
mysql.slow_log OK
mysql.tables_priv OK
mysql.time_zone OK
mysql.time_zone_leap_second OK
mysql.time_zone_name OK
mysql.time_zone_transition OK
mysql.time_zone_transition_type OK
mysql.user OK
Running &#39;mysql_fix_privilege_tables&#39;...
OK</code><br>至此mysql已经更新好了。登陆mysql，检查数据是否和原来一样。</p>
<p>这个mysql升级其实不复杂，其实就是重新安装一遍，然后把数据目录文件覆盖一下。不过数据库升级，主要还是得注意数据备份，防止数据和意外丢失。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[svn: file is scheduled for addition, but is missing]]></title>
      <url>http://www.wulai.me/2016/03/16/svn-file-is-scheduled-for-addition-but-is-missing/</url>
      <content type="html"><![CDATA[<p>svn提交错误file is scheduled for addition, but is missing</p>
<p><code>svn delete</code></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[查找目录下的所有文件中是否含有某个字符串]]></title>
      <url>http://www.wulai.me/2016/03/01/e6-9f-a5-e6-89-be-e7-9b-ae-e5-bd-95-e4-b8-8b-e7-9a-84-e6-89-80-e6-9c-89-e6-96-87-e4-bb-b6-e4-b8-ad-e6-98-af-e5-90-a6-e5-90-ab-e6-9c-89-e6-9f-90-e4-b8-aa-e5-ad-97-e7-ac-a6-e4-b8-b2/</url>
      <content type="html"><![CDATA[<ul>
<li>查找目录下的所有文件中是否含有某个字符串<em>   find .|xargs grep -ri “IBM”</em>   查找目录下的所有文件中是否含有某个字符串,并且只打印出文件名*   find .|xargs grep -ri “IBM” -l</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[如何批量或者全部删除Linux的系统邮件？]]></title>
      <url>http://www.wulai.me/2016/01/21/e5-a6-82-e4-bd-95-e6-89-b9-e9-87-8f-e6-88-96-e8-80-85-e5-85-a8-e9-83-a8-e5-88-a0-e9-99-a4linux-e7-9a-84-e7-b3-bb-e7-bb-9f-e9-82-ae-e4-bb-b6-ef-bc-9f/</url>
      <content type="html"><![CDATA[<p>CentOS Linux Server 会将许多系统运行的状态发邮件给管理员root用户，系统邮件存放在 /var/spool/mail/root 目录中，可以通过使用 mail 命令来查看邮件，但是时间长了，也会造成邮件过多，如何使用 Shell 命令来批量删除或者全部删除呢？</p>
<p>　　方法一：使用mail命令，然后在 &amp; 提示符下使用 d 命令（Delete），批量删除邮件，例如删除1~53邮件：</p>
<p>　　# mail<br>　　&amp; d 1-53</p>
<p>　　方法二：删除全部系统邮件</p>
<p>　　# &gt; /var/spool/mail/root    or  cat /dev/null &gt; /var/spool/mail/root</p>
<p>　　或者</p>
<p>　　# echo “d *” |mail -N</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux 刪除 Delete all root mail]]></title>
      <url>http://www.wulai.me/2016/01/21/linux-e5-88-aa-e9-99-a4-delete-all-root-mail/</url>
      <content type="html"><![CDATA[<p>有時候系統會提示收到郵件，通常是一些系統錯誤的通知，看完確認沒問題就可以刪了。</p>
<p>通知長得像這樣：<br>You have new mail in /var/spool/mail/root<br>刪除的方法很簡單，用以下兩種指令擇一即可。</p>
<p>cp /dev/null /var/spool/mail/root</p>
<blockquote>
<p>/var/spool/mail/root<br>  這樣就會清空root的mail。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SSH免密码登录]]></title>
      <url>http://www.wulai.me/2016/01/17/ssh-e5-85-8d-e5-af-86-e7-a0-81-e7-99-bb-e5-bd-95/</url>
      <content type="html"><![CDATA[<p>在配置Hadoop集群分布时，要使用SSH免密码登录，假设现在有两台机器hadoop@wang-PC(192.168.10.100)，作为A机，hadoop@chen-PC(192.168.10.107)，作为B机。现想hadoop@wang-PC通过ssh免密码登录到hadoop@chen-PC。</p>
<p>###1.在A机下生成公钥/私钥对。<br>[hadoop@wang-PC ~]$ ssh-keygen -t rsa -P ‘’<br>敲击回车键即可，<br>它在/home/hadoop下生成.ssh目录，.ssh下有id_rsa和id_rsa.pub。</p>
<p>###2.把A机器下的id_rsa.pub复制到B机器下的.ssh/authorized_keys文件里。</p>
<p>[hadoop@wang-PC ~]$ scp .ssh/id_rsa.pub hadoop@192.168.10.107:/home/hadoop/id_rsa.pub.hadoop_wang<br>hadoop@192.168.10.107’s password:<br>由于还没有免密码登录的，所以要输入密码。</p>
<p>3.B机把从A机复制的id_rsa.pub.hadoop_wang添加到.ssh/authorzied_keys文件里。</p>
<p>[hadoop@chen-PC ~]$ cat id_rsa.pub.hadoop_wang &gt;&gt; .ssh/authorized_keys<br>[hadoop@chen-PC ~]$ chmod 600 .ssh/authorized_keys<br>authorized_keys的权限要是600。</p>
<p>4.A机登录B机。<br>[hadoop@wang-PC ~]$ ssh 192.168.10.107<br>第一次登录是时要你输入yes。<br>现在A机可以无密码登录B机了。</p>
<p>小结：登录的机子可有私钥，被登录的机子要有登录机子的公钥。这个公钥/私钥对一般在私钥宿主机产生。上面是用rsa算法的公钥/私钥对，当然也可以用dsa(对应的文件是id_dsa，id_dsa.pub)<br>想让A，B机无密码互登录，那B机以上面同样的方式配置即可,把B的公钥复制过去添加到authorized_keys的末尾就行了。<br>至此完毕。</p>
<blockquote>
<blockquote>
<p>补充<br>    配置本地ssh config文件。执行：<br>    vi ~/.ssh/config<br>    加入以下内容：<br>    Host cssor_server  #别名，域名缩写<br>       HostName cssor.com  #完整的域名<br>       User cssor  #登录该域名使用的账号名<br>       PreferredAuthentications publickey  #有些情况或许需要加入此句，优先验证类型ssh<br>       IdentityFile ~/.ssh/id_rsa #私钥文件的路径</p>
</blockquote>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[json解析错误]]></title>
      <url>http://www.wulai.me/2016/01/05/json-e8-a7-a3-e6-9e-90-e9-94-99-e8-af-af/</url>
      <content type="html"><![CDATA[<pre><code>     switch (json_last_error()) {
         case JSON_ERROR_NONE:
             echo &apos; - No errors&apos;;
             break;
         case JSON_ERROR_DEPTH:
             echo &apos; - Maximum stack depth exceeded&apos;;
             break;
         case JSON_ERROR_STATE_MISMATCH:
             echo &apos; - Underflow or the modes mismatch&apos;;
             break;
         case JSON_ERROR_CTRL_CHAR:
             echo &apos; - Unexpected control character found&apos;;
             break;
         case JSON_ERROR_SYNTAX:
             echo &apos; - Syntax error, malformed JSON&apos;;
             break;
         case JSON_ERROR_UTF8:
             echo &apos; - Malformed UTF-8 characters, possibly incorrectly encoded&apos;;
             break;
         default:
             echo &apos; - Unknown error&apos;;
             break;
     }
`&lt;/pre&gt;

## 我碰到的错误

&lt;pre&gt;`echo mb_detect_encoding($passengers);
$json = str_replace(&apos;&amp;amp;quot;&apos;, &apos;&quot;&apos;, $passengers);
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[商业模式]]></title>
      <url>http://www.wulai.me/2016/01/03/e5-95-86-e4-b8-9a-e6-a8-a1-e5-bc-8f/</url>
      <content type="html"><![CDATA[<p>不能够形成一个生态的商业模式都是危险的。可能就是庞氏骗局或者传销</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[版本管理，外部定义]]></title>
      <url>http://www.wulai.me/2015/12/08/e7-89-88-e6-9c-ac-e7-ae-a1-e7-90-86-ef-bc-8c-e5-a4-96-e9-83-a8-e5-ae-9a-e4-b9-89/</url>
      <content type="html"><![CDATA[<ul>
<li>git我用git submodule，</li>
<li>svn我用externals</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[删除数据库下所有表]]></title>
      <url>http://www.wulai.me/2015/11/26/e5-88-a0-e9-99-a4-e6-95-b0-e6-8d-ae-e5-ba-93-e4-b8-8b-e6-89-80-e6-9c-89-e8-a1-a8/</url>
      <content type="html"><![CDATA[<pre><code>use information_schema;
select concat(&apos;drop table &apos;,table_name,&apos;;&apos;) from TABLES where table_schema=&apos;tt365&apos;;
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[删除指定时间之后的文章]]></title>
      <url>http://www.wulai.me/2015/11/23/e5-88-a0-e9-99-a4-e6-8c-87-e5-ae-9a-e6-97-b6-e9-97-b4-e4-b9-8b-e5-90-8e-e7-9a-84-e6-96-87-e7-ab-a0/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">find . -cmin -50 -type f |xargs rm -rf</div><div class="line"></div><div class="line"># find /tmp -mtime +30 -type f -name *.sh[ab] -exec rm -f &#123;&#125; ;</div><div class="line"></div><div class="line">/tmp –设置查找的目录；</div><div class="line"></div><div class="line">-mtime +30 –设置时间为30天前；</div><div class="line"></div><div class="line">-type f –设置查找的类型为文件；</div><div class="line"></div><div class="line">-name *.sh[ab] –设置文件名称中包含sha或者shb；</div><div class="line"></div><div class="line">-exec rm -f –查找完毕后执行删除操作；</div><div class="line"></div><div class="line">`提示`：将此命令写入crontab后即可自动完成查找并删除的工作 另外的方法大同小异：</div><div class="line"></div><div class="line"># find /tmp -mtime +30 -type f | xargs rm -rf</div><div class="line"></div><div class="line"># 另外一个操作方法：</div><div class="line"></div><div class="line">find . -name &quot;*-e&quot; -exec rm &apos;&#123;&#125;&apos; +</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[互联网产品经理的必读书目有哪些？(知乎)]]></title>
      <url>http://www.wulai.me/2015/11/02/e4-ba-92-e8-81-94-e7-bd-91-e4-ba-a7-e5-93-81-e7-bb-8f-e7-90-86-e7-9a-84-e5-bf-85-e8-af-bb-e4-b9-a6-e7-9b-ae-e6-9c-89-e5-93-aa-e4-ba-9b-ef-bc-9f-e7-9f-a5-e4-b9-8e/</url>
      <content type="html"><![CDATA[<p>kentzhu，一个PM</p>
<p>著作权归作者所有。 商业转载请联系作者获得授权，非商业转载请注明出处。 作者：kentzhu 链接：<a href="http://www.zhihu.com/question/19568240/answer/13442295" target="_blank" rel="external">http://www.zhihu.com/question/19568240/answer/13442295</a> 来源：知乎</p>
<h2 id="一、产品市场"><a href="#一、产品市场" class="headerlink" title="一、产品市场"></a>一、产品市场</h2><ul>
<li>《引爆点》——产品市场与运营推广*   《长尾理论》——产品市场</li>
<li>《魔鬼经济学》——产品市场*   《影响力》——产品市场</li>
<li>《怪诞行为学》——产品市场与用户行为必读</li>
</ul>
<h2 id="二、产品设计"><a href="#二、产品设计" class="headerlink" title="二、产品设计"></a>二、产品设计</h2><ul>
<li>《用户体验的要素》——你们都懂的</li>
<li>《就这么简单》——用户体验科普*   《锦绣蓝图》——Web信息架构必读</li>
<li>《Web信息架构》——Web信息架构必读</li>
<li>《创造突破性产品》——PM启蒙读物</li>
<li>《写给大家看的设计师》——UI设计必读</li>
<li>《应需而变，设计的力量》——培养同理心</li>
<li>《简单法则》——设计思想</li>
</ul>
<h2 id="三、团队合作"><a href="#三、团队合作" class="headerlink" title="三、团队合作"></a>三、团队合作</h2><ul>
<li>《决策与判断》——换位思考<em>   《只有偏执狂才能生存》——情商</em>   《演说之禅》——气场与感染力*   《启示录》——团队</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[产品经理书单——张小龙（微信）]]></title>
      <url>http://www.wulai.me/2015/10/17/e4-ba-a7-e5-93-81-e7-bb-8f-e7-90-86-e4-b9-a6-e5-8d-95-e5-bc-a0-e5-b0-8f-e9-be-99-ef-bc-88-e5-be-ae-e4-bf-a1-ef-bc-89/</url>
      <content type="html"><![CDATA[<p>　在距离腾讯深圳总部几百公里之外的广州研发部有个奇人，他衣着朴素，面颊消瘦，语速平缓。媒体记者一般很难见到他，但是如果某个话题触动到他，交谈有时也变得异常顺利。这个人就是腾讯公司高级副总裁，“微信之父”张小龙。</p>
<p>　　张小龙会要求他的产品经理人手一本《乔布斯传》，也曾有人说过，如果求职者说自己看完了凯文·凯利的《失控》，面试就可以结束了。作为一名“微信先生”，张小龙平日里会看哪些书?这些书又如何影响着他对“微信”的构想呢?</p>
<p>　　“微信之父”张小龙的书单</p>
<h2 id="1、《失控》"><a href="#1、《失控》" class="headerlink" title="1、《失控》"></a>1、《失控》</h2><p>　　凯文·凯利，一位在亚洲游荡了近10年的美国人，东方激发了他对于技术的思考，最终通往哲学的终极命题。在他笔下，失控，往往意味着不确定性，容易使人感到不安，但正是不确定性和不可控性，成就了创新的源泉与进化的动因。</p>
<p>　　在广研，产品经理们人手一本《失控》，因为张小龙说过：不读《失控》的产品经理，知识结构是不完整的。在腾讯内部的演讲中，张小龙反复提及这本书启发了他的产品观 ：不与用户产生互动的产品，是失败的产品。</p>
<p>　　产品规则越简单，才越能让群体形成自发的互动。产品上线后，就有了自己的生命，会自己与海量用户互动，最后会互动出什么结果，是产品设计者不能控制的。</p>
<p>　　张小龙： 凯文•凯利的《失控》我给很多人推荐。这本书很厚，所以很多人都没有耐心的看完它，我自己也是，可是如果我们面试一个大学生，他告诉我他看完了这本书，我肯定就录用他——不过他们不知道这个秘诀。如果做互联网产品的不看一下这本书，我认为知识是不全面的。他从生物学、社会学的角度描述了一种群体效应，总的来说，结论是群体的智商低于个体智商。</p>
<p>　　这个观点不在那本书里，而是在另外一本书里，我不记得书名。一个人在组织里，组织的平均智商是低于个体智商的，个体的智商更高一些，群体会拉平这个智商。比如说在微博里，微博上多了你的智商会降低，大家认同吗?你没有发现这个变化，因为你每天降低一点。</p>
<p>　　很简单的，你每天在微博上说的话，你会发现跟大众越来越一致，别人在说什么，你也在说什么。你不会说一些大家不能理解的东西了，因为你会觉得那很突兀，会让大家不舒服。所以微博的转发那么高，自己写的那么低，就是这个原因，大家拼命的一团和气，互相夸两句。群体有趋同性。</p>
<h2 id="2、《科技想要什么》"><a href="#2、《科技想要什么》" class="headerlink" title="2、《科技想要什么》"></a>2、《科技想要什么》</h2><p>　　凯文·凯利向我们介绍了一种全新的科技观。他认为，作为整体，科技不是由线路和金属构成的一团乱麻，而是有生命力的自然形成的系统，它的起源完全可以回溯到生命的初始时期。</p>
<p>　　张小龙对原始人的生活方式充满兴趣，花工夫研究了人类的起源，人类为什么会直立行走，他还曾在知乎上提问：原始人用什么来剪指甲?广研内部对摇一摇有个专门的称呼：撸一撸。这是人类最原始的姿势，最原始的，体验往往是最好的。</p>
<p>　　为什么?张小龙说自己平时会非常留心观察三四岁小孩子，他发现他们很喜欢用iPhone与iPad，因为这两款电子产品很容易学，比如开机，虽然看不懂“滑动来解锁”，但因为触摸是人的天性，他们会下意识顺着箭头的方向用手指去滑动。“越简单，越原始，就越人性化”。</p>
<h2 id="3、《乔布斯传》"><a href="#3、《乔布斯传》" class="headerlink" title="3、《乔布斯传》"></a>3、《乔布斯传》</h2><p>　　在腾讯公司内部，张小龙被称为继马化腾之后的第二个超级产品经理，中国的乔布斯。微信4 .0推出时张小龙更新了微博签名：越简单，但越好。这是德国工业设计大师Dieter Ram崇尚的设计理念，也是乔布斯“至繁归于至简”的精神。4.0初期的朋友圈甚至没有滤镜，因为他认为：照片真实、不加修饰地反映生活即可。</p>
<p>　　微信发展早期，一些创意常被竞争对手模仿，并进化出新功能，马化腾曾问张小龙：是不是要做细化，免得别人做了那些我们没有想到的功能。张坚决否定，他说：只有做到极简，才无法被超越。 一位微信团队前成员透露，微信每个版本的设计，张小龙都会鼓励大家先做加法，再做减法，“现在你正在用的一个功能，很可能就是我们砍了300多个功能后留下的。”他说。</p>
<p>　　微信的开机画面，起初做过许多方案，大家比较倾向于两个人站在地球前，张小龙坚持就一个人，否则无法传递这款应用的用意：人很孤独，所以需要沟通。</p>
<p>　　朋友圈也是一款充满极简主义的产品，它的主色调是蓝灰色，这也是张小龙平时常穿的T恤以及广研办公室的色调。拍照片，按一下右上角相机按钮;写纯文本，长按右上角相机按钮即可，这一功能许多用户起初并不知道。“按住说话”的功能也是，说话时，其实按三秒就可以放开了。但张小龙从不说，也不担心用户不会用，“你去找，自然就能找到”。</p>
<h2 id="4、《女人的起源》"><a href="#4、《女人的起源》" class="headerlink" title="4、《女人的起源》"></a>4、《女人的起源》</h2><p>　　以男性为中心的生物学家，则用人类起源于丛林并进化为以狩猎为生的肉食动物的学说，来证明女性无论在体力和智力上，都处于从属的地位。对此，《女人的起源》首次为女性在人类进化史中的平等地位据理力争。</p>
<p>　　它开一代风气之先，力图解开人类，特别是女性的演化和起源之谜;而它提供的答案，则从女性的角度对人类的史前史做出了推测性的重构，极富革命性和破坏力。在张小龙的演讲里，他曾经向听众推荐这本书，他说：“如果你们对女性的心理研究不透彻的话，你就损失了一半的用户。”</p>
<h2 id="5、《黑客》"><a href="#5、《黑客》" class="headerlink" title="5、《黑客》"></a>5、《黑客》</h2><p>　　Steven Levy这部经典力作的25周年版从20世纪50年代早期跨越到80年代后期，追述了计算机革命中初期黑客的丰功伟绩，他们都是最聪明和最富有个性的精英。他们勇于承担风险，勇于挑战规则，并把世界推向了一个全新的发展方向。</p>
<p>　　本书更新了一些著名黑客的最新资料，包括比尔·盖茨、马克·扎克伯格、理查德·斯托曼和史蒂夫·沃兹尼亚克，并讲述了从早期计算机研究实验室到最初的家用计算机期间一些妙趣横生的故事。</p>
<p>　　在Levy的笔下，他们都是聪明而勤奋的人，他们极富想象力，他们另辟蹊径，发现了计算机工程问题的巧妙解决方案。他们都有一个共同的价值观，那就是至今仍然长盛不衰的“黑客道德”。</p>
<h2 id="6、《异类》"><a href="#6、《异类》" class="headerlink" title="6、《异类》"></a>6、《异类》</h2><p>　　在《异类》一书中，作家格拉德威尔对社会中那些成功人士进行的分析，让读者看到了一连串颇感意外的统计结果：英超联赛大部分球员都在9月至11月出生;比尔·盖茨和史蒂夫·乔布斯都出生在1955年;纽约很多著名律师事务所的开创者竟然都是犹太人后裔，并且他们的祖辈大多是在纽约的服装行业谋生。那些奇才异类，他们之所以神奇，得感谢机遇的眷顾。</p>
<p>　　不过，除了机遇之外，他们的成功还需要上辈人的文化熏陶。因此，从《异类》一书中，你能体会到机遇对成功是如此的重要。格拉德威尔为读者指出了成功之路的方向，但怎样把握这份机遇，每个人都需要仔细思考，毕竟，不同人拥有不同的机遇。在这本书中，张小龙最欣赏的则是“1万小时定律 ”，即一个人必须经过超过1万小时的训练才能达到一定的专业高度。</p>
<h2 id="7、《信息简史》"><a href="#7、《信息简史》" class="headerlink" title="7、《信息简史》"></a>7、《信息简史》</h2><p>　　现如今，信息如洪流般淹没了我们，使我们深陷信息焦虑、信息过载、信息疲劳的困扰。但回顾历史，这并不是件新鲜事，人们也总是能想出应对手段。维基百科、Google便是我们的应对之一。无论对于信息的未来持何态度，有一点是确定无疑的，即我们人类是信息的造物。</p>
<p>　　作为《混沌》、《费曼传》、《越来越快》、《牛顿传》等畅销书的作者，格雷克不仅在书中细致还原了历史细节，通俗解释了各种理论，还生动刻画了几位不为大众所知的人物：可编程计算机先驱、超越时代的查尔斯·巴贝奇，第一位程序员、诗人拜伦之女爱达·拜伦，计算机科学之父、天妒英才的阿兰·图灵，以及全书的主人公、信息论之父克劳德·香农。</p>
<h2 id="8、《数字乌托邦》"><a href="#8、《数字乌托邦》" class="headerlink" title="8、《数字乌托邦》"></a>8、《数字乌托邦》</h2><p>　　20世纪60年代早期，在美国大众眼中，计算机只是冷战中冰冷的机器，然而到了90年代互联网到来之时，计算机却呈现出一个截然不同的世界——它们模拟出了一个数字乌托邦般的协同体，而这正是曾经最反对冷战的嬉皮士们的共同愿景。本书正是探索这次非同寻常，且颇具讽刺意味的变革的第一本书。</p>
<p>　　作者挖掘出那些在旧金山湾区的先驱者——斯图尔特·布兰德和他的“全球网络”鲜为人知的故事。1968年到1998年期间，通过《全球概览》、“全球电子链接(WELL)”和最终取得巨大成功的《连线》杂志，布兰德和他的伙伴们长期扮演着旧金山嬉皮士运动和新兴科技聚集区硅谷的中间人的角色。</p>
<p>　　正由于他们富有远见的努力，反主流文化分子和科技人士一同重新定义了计算机的形象：计算机是解放自我的武器，计算机建筑了令人耳目一新的虚拟社区，计算机还让人们能更大胆地拓展社会的新疆界。</p>
<p>　　本文主体部分根据《壹读》“失控的微信先生”与《商业周刊中文版》“张小龙的盗梦空间”整理。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[产品经理入门书籍－    苏杰（淘宝）]]></title>
      <url>http://www.wulai.me/2015/10/17/e4-ba-a7-e5-93-81-e7-bb-8f-e7-90-86-e5-85-a5-e9-97-a8-e4-b9-a6-e7-b1-8d/</url>
      <content type="html"><![CDATA[<h3 id="1、人人都是产品经理"><a href="#1、人人都是产品经理" class="headerlink" title="1、人人都是产品经理"></a>1、人人都是产品经理</h3><ul>
<li>作者: 苏杰<em>   出版社: 电子工业出版社</em>   出版年: 2010年4月</li>
</ul>
<h3 id="2、启示录"><a href="#2、启示录" class="headerlink" title="2、启示录"></a>2、启示录</h3><ul>
<li>作者: [美] Marty Cagan<em>   出版社: 华中科技大学出版社</em>   出版年: 2011-5</li>
</ul>
<h3 id="3、淘宝十年产品事"><a href="#3、淘宝十年产品事" class="headerlink" title="3、淘宝十年产品事"></a>3、淘宝十年产品事</h3><ul>
<li>作者: 苏杰<em>   出版社: 电子工业出版社</em>   出版年: 2013-10-15</li>
</ul>
<h3 id="4、产品经理手册"><a href="#4、产品经理手册" class="headerlink" title="4、产品经理手册"></a>4、产品经理手册</h3><ul>
<li>作者: 琳达·哥乔斯<em>   出版社: 中国财政经济出版社</em>   出版年: 2007-1</li>
</ul>
<h3 id="5、用户体验的要素"><a href="#5、用户体验的要素" class="headerlink" title="5、用户体验的要素"></a>5、用户体验的要素</h3><ul>
<li>作者: Jesse James Garrett<em>   出版社: 机械工业出版社</em>   出版年: 2007年10月</li>
</ul>
<h3 id="6、赢在用户"><a href="#6、赢在用户" class="headerlink" title="6、赢在用户"></a>6、赢在用户</h3><ul>
<li>作者: [美]Steve Mulder / [美]Zivv Yarr<em>   出版社: 机械工业出版社</em>   出版年: 2007-08-01</li>
</ul>
<h3 id="7、统计数字会撒谎"><a href="#7、统计数字会撒谎" class="headerlink" title="7、统计数字会撒谎"></a>7、统计数字会撒谎</h3><ul>
<li>作者: [美] 达莱尔·哈夫<em>   出版社: 中国城市出版社</em>   出版年: 2009-3</li>
</ul>
<h3 id="8、未来是湿的"><a href="#8、未来是湿的" class="headerlink" title="8、未来是湿的"></a>8、未来是湿的</h3><ul>
<li>作者: [美] 克莱·舍基<em>   出版社: 中国人民大学出版社</em>   出版年: 2009-5</li>
</ul>
<h3 id="9、餐巾纸的背面"><a href="#9、餐巾纸的背面" class="headerlink" title="9、餐巾纸的背面"></a>9、餐巾纸的背面</h3><ul>
<li>作者: [美]丹·罗姆<em>   出版社: 中信出版社</em>   出版年: 2009-6</li>
</ul>
<h3 id="10、改变心理学的40项研究"><a href="#10、改变心理学的40项研究" class="headerlink" title="10、改变心理学的40项研究"></a>10、改变心理学的40项研究</h3><ul>
<li>作者: 〔美〕Roger R Hock著<em>   出版社: 中国轻工业出版社</em>   出版年: 2004-1-1</li>
</ul>
<h3 id="11、结网"><a href="#11、结网" class="headerlink" title="11、结网"></a>11、结网</h3><ul>
<li>作者: 王坚<em>   出版社: 人民邮电出版社</em>   出版年: 2010-4</li>
</ul>
<h3 id="12、轻公司"><a href="#12、轻公司" class="headerlink" title="12、轻公司"></a>12、轻公司</h3><ul>
<li>作者: 李黎 / 杜晨<em>   出版社: 中信出版社</em>   出版年: 2009-7</li>
</ul>
<h3 id="13、决策与判断"><a href="#13、决策与判断" class="headerlink" title="13、决策与判断"></a>13、决策与判断</h3><ul>
<li>作者: 斯科特·普劳斯<em>   出版社: 人民邮电出版社</em>   出版年: 2004-9</li>
</ul>
<h3 id="14、中国历代政治得失"><a href="#14、中国历代政治得失" class="headerlink" title="14、中国历代政治得失"></a>14、中国历代政治得失</h3><ul>
<li>作者: 钱穆<em>   出版社: 生活·读书·新知三联书店</em>   出版年: 2001</li>
</ul>
<h3 id="15、学会提问"><a href="#15、学会提问" class="headerlink" title="15、学会提问"></a>15、学会提问</h3><ul>
<li>作者: 布朗<em>   出版社: 中国轻工业出版社</em>   出版年: 2006-1</li>
</ul>
<h3 id="16、别做正常的傻瓜"><a href="#16、别做正常的傻瓜" class="headerlink" title="16、别做正常的傻瓜"></a>16、别做正常的傻瓜</h3><ul>
<li>作者: 奚恺元<em>   出版社: 机械工业出版社</em>   出版年: 2006-8</li>
</ul>
<h3 id="17、大脑使用说明书"><a href="#17、大脑使用说明书" class="headerlink" title="17、大脑使用说明书"></a>17、大脑使用说明书</h3><ul>
<li>作者: 东尼•博赞<em>   出版社: 外语教学与研究出版社</em>   出版年: 2005-4-1</li>
</ul>
<h3 id="18、About-Face-3-交互设计精髓"><a href="#18、About-Face-3-交互设计精髓" class="headerlink" title="18、About Face 3 交互设计精髓"></a>18、About Face 3 交互设计精髓</h3><ul>
<li>作者: Alan Cooper / Robert Reimann / David Cronin<em>   出版社: 电子工业出版社</em>   出版年: 2008-11</li>
</ul>
<h3 id="19、美第奇效应-7-6-144人评价"><a href="#19、美第奇效应-7-6-144人评价" class="headerlink" title="19、美第奇效应 7.6 (144人评价)"></a>19、美第奇效应 7.6 (144人评价)</h3><ul>
<li>作者: 弗朗斯·约翰松<em>   出版社: 商务印书馆发行部</em>   出版年: 2006-3</li>
</ul>
<h3 id="20、锦绣蓝图"><a href="#20、锦绣蓝图" class="headerlink" title="20、锦绣蓝图"></a>20、锦绣蓝图</h3><ul>
<li>作者: [美] 沃德科 (Christina Wodtke) / [美] 戈夫拉 (Austin Govella)<em>   出版社: 人民邮电出版社</em>   出版年: 2009-11-01</li>
</ul>
<h3 id="21、罗伯特议事规则"><a href="#21、罗伯特议事规则" class="headerlink" title="21、罗伯特议事规则"></a>21、罗伯特议事规则</h3><ul>
<li>作者: 亨利·罗伯特<em>   出版社: 世纪出版集团 格致出版社</em>   出版年: 2008年1月</li>
</ul>
<h3 id="22、博弈论的诡计"><a href="#22、博弈论的诡计" class="headerlink" title="22、博弈论的诡计"></a>22、博弈论的诡计</h3><ul>
<li>作者: 王春永<em>   出版社: 中国发展</em>   出版年: 2007-1-1</li>
</ul>
<h3 id="23、经济学原理（上下）"><a href="#23、经济学原理（上下）" class="headerlink" title="23、经济学原理（上下）"></a>23、经济学原理（上下）</h3><ul>
<li>作者: [美] 曼昆<em>   出版社: 生活·读书·新知三联书店 北京大学出版社</em>   出版年: 2001-12</li>
</ul>
<h3 id="24、人月神话"><a href="#24、人月神话" class="headerlink" title="24、人月神话"></a>24、人月神话</h3><ul>
<li>作者: [美] 弗雷德里克·布鲁克斯<em>   出版社: 清华大学出版社</em>   出版年: 2002-11</li>
</ul>
<h3 id="25、人件"><a href="#25、人件" class="headerlink" title="25、人件"></a>25、人件</h3><ul>
<li>作者: Tom DeMarco / Timothy Lister<em>   出版社: 清华大学出版社</em>   出版年: 2003</li>
</ul>
<h3 id="26、麦肯锡方法"><a href="#26、麦肯锡方法" class="headerlink" title="26、麦肯锡方法"></a>26、麦肯锡方法</h3><ul>
<li>作者: （美）埃森・M・拉塞尔<em>   出版社: 华夏出版社</em>   出版年: 2001-1</li>
</ul>
<h3 id="27、影响力"><a href="#27、影响力" class="headerlink" title="27、影响力"></a>27、影响力</h3><ul>
<li>作者: [美] 罗伯特·西奥迪尼<em>   出版社: 中国人民大学出版社</em>   出版年: 2006-5</li>
</ul>
<h3 id="28、维基经济学"><a href="#28、维基经济学" class="headerlink" title="28、维基经济学"></a>28、维基经济学</h3><ul>
<li>作者: [加] 唐·泰普斯科特 / [英] 安东尼·D·威廉姆斯<em>   出版社: 中国青年出版社</em>   出版年: 2007-10</li>
</ul>
<h3 id="29、世界是平的"><a href="#29、世界是平的" class="headerlink" title="29、世界是平的"></a>29、世界是平的</h3><ul>
<li>作者: [美] 托马斯·弗里德曼<em>   出版社: 湖南科学技术出版社</em>   出版年: 2006-11</li>
</ul>
<h3 id="30、长尾理论"><a href="#30、长尾理论" class="headerlink" title="30、长尾理论"></a>30、长尾理论</h3><ul>
<li>作者: [美] 克里斯·安德森<em>   出版社: 中信出版社</em>   出版年: 2006-12</li>
</ul>
<h3 id="31、点石成金"><a href="#31、点石成金" class="headerlink" title="31、点石成金"></a>31、点石成金</h3><ul>
<li>作者: [美] 史蒂夫·克鲁克<em>   出版社: 机械工业出版社</em>   出版年: 2006-8</li>
</ul>
<h3 id="32、交互设计之路"><a href="#32、交互设计之路" class="headerlink" title="32、交互设计之路"></a>32、交互设计之路</h3><ul>
<li>作者: 库帕<em>   出版社: 电子工业出版社</em>   出版年: 2006-3</li>
</ul>
<h3 id="33、引爆点"><a href="#33、引爆点" class="headerlink" title="33、引爆点"></a>33、引爆点</h3><ul>
<li>作者: [美] 马尔科姆·格拉德威尔<em>   出版社: 中信出版社</em>   出版年: 2006-1</li>
</ul>
<h3 id="34、情感化设计"><a href="#34、情感化设计" class="headerlink" title="34、情感化设计"></a>34、情感化设计</h3><ul>
<li>作者: [美] Donald A.Norman；<em>   出版社: 电子工业出版社</em>   出版年: 2005-5</li>
</ul>
<h3 id="35、水平营销"><a href="#35、水平营销" class="headerlink" title="35、水平营销"></a>35、水平营销</h3><ul>
<li>作者: 陈燕茹 / 菲利普・科特勒 / 费尔南多・德・巴斯<em>   出版社: 中信出版社</em>   出版年: 2005-1</li>
</ul>
<h3 id="36、设计心理学"><a href="#36、设计心理学" class="headerlink" title="36、设计心理学"></a>36、设计心理学</h3><ul>
<li>作者: Donald Norman<em>   出版社: 中信出版社</em>   出版年: 2003-10-1</li>
</ul>
<h3 id="37、万历十五年"><a href="#37、万历十五年" class="headerlink" title="37、万历十五年"></a>37、万历十五年</h3><ul>
<li>作者: [美] 黄仁宇<em>   出版社: 生活·读书·新知三联书店</em>   出版年: 1997-5</li>
</ul>
<h3 id="38、公司进化论"><a href="#38、公司进化论" class="headerlink" title="38、公司进化论"></a>38、公司进化论</h3><ul>
<li>作者: [美]杰弗里.摩尔<em>   出版社: 机械工业出版社</em>   出版年: 2007-5</li>
</ul>
<h3 id="39、黑天鹅"><a href="#39、黑天鹅" class="headerlink" title="39、黑天鹅"></a>39、黑天鹅</h3><ul>
<li>作者: [美] 纳西姆·尼古拉斯·塔勒布<em>   出版社: 中信出版社</em>   出版年: 2008-5</li>
</ul>
<h3 id="40、沸腾十五年"><a href="#40、沸腾十五年" class="headerlink" title="40、沸腾十五年"></a>40、沸腾十五年</h3><ul>
<li>作者: 林军<em>   出版社: 中信出版社</em>   出版年: 2009-7</li>
</ul>
<h3 id="40、金字塔原理"><a href="#40、金字塔原理" class="headerlink" title="40、金字塔原理"></a>40、金字塔原理</h3><ul>
<li>作者: [美] 巴巴拉·明托<em>   出版社: 民主与建设出版社</em>   出版年: 2002-12</li>
</ul>
<h3 id="41、枪炮、病菌与钢铁"><a href="#41、枪炮、病菌与钢铁" class="headerlink" title="41、枪炮、病菌与钢铁"></a>41、枪炮、病菌与钢铁</h3><ul>
<li>作者: [美] 贾雷德·戴蒙德<em>   出版社: 上海译文出版社</em>   出版年: 2006-4-1</li>
</ul>
<h3 id="42、失控"><a href="#42、失控" class="headerlink" title="42、失控"></a>42、失控</h3><ul>
<li>作者: [美] 凯文·凯利<em>   出版社: 新星出版社</em>   出版年: 2010-12</li>
</ul>
<h3 id="45、思考的技术"><a href="#45、思考的技术" class="headerlink" title="45、思考的技术"></a>45、思考的技术</h3><ul>
<li>作者: 大前研一<em>   出版社: 中信出版社</em>   出版年: 2008年7月</li>
</ul>
<h3 id="46、浪潮之巅"><a href="#46、浪潮之巅" class="headerlink" title="46、浪潮之巅"></a>46、浪潮之巅</h3><ul>
<li>作者: 吴军<em>   出版社: 电子工业出版社</em>   出版年: 2011-8</li>
</ul>
<h3 id="47、黑客与画家"><a href="#47、黑客与画家" class="headerlink" title="47、黑客与画家"></a>47、黑客与画家</h3><ul>
<li>作者: [美] Paul Graham<em>   出版社: 人民邮电出版社</em>   出版年: 2011-4</li>
</ul>
<h3 id="48、四步创业法"><a href="#48、四步创业法" class="headerlink" title="48、四步创业法"></a>48、四步创业法</h3><ul>
<li>作者: [美] Steven Gary Blank<em>   出版社: 华中科技大学出版社</em>   出版年: 2012-8-1</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[mysql 查看备注]]></title>
      <url>http://www.wulai.me/2015/10/06/mysql-e6-9f-a5-e7-9c-8b-e5-a4-87-e6-b3-a8/</url>
      <content type="html"><![CDATA[<h2 id="简单的用法"><a href="#简单的用法" class="headerlink" title="简单的用法"></a>简单的用法</h2><pre><code>SELECT
COLUMN_NAME,
COLUMN_COMMENT  AS  `备注`
FROM information_schema.COLUMNS WHERE TABLE_NAME=&apos;pw_admin_role&apos;
`&lt;/pre&gt;

### 复杂的用法

&lt;pre&gt;`SELECT
COLUMN_NAME,
DATA_TYPE AS `数据类型`,
CHARACTER_MAXIMUM_LENGTH  AS `字符长度`,
NUMERIC_PRECISION AS `数字长度`,
NUMERIC_SCALE AS `小数位数`,
IS_NULLABLE AS `是否允许非空`,
CASE WHEN EXTRA = &apos;auto_increment&apos; THEN 1 ELSE 0 END AS `是否自增`,
COLUMN_DEFAULT  AS  `默认值`,
COLUMN_COMMENT  AS  `备注`
FROM information_schema.COLUMNS WHERE TABLE_NAME=&apos;pw_admin_role&apos;
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Ryan Hall 教学视频]]></title>
      <url>http://www.wulai.me/2015/09/29/ryan-hall-e6-95-99-e5-ad-a6-e8-a7-86-e9-a2-91/</url>
      <content type="html"><![CDATA[<p>后踢腿训练和高抬腿训练 <a href="http://v.youku.com/v_show/id_XMzA0Njc4OTQ0.html" target="_blank" rel="external">http://v.youku.com/v_show/id_XMzA0Njc4OTQ0.html</a></p>
<p>慢速高抬腿</p>
<p><a href="http://v.youku.com/v_show/id_XMzA0Njc4ODg0.html" target="_blank" rel="external">http://v.youku.com/v_show/id_XMzA0Njc4ODg0.html</a></p>
<p>掌握正确跑步姿势 <a href="http://v.youku.com/v_show/id_XMzA0Njc4Nzky.html" target="_blank" rel="external">http://v.youku.com/v_show/id_XMzA0Njc4Nzky.html</a></p>
<p>头部基准 <a href="http://v.youku.com/v_show/id_XMzA0Njc4NzUy.html" target="_blank" rel="external">http://v.youku.com/v_show/id_XMzA0Njc4NzUy.html</a></p>
<p>动态拉伸训练 <a href="http://v.youku.com/v_show/id_XMzA0Njc4NjIw.html" target="_blank" rel="external">http://v.youku.com/v_show/id_XMzA0Njc4NjIw.html</a></p>
<p>中速高抬腿训练 <a href="http://v.youku.com/v_show/id_XMzA0Njc4NTUy.html" target="_blank" rel="external">http://v.youku.com/v_show/id_XMzA0Njc4NTUy.html</a></p>
<p>臂部基准 <a href="http://v.youku.com/v_show/id_XMzA0Njc4NTc2.html" target="_blank" rel="external">http://v.youku.com/v_show/id_XMzA0Njc4NTc2.html</a></p>
<p>长距离间歇跑训练 <a href="http://v.youku.com/v_show/id_XMzA0Njc4NTA4.html" target="_blank" rel="external">http://v.youku.com/v_show/id_XMzA0Njc4NTA4.html</a></p>
<p>提高成绩的冲刺练习 <a href="http://v.youku.com/v_show/id_XMzA0Njc4NDMy.html" target="_blank" rel="external">http://v.youku.com/v_show/id_XMzA0Njc4NDMy.html</a></p>
<p>短距离间歇跑训练 <a href="http://v.youku.com/v_show/id_XMzA0Njc4MzQ0.html" target="_blank" rel="external">http://v.youku.com/v_show/id_XMzA0Njc4MzQ0.html</a></p>
<p>节奏跑 <a href="http://v.youku.com/v_show/id_XMzA0Njc4Mjk2.html" target="_blank" rel="external">http://v.youku.com/v_show/id_XMzA0Njc4Mjk2.html</a></p>
<p>高抬腿训练 <a href="http://v.youku.com/v_show/id_XMzA0Njc4MjY0.html" target="_blank" rel="external">http://v.youku.com/v_show/id_XMzA0Njc4MjY0.html</a></p>
<p>马拉松模拟训练 <a href="http://v.youku.com/v_show/id_XMzA0Njc4MjI0.html" target="_blank" rel="external">http://v.youku.com/v_show/id_XMzA0Njc4MjI0.html</a></p>
<p>直腿交叉曲腿交叉与跑步 <a href="http://v.youku.com/v_show/id_XMzA0Njc4MTQw.html" target="_blank" rel="external">http://v.youku.com/v_show/id_XMzA0Njc4MTQw.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[破解步频和步幅统一的难题！（转）]]></title>
      <url>http://www.wulai.me/2015/09/29/e7-a0-b4-e8-a7-a3-e6-ad-a5-e9-a2-91-e5-92-8c-e6-ad-a5-e5-b9-85-e7-bb-9f-e4-b8-80-e7-9a-84-e9-9a-be-e9-a2-98-ef-bc-81-ef-bc-88-e8-bd-ac-ef-bc-89/</url>
      <content type="html"><![CDATA[<p>速度 = 步频 × 步幅，一条极为简单而又冰冷的公式。</p>
<p>要跑得快，你可以提高步频，或者加大步幅，或者两者兼有，貌似很简单。但是这个问题，已经被反复讨论了几十年，主要在于，步频与步幅，是两个相互制约的因素。你很难完全撇开一个因素，谈论如何改进另一个因素。</p>
<p>你一步两米顶人家两步，人家却可以小鸡啄米似的怎么也甩不掉，正是说明了步幅与步频的对立关系。如果你既大步流星，同时也小鸡啄米，那恭喜你，实力上了两个台阶不止，冲300去的。</p>
<p>那我想跑的快，增加哪个更有效呢？先来看看顶尖运动员是怎么跑的：</p>
<p>2007年的世锦赛万米，贝克勒（万米世界记录保持者）与Mathathi以同样的速度跑了前面九千米。贝克勒身高1.63米，步频190/分钟。在最后的一公里冲刺阶段，他的步幅不变，步频提高到惊人的216/分钟，一举摘金。Mathathi身高1.7米，步频接近200/分钟，在最后冲刺阶段，加大了步幅，步频反而下降，维持速度不变（后来他表示最后没有提速，是疲劳所致）。</p>
<p>而女子万米记录保持者王军霞，则是典型的全程高频率跑法，她的平均步频达到209/分钟。在冲刺阶段，她一般采用加大步幅，步频不变的方式。</p>
<p>上述例子说明，首先，专业运动员的步频都很高。而且，他们可以根据需要调节步频/步幅的节奏。</p>
<p>那么，业余跑者，应该怎么跑呢？</p>
<p>运动生化检测表明，长跑运动员在同一速度下用不同的步频步幅跑步时，摄氧水平呈现U型，既过高和过低的步频都会增加摄氧水平。也就是说，对某个运动员，确实存在着最经济的步频。欧美的跑风盛行，跑步教材多如牛毛，他们经常提到一个“标准步频”：180/分钟。他们宣称，达到或接近这个步频，是每一个长跑者应该改进的技术。据我自己观察，大部分业余跑者的步频达不到这个数字，包括一些全马进了二级的快马。业余跑者中普遍存在的一个问题，就是过大的步幅，把步频限制在不经济的低水平，同时也带来伤痛增加等其他负面作用。</p>
<h2 id="【步幅过大】"><a href="#【步幅过大】" class="headerlink" title="【步幅过大】"></a>【步幅过大】</h2><p>我们需要先对“步幅过大”进行定义。所谓步幅过大，就是如图这样右侧的跑法：过度前伸的小腿，打直的膝盖，脚跟的重落地。不幸的是，这样的跑法实在太常见。</p>
<p>而合适的步幅，则应该是如图左侧的跑法：中前掌落地，落地点靠近重心，主动下压、扒地。</p>
<p><img src="http://res.hillock.com.cn/web/100000094_141359.jpg" alt="enter image description here"></p>
<p>步幅过大的坏处是显而易见的：明显的刹车作用，过长的支撑时间，完全抵消了大步幅带来的好处；还显著增加的震动的传导。</p>
<p>事实上，扒地与后蹬动作中的向前分量，是跑步前进的唯一动力。任何跑步技术的改进，都必须针对如何加强这个唯一动力。极端的例子如短跑，步幅是所有跑步中最大的，但是他的落地点也是很靠近身体重心的，目的就在于避免刹车作用，尽量缩短支撑时间，并为强大的扒地与后蹬提供结构条件，如图所示，短跑运动员绝对不会把小腿打直了伸到前面去！</p>
<p><img src="http://res.hillock.com.cn/web/100000094_141456.jpg" alt="enter image description here"></p>
<p>再看看顶尖长距离运动员的落地方式，无一例外，均是中前掌落地，靠近身体，折叠膝关节，主动下压。</p>
<p><img src="http://res.hillock.com.cn/web/100000094_141610.jpg" alt="enter image description here"></p>
<p>再来看看定量的对比： 业余跑者，很大比例是小腿前伸，有些甚至超出15°，而专业高手多是负的角度。脚一着地即可发力，避免了被动支撑重心跟进的阶段，单足触地时间可以达到0.15秒以内。 <img src="http://res.hillock.com.cn/web/100000094_141655.jpg" alt="enter image description here"></p>
<p>步幅过大的问题，牵涉到一个大家经常讨论的另一个问题：就是中前掌落地还是脚跟落地，这个问题跑友争论激烈互不认同。我认为，只要你把落地点靠近身体，中前掌落地就是自然而言的事。而后跟落地也不是什么大不了一定要克服的习惯，只要落地点OK，就已经大大提高了跑步的效率。</p>
<p>至此，我的观点是，业余跑者改进跑步技术的第一步，就是避免步幅过大。</p>
<h2 id="【提高步幅】"><a href="#【提高步幅】" class="headerlink" title="【提高步幅】"></a>【提高步幅】</h2><p>避免了步幅过大，就开始着手解决如何把步频提高170-180，或曰适合自己的经济步频。</p>
<p>步频与力量、神经类型相关。跑步的时候，对抗肌收缩与舒张快速交替运动，这就要求大脑皮层运动中枢的兴奋与抑制过程迅速转换。据观察，一个短跑选手，他的固有步频在年纪很小的时候就形成了，要改起来，还真不是很容易。我以前曾和体育教练前往中学选材，教练并不看百米成绩，要求进行原地高抬腿频率测试，对频率高的再进行重点关注和其他测试。这就是神经类型是短跑天赋的最大因素的道理，放到中长跑，这个素质仍然是至关重要的。</p>
<p>业余跑者，大多是半路出家，未受过跑步训练。要提高步频，途径之一是逐渐习惯这种快速转换，比如经常进行一些200米之类的反复冲刺跑，体会跑步的协调发力。专业马拉松运动员，一般很少进行这么短距离的练习，而跑吧佟强的计划就有此类练习，正是这个道理。</p>
<p>至于力量，跑步要求的不是那种深蹲之类的绝对静力量，而是运动中的协调用力。形象地说，就是要鹿的力量，不要牛的力量。要练习的途径包括高抬腿跑，后踢腿跑，不屈膝小跳上楼梯，沙地跑等等。</p>
<p>业余跑者的触地时间较长，下肢结构缺乏弹性，也是原因之一。如果你的下肢是一块海绵，吸收了落地的大部分震动，却没有提供力量回馈，就如跑沙地一样，当然跑不快！想跑得快，你就要提高结构的刚性，把你的下肢结构变为一个弹力球。措施包括：不要穿太软的跑鞋（保护是否足够的问题，暂不探讨），增强下肢小肌群，保持足弓的弹性等等。自由泳教练，最头痛的就是学员的脚打不直，称之为跑步脚（如图），但是这个“跑步脚”却是天然的跑步弹力装置，一触即走，绝不拖泥带水。要提高足部结构的刚性，推荐进行越野跑，你不得不随时调整步频步幅，左冲右突凌波微步，练习效果十分明显。</p>
<p>提高频率的时候还要注意，我们要的是放松、协调的高频，不是生硬、刻意的高频。正如最高效率的前进方式是滚动，你的双腿应该是“主动下压落地—扒地—后蹬—放松后扬—屈膝送髋”这样的过程，想象你穿上锁鞋骑自行车，双腿不是下压上提，而是随时进行圆周运动，沿切线方向发力。什么时候你跑步跑出了这种滚动的感觉，那肯定比别人要轻松！</p>
<p>就我自己而言，170-180的步频是很自然的状态，如果是短距离比赛，就会更高一些。所有跑友都应该测量一下自己的步频，明显低于170-180的，不妨先从提高步频做起，稍微习惯一下，你就会发现跑得更省力了。</p>
<p>当然，步频的提高是有限度的，限度则取决于你的神经协调性、身体结构和力量。理论上，人的肌肉1/3的最大收缩速度下运动最为高效，这相当于每分钟180-200步。</p>
<h2 id="【加大步幅】"><a href="#【加大步幅】" class="headerlink" title="【加大步幅】"></a>【加大步幅】</h2><p>现在，你既修正了步幅过大的毛病，又习惯了高效率的步频，再想跑得更快的，那就很简单了，唯有加大步幅。什么？好不容易把步幅缩短了现在又要加大？呵呵，事物总是螺旋式上升嘛。好消息是，如能按正确方式加大步幅，你就能把以前的自己甩得老远！坏消息是，加大步幅，最难。</p>
<p>步幅，是力量、柔韧性、协调性的函数，其中又以力量最为关键。</p>
<p>加大步幅，无非是就是“积极前摆，充分送髋，快速下压，主动扒地，加强后蹬”，每一样都是以力量为基础！逐个注释如下：</p>
<p>1&#46;步幅大，说明动作幅度大。前摆幅度与后蹬幅度相互制约，后蹬之后不放松，又限制大小腿折叠角度，导致前摆不充分，真是一环扣一环。</p>
<p>2&#46;所谓送髋，就是以骨盆的转动带动摆腿。躯干，是几乎所有全身运动的发力核心，跑步也是如此。越来越多跑友重视核心力量，是个好现象。不跑步那天去做个飞燕、拱桥啥的，真是挺不错。不过我个人认为，动态的力量练习比静态的好，比如划船机就是个很好的核心力量的练习。</p>
<p>3&#46;主动下压扒地，貌似是减小了步幅，实际却是相反，因为后蹬被加强了。后蹬是跑步动作中最主要的驱动，下压扒地就是其准备动作。后蹬越强，前进性就越好，不必要的上下跳动就越少。这里比较一下Ryan Hall与Samuel Kamau，前者大家熟知，录制了很多教学视频；后者更是超一流选手，北京奥运冠军，半马59分以内。Samuel Kamau明显矮一些，但是他的后蹬角度很恐怖（我今天贴图的额度用完了，只能文字描述下：他的后蹬摆腿达到106°，而前者是90°），两个人的步幅差不多大。Ryan Hall每步要上下跳动4英寸，一个全马下来，光累积跳高就接近80层大楼的高度。每加大1°，就能增加2%的步幅，并能有效减少滞空时间。一个马拉松几万步，累积起来不得了啊。有限的能量，必须尽量的向前、向前、再向前！</p>
<p>总而言之，加大步幅是一个连贯的过程，不是强调动作的某一个阶段，在任何加大步幅的尝试之前，请确认你的跑步是稳定和平衡的。加大步幅更不是单纯的蹦跶延长滞空时间，而是通过技术与身体结构的结合，比如送髋和后蹬这些来实现高而平稳的重心。老黑步幅既大，步频又快，正是这个原因。 下面这些常见的不良习惯是制约步幅加大的：</p>
<ol>
<li>肩带肌肉紧张，上臂几乎不动，只是前臂小幅摆动。</li>
<li>过分强调经济性，自我限制下肢摆动幅度。</li>
<li>小腿过度前伸，脚跟触地时间过长，损失弹性，动力不足。</li>
<li>跑后不注重拉伸，韧带紧张僵硬，限制动作幅度。</li>
</ol>
<p>日复一日地路跑，而不进行专项力量练习，自然事倍功半。要加大步幅，主要在于加强躯干和下肢力量。有强大的结构，才可以吸收震动保护关节；强大的腿部向心力量，离地腿才可以快速前摆；强大的腿部离心力量，才可以主动下压引导后蹬。总之，你要变得强大。</p>
<ol>
<li>还是那句话，动态练优于静力练习。多组数的上台阶，跑坡，跳跃，短距离跑，都是有效途径。</li>
<li>有条件时不时去跑一次越野路面，更是可以全面均衡发展。</li>
<li>跑步机，就是最好的跑坡（没有下坡跑的伤害，稳定而持续的坡度，可以调节）。</li>
<li>交叉训练必不可少，推荐网球（急停急起、、反复冲刺、腰腹发力），足球篮球不推荐（强对抗容易受伤，养伤太久）。</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[跑步前后拉伸，记住几张图片]]></title>
      <url>http://www.wulai.me/2015/09/12/e8-b7-91-e6-ad-a5-e5-89-8d-e5-90-8e-e6-8b-89-e4-bc-b8-ef-bc-8c-e8-ae-b0-e4-bd-8f-e5-87-a0-e5-bc-a0-e5-9b-be-e7-89-87/</url>
      <content type="html"><![CDATA[<p><img src="http://res.hillock.com.cn/web/6EPRT1IJ0HRV0092.jpg" alt="enter image description here"></p>
<p><img src="http://res.hillock.com.cn/web/6EPRT2PA0HRV0092.jpg" alt="enter image description here"></p>
<p><img src="http://res.hillock.com.cn/web/6EPRT2650HRV0092.jpg" alt="enter image description here"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[马拉松运动员的伸展运动]]></title>
      <url>http://www.wulai.me/2015/09/10/e9-a9-ac-e6-8b-89-e6-9d-be-e8-bf-90-e5-8a-a8-e5-91-98-e7-9a-84-e4-bc-b8-e5-b1-95-e8-bf-90-e5-8a-a8/</url>
      <content type="html"><![CDATA[<h3 id="1、-腓肠肌"><a href="#1、-腓肠肌" class="headerlink" title="1、 腓肠肌"></a>1、 腓肠肌</h3><p>拉长或伸展小腿后方的腓肠肌和比目鱼肌。</p>
<ul>
<li>开始姿势</li>
</ul>
<p>右脚在前，身体呈“半冲刺”姿势，面对或背对墙站立。脚应该平行站立且保持与髋同宽，手扶在墙上。</p>
<p><img src="http://res.hillock.com.cn/web/0701091.jpg" alt="enter image description here"></p>
<h3 id="2、-伸展比目鱼肌"><a href="#2、-伸展比目鱼肌" class="headerlink" title="2、 伸展比目鱼肌"></a>2、 伸展比目鱼肌</h3><p>像腓肠肌伸展运动的开始姿势一样站立，但稍屈后膝，从而加强对后腿比目鱼肌的伸展。</p>
<p><img src="http://res.hillock.com.cn/web/0701092.jpg" alt="enter image description here"></p>
<h3 id="3、-股四头肌"><a href="#3、-股四头肌" class="headerlink" title="3、 股四头肌"></a>3、 股四头肌</h3><p>拉长或伸展股四头肌的前侧肌肉。如果臀部是倾斜着向前，这种方法也可以伸展臀部的屈肌。</p>
<ul>
<li>开始姿势和伸展运动</li>
</ul>
<p>左脚站立，扶墙或依靠同伴保持身体平衡，如果需要的话，右腿弯曲，并用右手握住踝关节，用力使脚后跟尽量靠近臀大肌，持续一段时间（可用自己的手提高动作的幅度）。换右脚做相同的动作。通过伸展运动，保证奔跑时提臀，还可以发展股四头肌后侧部分。</p>
<p><img src="http://res.hillock.com.cn/web/0701093.jpg" alt="enter image description here"></p>
<h3 id="4、-大腿内侧内收肌"><a href="#4、-大腿内侧内收肌" class="headerlink" title="4、 大腿内侧内收肌"></a>4、 大腿内侧内收肌</h3><p>拉长或伸展大腿内侧内收肌的肌肉。</p>
<ul>
<li>开始姿势和伸展运动</li>
</ul>
<p>坐在地上，挺直后背。如果需要的话，背靠着一面墙。两只脚的脚底相对，让膝盖上部逐渐靠近墙，直到你的大腿内侧和腹股沟得到完全的伸展为止。双手不仅能放在背后的地面上，帮助保持脊椎骨垂直的姿势；而且还能习惯压你的双膝内侧，以些增加伸展的力度（这种伸展活动可供选择的办法是增加你大腿的宽度和垂直度，并通过施加在膝盖内侧的压力使腿与手更容易分开）。</p>
<p><img src="http://res.hillock.com.cn/web/0701094.jpg" alt="enter image description here"></p>
<h3 id="5、-跟腱（大腿后面的跟腱）"><a href="#5、-跟腱（大腿后面的跟腱）" class="headerlink" title="5、 跟腱（大腿后面的跟腱）"></a>5、 跟腱（大腿后面的跟腱）</h3><p>拉长或伸展大腿后面跟腿。</p>
<ul>
<li>开始姿势和伸展运动</li>
</ul>
<p>上体正直坐在地板上，伸出右腿放在体前－－但膝关节不能完全“锁住”。左腿弯曲且稍微外展。从臀部向前弯曲，直到感觉右大腿后面的肌肉伸长。当轻轻地向前倾斜时，腰要挺直，头部保持不动，重复另外一侧。你也可以站着，把一条腿搁在膝盖高度的长凳上做这个锻炼。</p>
<p><img src="http://res.hillock.com.cn/web/0701095.jpg" alt="enter image description here"></p>
<h3 id="6、臀大肌"><a href="#6、臀大肌" class="headerlink" title="6、臀大肌"></a>6、臀大肌</h3><p>拉长或伸展臀部肌肉</p>
<ul>
<li>开始姿势和伸展运动</li>
</ul>
<p>躺在地板上左腿伸直，或者坐在地板上挺直后背，左腿伸直，右腿弯曲越过左腿，并与左腿交叉，脚尽可能舒适地靠近身体。用你的左臂裹住右腿。膝盖向身体靠拢直到感到右侧臀大肌被伸展。保持一会儿，然后重复另一侧。</p>
<p><img src="http://res.hillock.com.cn/web/0701096.jpg" alt="enter image description here"></p>
<h3 id="7、髂腰肌"><a href="#7、髂腰肌" class="headerlink" title="7、髂腰肌"></a>7、髂腰肌</h3><p>拉长或伸展髂腰肌－－从骨盆和腰脊柱直到大腿骨前面的肌肉。</p>
<ul>
<li>开始姿势和伸展运动</li>
</ul>
<p>跪在地面上，右腿成弓步姿势，大腿与地面保持平行，左腿的膝关节跪在地面上。按压臀部直至感觉到伸展为止。为了保持身体平衡，可以把手放在臀部上、右膝上或地面上。保持向上提腰，上体挺直，然后，换另一侧做同样的动作。</p>
<p><img src="http://res.hillock.com.cn/web/0701097.jpg" alt="enter image description here"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Cannot start PhantomJS  karma]]></title>
      <url>http://www.wulai.me/2015/08/14/220/</url>
      <content type="html"><![CDATA[<h2 id="1、错误信息"><a href="#1、错误信息" class="headerlink" title="1、错误信息"></a>1、错误信息</h2><pre><code>Running &quot;karma:unit&quot; (karma) task
INFO [karma]: Karma v0.12.37 server started at http://localhost:9876/
INFO [launcher]: Starting browser PhantomJS
ERROR [launcher]: Cannot start PhantomJS

INFO [launcher]: Trying to start PhantomJS again (1/2).
ERROR [launcher]: Cannot start PhantomJS

INFO [launcher]: Trying to start PhantomJS again (2/2).
ERROR [launcher]: Cannot start PhantomJS

ERROR [launcher]: PhantomJS failed 2 times (cannot start). Giving up.
Warning: Task &quot;karma:unit&quot; failed. Used --force, continuing.

Done, but with warnings.
`&lt;/pre&gt;

## 2、系统ubuntu 14.04

## 3、解决方案

&lt;pre&gt;`sudo apt-get install libfontconfig
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ubuntu安装gem grunt-contrib-sass]]></title>
      <url>http://www.wulai.me/2015/08/09/ubuntu-e5-ae-89-e8-a3-85gem/</url>
      <content type="html"><![CDATA[<pre><code># Install gem sass for grunt-contrib-sass
RUN apt-get update -qq &amp;amp;&amp;amp; apt-get install -y build-essential
RUN apt-get install -y ruby
RUN gem install sass
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[如何删除docker images/containers]]></title>
      <url>http://www.wulai.me/2015/08/08/e5-a6-82-e4-bd-95-e5-88-a0-e9-99-a4docker-imagescontainers/</url>
      <content type="html"><![CDATA[<h2 id="1-46-进入root权限"><a href="#1-46-进入root权限" class="headerlink" title="1&#46;进入root权限"></a>1&#46;进入root权限</h2><pre><code>sudo su
`&lt;/pre&gt;

## 2&amp;#46;停止所有的container，这样才能够删除其中的images：

&lt;pre&gt;`docker stop $(docker ps -a -q)
`&lt;/pre&gt;

如果想要删除所有container的话再加一个指令：

&lt;pre&gt;`docker rm $(docker ps -a -q)
`&lt;/pre&gt;

## 3&amp;#46;查看当前有些什么images

&lt;pre&gt;`docker images
`&lt;/pre&gt;

## 4&amp;#46;删除images，通过image的id来指定删除谁

&lt;pre&gt;`docker rmi &amp;lt;image id&amp;gt;
`&lt;/pre&gt;

想要删除untagged images，也就是那些id为&lt;None&gt;的image的话可以用

&lt;pre&gt;`docker rmi $(docker images | grep &quot;^&amp;lt;none&amp;gt;&quot; | awk &quot;{print $3}&quot;)
`&lt;/pre&gt;

要删除全部image的话

&lt;pre&gt;`docker rmi $(docker images -q)
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Docker之常用命令 ]]></title>
      <url>http://www.wulai.me/2015/08/08/docker-e4-b9-8b-e5-b8-b8-e7-94-a8-e5-91-bd-e4-bb-a4/</url>
      <content type="html"><![CDATA[<h2 id="1-46-查看docker信息（version、info）"><a href="#1-46-查看docker信息（version、info）" class="headerlink" title="1&#46; 查看docker信息（version、info）"></a>1&#46; 查看docker信息（version、info）</h2><pre><code># 查看docker版本  
$docker version  

# 显示docker系统的信息  
$docker info  
`&lt;/pre&gt;

## 2&amp;#46; 对image的操作（search、pull、images、rmi、history）

&lt;pre&gt;`# 检索image  
$docker search image_name  

# 下载image  
$docker pull image_name  

# 列出镜像列表; -a, --all=false Show all images; --no-trunc=false Don&apos;t truncate output; -q, --quiet=false Only show numeric IDs  
$docker images  

# 删除一个或者多个镜像; -f, --force=false Force; --no-prune=false Do not delete untagged parents  
$docker rmi image_name  

# 显示一个镜像的历史; --no-trunc=false Don&apos;t truncate output; -q, --quiet=false Only show numeric IDs  
$docker history image_name  
`&lt;/pre&gt;

## 3&amp;#46; 启动容器（run）

&lt;pre&gt;`docker容器可以理解为在沙盒中运行的进程。这个沙盒包含了该进程运行所必须的资源，包括文件系统、系统类库、shell 环境等等。但这个沙盒默认是不会运行任何程序的。你需要在沙盒中运行一个进程来启动某一个容器。这个进程是该容器的唯一进程，所以当该进程结束的时候，容器也会完全的停止。
# 在容器中运行&quot;echo&quot;命令，输出&quot;hello word&quot;  
$docker run image_name echo &quot;hello word&quot;  

# 交互式进入容器中  
$docker run -i -t image_name /bin/bash  

# 在容器中安装新的程序  
$docker run image_name apt-get install -y app_name  
`&lt;/pre&gt;

`Note：` 在执行apt-get 命令的时候，要带上-y参数。如果不指定-y参数的话，apt-get命令会进入交互模式，需要用户输入命令来进行确认，但在docker环境中是无法响应这种交互的。apt-get 命令执行完毕之后，容器就会停止，但对容器的改动不会丢失。

## 4&amp;#46; 查看容器（ps）

&lt;pre&gt;`# 列出当前所有正在运行的container  
$docker ps  
# 列出所有的container  
$docker ps -a  
# 列出最近一次启动的container  
$docker ps -l  
`&lt;/pre&gt;

## 5&amp;#46; 保存对容器的修改（commit）

当你对某一个容器做了修改之后（通过在容器中运行某一个命令），可以把对容器的修改保存下来，这样下次可以从保存后的最新状态运行该容器。

&lt;pre&gt;`# 保存对容器的修改; -a, --author=&quot;&quot; Author; -m, --message=&quot;&quot; Commit message  
$docker commit ID new_image_name  
`&lt;/pre&gt;

`Note：` image相当于类，container相当于实例，不过可以动态给实例安装新软件，然后把这个container用commit命令固化成一个image。

## 6&amp;#46; 对容器的操作（rm、stop、start、kill、logs、diff、top、cp、restart、attach）

&lt;pre&gt;`# 删除所有容器  
$docker rm `docker ps -a -q`  

# 删除单个容器; -f, --force=false; -l, --link=false Remove the specified link and not the underlying container; -v, --        volumes=false Remove the volumes associated to the container  
$docker rm Name/ID  

# 停止、启动、杀死一个容器  
$docker stop Name/ID  
$docker start Name/ID  
$docker kill Name/ID  

# 从一个容器中取日志; -f, --follow=false Follow log output; -t, --timestamps=false Show timestamps  
$docker logs Name/ID  

# 列出一个容器里面被改变的文件或者目录，list列表会显示出三种事件，A 增加的，D 删除的，C 被改变的  
$docker diff Name/ID  

# 显示一个运行的容器里面的进程信息  
$docker top Name/ID  

# 从容器里面拷贝文件/目录到本地一个路径  
$docker cp Name:/container_path to_path  
$docker cp ID:/container_path to_path  

# 重启一个正在运行的容器; -t, --time=10 Number of seconds to try to stop for before killing the container, Default=10  
$docker restart Name/ID  

# 附加到一个运行的容器上面; --no-stdin=false Do not attach stdin; --sig-proxy=true Proxify all received signal to the process  
$docker attach ID  
`&lt;/pre&gt;

`Note：` attach命令允许你查看或者影响一个运行的容器。你可以在同一时间attach同一个容器。你也可以从一个容器中脱离出来，是从CTRL-C。

## 7&amp;#46; 保存和加载镜像（save、load）

&lt;pre&gt;`当需要把一台机器上的镜像迁移到另一台机器的时候，需要保存镜像与加载镜像。

# 保存镜像到一个tar包; -o, --output=&quot;&quot; Write to an file  
$docker save image_name -o file_path  
# 加载一个tar包格式的镜像; -i, --input=&quot;&quot; Read from a tar archive file  
$docker load -i file_path  

# 机器a  
$docker save image_name &amp;gt; /home/save.tar  
# 使用scp将save.tar拷到机器b上，然后：  
$docker load &amp;lt; /home/save.tar  
`&lt;/pre&gt;

## 8、 登录registry server（login）

&lt;pre&gt;`# 登陆registry server; -e, --email=&quot;&quot; Email; -p, --password=&quot;&quot; Password; -u, --username=&quot;&quot; Username  
$docker login  
`&lt;/pre&gt;

## 9&amp;#46; 发布image（push）

&lt;pre&gt;`# 发布docker镜像  
$docker push new_image_name  
`&lt;/pre&gt;

## 10&amp;#46; 根据Dockerfile 构建出一个容器

&lt;pre&gt;`#build  
  --no-cache=false Do not use cache when building the image  
  -q, --quiet=false Suppress the verbose output generated by the containers  
  --rm=true Remove intermediate containers after a successful build  
  -t, --tag=&quot;&quot; Repository name (and optionally a tag) to be applied to the resulting image in case of success  
$docker build -t image_name Dockerfile_path
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[An error occurred trying to connect: Get https://192.168.xx.xx:2376/v1.18/containers/json: remote error: bad certificate]]></title>
      <url>http://www.wulai.me/2015/08/06/an-error-occurred-trying-to-connect-get-https192-168-xx-xx2376v1-18containersjson-remote-error-bad-certificate/</url>
      <content type="html"><![CDATA[<p>An error occurred trying to connect: Get <a href="https://192.168.xx.xx:2376/v1.18/containers/json" target="_blank" rel="external">https://192.168.xx.xx:2376/v1.18/containers/json</a>: remote error: bad certificate</p>
<pre><code>boot2docker poweroff 
boot2docker destroy
boot2docker init 
boot2docker start
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Ubuntu通过PPTP协议使用VPN]]></title>
      <url>http://www.wulai.me/2015/07/27/ubuntu-e9-80-9a-e8-bf-87pptp-e5-8d-8f-e8-ae-ae-e4-bd-bf-e7-94-a8vpn/</url>
      <content type="html"><![CDATA[<h1 id="1、安装pptp客户端软件"><a href="#1、安装pptp客户端软件" class="headerlink" title="1、安装pptp客户端软件"></a>1、安装pptp客户端软件</h1><pre><code>~ sudo apt-get install pptp-linux
`&lt;/pre&gt;

# 2、查看网络配置

&lt;pre&gt;`~ ifconfig
eth0      Link encap:Ethernet  HWaddr 08:00:27:90:e8:19
          inet addr:192.168.1.200  Bcast:192.168.1.255  Mask:255.255.255.0
          inet6 addr: fe80::a00:27ff:fe90:e819/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:74 errors:0 dropped:0 overruns:0 frame:0
          TX packets:64 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:8112 (8.1 KB)  TX bytes:8542 (8.5 KB)

lo        Link encap:Local Loopback
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:16436  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)

~ route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         192.168.1.1     0.0.0.0         UG    100    0        0 eth0
192.168.1.0     0.0.0.0         255.255.255.0   U     0      0        0 eth0

~ ip route 
default via 192.168.1.1 dev eth0  metric 100
192.168.1.0/24 dev eth0  proto kernel  scope link  src 192.168.1.200
`&lt;/pre&gt;

# 3、初始化一个VPN的连接通道：myvpn

&lt;pre&gt;`~ sudo pptpsetup --create myvpn --server xxx.xxx.xxx.xxx --username xx1--password xx2--encrypt --start

Using interface ppp0
Connect: ppp0  /dev/pts/1
CHAP authentication succeeded
MPPE 128-bit stateless compression enabled
local  IP address 10.10.10.3
remote IP address 10.10.10.1
`&lt;/pre&gt;

成功连接到远程VPN服务器。
</code></pre><ul>
<li>通过刚才的创建脚步：</li>
<li>在/etc/ppp/peers目录下面，会生成一个叫myvpn的文件。</li>
<li><p>在/etc/ppp目录下面，用户名和密码会写在chap-secrets文件中。</p>
<h1 id="4、"><a href="#4、" class="headerlink" title="4、"></a>4、</h1><pre>`~ sudo vi /etc/ppp/peers/myvpn

# written by pptpsetup
pty "pptp xxx.xxx.xxx.xxx --nolaunchpppd"
lock
noauth
nobsdcomp
nodeflate
name conan2
remotename myvpn
ipparam myvpn
require-mppe-128

#生成用户名和密码
~ sudo vi /etc/ppp/chap-secrets
xx1 myvpn "xx2" *
`</pre>

<h1 id="5、通过网站路由功能，测试VPN"><a href="#5、通过网站路由功能，测试VPN" class="headerlink" title="5、通过网站路由功能，测试VPN"></a>5、通过网站路由功能，测试VPN</h1><h1 id="安装traceroute"><a href="#安装traceroute" class="headerlink" title="安装traceroute"></a>安装traceroute</h1><pre>`~ sudo apt-get install traceroute 

~ traceroute www.163.com
traceroute to www.163.com (101.23.128.17), 30 hops max, 60 byte packets
 1  localhost (192.168.1.1)  2.222 ms  3.144 ms  3.132 ms
 2  111.192.144.1 (111.192.144.1)  80.279 ms  80.632 ms  80.624 ms
 3  61.148.185.69 (61.148.185.69)  9.026 ms  9.492 ms  9.479 ms
 4  124.65.61.157 (124.65.61.157)  9.469 ms  9.459 ms  9.447 ms
 5  202.96.12.185 (202.96.12.185)  9.829 ms  9.783 ms  9.771 ms
 6  219.158.96.110 (219.158.96.110)  17.160 ms  17.210 ms  17.158 ms
 7  61.182.176.178 (61.182.176.178)  30.222 ms  28.589 ms  28.077 ms
 8  60.5.194.58 (60.5.194.58)  29.293 ms  29.287 ms  29.276 ms
 9  60.5.197.214 (60.5.197.214)  26.617 ms  26.724 ms  26.668 ms
10  101.23.255.45 (101.23.255.45)  27.672 ms  28.147 ms  26.811 ms
11  101.23.128.17 (101.23.128.17)  25.890 ms  28.065 ms  28.420 ms
`</pre>

<p>我们发现虽然VPN已经连接成功，但是路由没有通过VPN上网，第1跳还是localhost (192.168.1.1)</p>
<p>再次查看网络连接配置</p>
<pre>`~ ifconfig
eth0      Link encap:Ethernet  HWaddr 08:00:27:90:e8:19
          inet addr:192.168.1.200  Bcast:192.168.1.255  Mask:255.255.255.0
          inet6 addr: fe80::a00:27ff:fe90:e819/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:175 errors:0 dropped:0 overruns:0 frame:0
          TX packets:162 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:16817 (16.8 KB)  TX bytes:19723 (19.7 KB)

lo        Link encap:Local Loopback
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:16436  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)

ppp0      Link encap:Point-to-Point Protocol
          inet addr:10.10.10.3  P-t-P:10.10.10.1  Mask:255.255.255.255
          UP POINTOPOINT RUNNING NOARP MULTICAST  MTU:1496  Metric:1
          RX packets:7 errors:0 dropped:0 overruns:0 frame:0
          TX packets:7 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:3
          RX bytes:70 (70.0 B)  TX bytes:76 (76.0 B)

~ route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         192.168.1.1     0.0.0.0         UG    100    0        0 eth0
10.10.10.1      0.0.0.0         255.255.255.255 UH    0      0        0 ppp0
50.116.27.194   192.168.1.1     255.255.255.255 UGH   0      0        0 eth0
192.168.1.0     0.0.0.0         255.255.255.0   U     0      0        0 eth0

~ ip route
default via 192.168.1.1 dev eth0  metric 100
10.10.10.1 dev ppp0  proto kernel  scope link  src 10.10.10.3
50.116.27.194 via 192.168.1.1 dev eth0  src 192.168.1.200
192.168.1.0/24 dev eth0  proto kernel  scope link  src 192.168.1.200
`</pre>

<p>我们发现默认路由是指向eth0。</p>
<p>下面修改路由配置：</p>
<pre>`    #修改路由命令
    ~ sudo ip route del default 
    ~ sudo ip route add default dev ppp0

    ~ route -n
    Kernel IP routing table
    Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
    0.0.0.0         0.0.0.0         0.0.0.0         U     0      0        0 ppp0
    10.10.10.1      0.0.0.0         255.255.255.255 UH    0      0        0 ppp0
    50.116.27.194   192.168.1.1     255.255.255.255 UGH   0      0        0 eth0
    192.168.1.0     0.0.0.0         255.255.255.0   U     0      0        0 eth0

    ~ ip route
    default dev ppp0  scope link
    10.10.10.1 dev ppp0  proto kernel  scope link  src 10.10.10.3
    50.116.27.194 via 192.168.1.1 dev eth0  src 192.168.1.200
    192.168.1.0/24 dev eth0  proto kernel  scope link  src 192.168.1.200

    ~ traceroute www.163.com
    traceroute to www.163.com (101.23.128.17), 30 hops max, 60 byte packets
     1  localhost (10.10.10.1)  281.093 ms  281.414 ms  280.941 ms
     2  router2-dal.linode.com (67.18.7.162)  281.225 ms  281.109 ms  281.841 ms
     3  xe-2-0-0.car04.dllstx2.networklayer.com (67.18.7.93)  280.882 ms  284.002 ms  283.913 ms
     4  po102.dsr01.dllstx2.networklayer.com (70.87.254.81)  284.123 ms  284.087 ms  283.979 ms
     5  po21.dsr01.dllstx3.networklayer.com (70.87.255.65)  284.000 ms  283.921 ms  283.839 ms
     6  ae16.bbr01.eq01.dal03.networklayer.com (173.192.18.224)  283.542 ms  279.296 ms  290.455 ms
     7  dls-bb1-link.telia.net (213.248.102.173)  301.426 ms  302.092 ms  302.085 ms
     8  las-bb1-link.telia.net (213.155.131.77)  327.192 ms  327.350 ms  327.344 ms
     9  chinaunicom-ic-151188-las-bb1.telia.net (213.248.94.126)  478.941 ms  479.089 ms  479.083 ms
    10  219.158.30.173 (219.158.30.173)  496.679 ms  496.673 ms  496.667 ms
    11  219.158.97.57 (219.158.97.57)  516.819 ms  517.035 ms  517.011 ms
    12  219.158.5.129 (219.158.5.129)  491.084 ms  490.018 ms  497.472 ms
    13  219.158.100.130 (219.158.100.130)  518.239 ms  518.216 ms  518.192 ms
    14  61.182.176.186 (61.182.176.186)  533.695 ms  533.673 ms  533.666 ms
    15  101.23.255.230 (101.23.255.230)  512.212 ms  512.500 ms  512.479 ms
    16  60.5.194.74 (60.5.194.74)  519.246 ms  519.815 ms  519.791 ms
    17  101.23.255.45 (101.23.255.45)  526.522 ms  526.907 ms  526.844 ms
    18  101.23.128.17 (101.23.128.17)  522.068 ms  517.535 ms  517.240 ms
`</pre>

<p>查看第一跳，localhost (10.10.10.1)，已经通过VPN实现路由。</p>
<p>停止VPN</p>
<pre>`    ~ sudo poff myvpn

    ~ ifconfig
    eth0      Link encap:Ethernet  HWaddr 08:00:27:90:e8:19
              inet addr:192.168.1.200  Bcast:192.168.1.255  Mask:255.255.255.0
              inet6 addr: fe80::a00:27ff:fe90:e819/64 Scope:Link
              UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
              RX packets:2270 errors:0 dropped:0 overruns:0 frame:0
              TX packets:1991 errors:0 dropped:0 overruns:0 carrier:0
              collisions:0 txqueuelen:1000
              RX bytes:207578 (207.5 KB)  TX bytes:184147 (184.1 KB)

    lo        Link encap:Local Loopback
              inet addr:127.0.0.1  Mask:255.0.0.0
              inet6 addr: ::1/128 Scope:Host
              UP LOOPBACK RUNNING  MTU:16436  Metric:1
              RX packets:0 errors:0 dropped:0 overruns:0 frame:0
              TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
              collisions:0 txqueuelen:0
              RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)
`</pre>

<p>再ping网站，发现网络出现问题。Network is unreachable</p>
<pre>`~ ping www.163.com
connect: Network is unreachable

~ route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
50.116.27.194   192.168.1.1     255.255.255.255 UGH   0      0        0 eth0
192.168.1.0     0.0.0.0         255.255.255.0   U     0      0        0 eth0

~ ip route
50.116.27.194 via 192.168.1.1 dev eth0  src 192.168.1.200
192.168.1.0/24 dev eth0  proto kernel  scope link  src 192.168.1.200

    ~ sudo ip route add default via 192.168.1.1

    ~ route -n
    Kernel IP routing table
    Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
    0.0.0.0         192.168.1.1     0.0.0.0         UG    0      0        0 eth0
    50.116.27.194   192.168.1.1     255.255.255.255 UGH   0      0        0 eth0
    192.168.1.0     0.0.0.0         255.255.255.0   U     0      0        0 eth0

    ~ ip route
    default via 192.168.1.1 dev eth0
    50.116.27.194 via 192.168.1.1 dev eth0  src 192.168.1.200
    192.168.1.0/24 dev eth0  proto kernel  scope link  src 192.168.1.200

    #再次ping网站，访问成功！
    ~ ping www.163.com
    PING 163.xdwscache.glb0.lxdns.com (101.23.128.17) 56(84) bytes of data.
    64 bytes from 101.23.128.17: icmp_req=1 ttl=54 time=25.6 ms
    64 bytes from 101.23.128.17: icmp_req=2 ttl=54 time=25.5 ms
    64 bytes from 101.23.128.17: icmp_req=3 ttl=54 time=27.8 ms
`</pre>

<p>通过ip-up, ip-down配置路由 ~ sudo vi /etc/ppp/ip-up.d/route-traffic</p>
<pre>`    #!/bin/bash
    /sbin/ip route add 50.116.27.194 via 192.168.1.1
    /sbin/ip route del default
    /sbin/ip route add default dev ppp0

    ~ sudo vi /etc/ppp/ip-down.d/disableroute

    #!/bin/bash
    /sbin/ip route add default via 192.168.1.1
`</pre>

<p>重启VPN连接</p>
<p><pre>`    ~ sudo pon myvpn</pre></p>
<pre><code>#路由跟踪正确
~ traceroute www.163.com
traceroute to www.163.com (123.125.34.30), 30 hops max, 60 byte packets
 1  localhost (10.10.10.1)  293.397 ms  293.782 ms  293.668 ms
 2  router2-dal.linode.com (67.18.7.162)  293.530 ms  293.721 ms  294.223 ms
 3  xe-2-0-0.car04.dllstx2.networklayer.com (67.18.7.93)  293.454 ms  293.358 ms  293.239 ms
 4  po102.dsr02.dllstx2.networklayer.com (70.87.254.85)  293.749 ms  293.650 ms  293.544 ms
 5  po22.dsr02.dllstx3.networklayer.com (70.87.255.69)  293.444 ms  293.339 ms  293.242 ms
 6  ae17.bbr02.eq01.dal03.networklayer.com (173.192.18.230)  293.117 ms  293.525 ms  300.406 ms
 7  dls-bb1-link.telia.net (80.239.195.177)  300.850 ms  300.667 ms  300.320 ms

#正常退出
~ sudo poff myvpn
#测试网络连接正常
~ ping www.163.com
PING 163.xdwscache.glb0.lxdns.com (101.23.128.17) 56(84) bytes of data.
64 bytes from 101.23.128.17: icmp_req=1 ttl=54 time=28.2 ms
64 bytes from 101.23.128.17: icmp_req=2 ttl=54 time=28.1 ms
</code></pre></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[在ubuntu下搭建pptp vpn服务器]]></title>
      <url>http://www.wulai.me/2015/07/27/e5-9c-a8ubuntu-e4-b8-8b-e6-90-ad-e5-bb-bapptp-vpn-e6-9c-8d-e5-8a-a1-e5-99-a8/</url>
      <content type="html"><![CDATA[<h1 id="pptp配置"><a href="#pptp配置" class="headerlink" title="pptp配置"></a>pptp配置</h1><h2 id="1、安装pptp"><a href="#1、安装pptp" class="headerlink" title="1、安装pptp"></a>1、安装pptp</h2><p>安装pptp</p>
<pre><code>sudo apt-get -y update
sudo apt-get -y install pptpd
`&lt;/pre&gt;

## 2、修改配置脚本

&lt;pre&gt;`cat &amp;gt;/etc/ppp/options.pptpd &amp;lt;&amp;lt;END
name pptpd
refuse-pap
refuse-chap
refuse-mschap
require-mschap-v2
require-mppe-128
ms-dns 8.8.8.8
ms-dns 8.8.4.4
proxyarp
lock
nobsdcomp 
novj
novjccomp
nologfd
END
`&lt;/pre&gt;

说明
</code></pre><ul>
<li>name pptpd（pptpd服务名，可以随便填写。）</li>
<li>refuse-pap（拒绝pap身份认证模式。）</li>
<li>refuse-chap（拒绝chap身份认证模式。）</li>
<li>refuse-mschap（拒绝mschap身份认证模式。）</li>
<li>require-mschap-v2（在端点进行连接握手时需要使用微软的 mschap-v2 进行自身验证。）</li>
<li>require-mppe-128（MPPE 模块使用 128 位加密。）</li>
<li>ms-dns 8.8.8.8 (ppp 为 Windows 客户端提供 DNS 服务器 IP 地址。)</li>
<li>proxyarp (建立 ARP 代理键值。)</li>
<li>nodefaultroute（不替换默认路由）</li>
<li>debug（开启调试模式，相关信息记录在 /var/logs/message 中。）</li>
<li>lock（锁定客户端 PTY 设备文件。）</li>
<li><p>nobsdcomp (禁用 BSD 压缩模式。)</p>
<h2 id="3、还有ip"><a href="#3、还有ip" class="headerlink" title="3、还有ip"></a>3、还有ip</h2><pre>`cat &gt; /etc/pptpd.conf &lt;&lt;END
option /etc/ppp/options.pptpd
logwtmp
localip 192.168.2.1
remoteip 192.168.2.10-100
END
`</pre>

<h2 id="4、增加路由转发"><a href="#4、增加路由转发" class="headerlink" title="4、增加路由转发"></a>4、增加路由转发</h2><h3 id="4-1-ipv4转发"><a href="#4-1-ipv4转发" class="headerlink" title="4.1 ipv4转发"></a>4.1 ipv4转发</h3><pre>`cat &gt;&gt; /etc/sysctl.conf &lt;&lt;END
net.ipv4.ip_forward=1
END
sysctl -p   
`</pre>

<h3 id="4-2-修改iptables"><a href="#4-2-修改iptables" class="headerlink" title="4.2 修改iptables"></a>4.2 修改iptables</h3></li>
<li><p>备份当前iptables<br>iptables-save &gt; /etc/iptables.down.rules</p>
</li>
<li>修改iptable NAT转发<br>iptables -t nat -A POSTROUTING -s 192.168.2.0/24 -o eth0 -j MASQUERADE</li>
<li><p>设置MTU</p>
<p>iptables -I FORWARD -s 192.168.2.0/24 -p tcp –syn -i ppp+ -j TCPMSS –set-mss 1300</p>
</li>
<li><p>保存新iptables</p>
<p>iptables-save &gt; /etc/iptables.up.rules</p>
</li>
<li><p>重启后继续有效<br>cat &gt;&gt;/etc/ppp/pptpd-options&lt;&lt;EOF<br>pre-up iptables-restore &lt; /etc/iptables.up.rules<br>post-down iptables-restore &lt; /etc/iptables.down.rules<br>EOF</p>
</li>
<li>增加用户</li>
<li>增加帐号密码都是test的用户<br>cat &gt;/etc/ppp/chap-secrets &lt;&lt;END<br>test pptpd test *<br>END</li>
<li>重启服务<br>/etc/init.d/pptpd restart<br>netstat -lntp</li>
<li><p>自动脚本<br>wget -c <a href="https://github.com/suyan/scripts/raw/master/Setup/pptp.sh" target="_blank" rel="external">https://github.com/suyan/scripts/raw/master/Setup/pptp.sh</a></p>
<h2 id="4、问题"><a href="#4、问题" class="headerlink" title="4、问题"></a>4、问题</h2><p>logwtmp.so 版本问题</p>
<p>如果链接中断，并且出现下面问题：</p>
<p><pre>`Plugin /usr/lib/pptpd/pptpd-logwtmp.so is for pppd version 2.4.5, this is 2.4.6</pre></p>
</li>
</ul>
<p>在 /etc/pptpd.conf 文件中把 logwtmp 删掉就好了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[动态生成元素不响应jquery事件]]></title>
      <url>http://www.wulai.me/2015/07/25/e5-8a-a8-e6-80-81-e7-94-9f-e6-88-90-e5-85-83-e7-b4-a0-e4-b8-8d-e5-93-8d-e5-ba-94jquery-e4-ba-8b-e4-bb-b6/</url>
      <content type="html"><![CDATA[<p>用on事件来解决</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[使用npm安装一些包失败了的看过来（npm国内镜像介绍）]]></title>
      <url>http://www.wulai.me/2015/07/16/e4-bd-bf-e7-94-a8npm-e5-ae-89-e8-a3-85-e4-b8-80-e4-ba-9b-e5-8c-85-e5-a4-b1-e8-b4-a5-e4-ba-86-e7-9a-84-e7-9c-8b-e8-bf-87-e6-9d-a5-ef-bc-88npm-e5-9b-bd-e5-86-85-e9-95-9c-e5-83-8f-e4-bb-8b-e7-bb-8d/</url>
      <content type="html"><![CDATA[<p>这个也是网上搜的，亲自试过，非常好用！</p>
<p>镜像使用方法（三种办法任意一种都能解决问题，建议使用第三种，将配置写死，下次用的时候配置还在）:</p>
<p>1&#46;通过config命令</p>
<pre><code>npm config set registry https://registry.npm.taobao.org 
npm info underscore （如果上面配置正确这个命令会有字符串response）
`&lt;/pre&gt;

2&amp;#46;命令行指定

&lt;pre&gt;`npm --registry https://registry.npm.taobao.org info underscore 
`&lt;/pre&gt;

3&amp;#46;编辑 ~/.npmrc 加入下面内容

&lt;pre&gt;`registry = https://registry.npm.taobao.org
</code></pre><p>搜索镜像: <a href="https://npm.taobao.org" target="_blank" rel="external">https://npm.taobao.org</a></p>
<p>建立或使用镜像,参考: <a href="https://github.com/cnpm/cnpmjs.org" target="_blank" rel="external">https://github.com/cnpm/cnpmjs.org</a></p>
<h2 id="国内镜像"><a href="#国内镜像" class="headerlink" title="国内镜像"></a>国内镜像</h2><p><code>http://cnpmjs.org/</code></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[PayPal高级工程总监：读完这100篇论文 就能成大数据高手]]></title>
      <url>http://www.wulai.me/2015/07/13/paypal-e9-ab-98-e7-ba-a7-e5-b7-a5-e7-a8-8b-e6-80-bb-e7-9b-91-ef-bc-9a-e8-af-bb-e5-ae-8c-e8-bf-99100-e7-af-87-e8-ae-ba-e6-96-87-e5-b0-b1-e8-83-bd-e6-88-90-e5-a4-a7-e6-95-b0-e6-8d-ae-e9-ab-98-e6-89-8b/</url>
      <content type="html"><![CDATA[<p>开源（Open Source）用之于大数据技术，其作用有二：一方面，在大数据技术变革之路上，开源在众人之力和众人之智推动下，摧枯拉朽，吐故纳新，扮演着非常重要的推动作用。另一方面，开源也给大数据技术构建了一个异常复杂的生态系统。每一天，都有一大堆“新”框架、“新”类库或“新”工具，犹如雨后春笋般涌出，乱花渐欲“迷”人眼。为了掌控住这些“新玩意”，数据分析的达人们不得不“殚精竭虑”地“学而时习之”。</p>
<p>无论你是一个大数据的布道者，还是一个日臻成熟的技术派，亦或你还在大数据这条路上“小河才露尖尖角”，多花点时间，深入理解一下大数据系统的技术体系演进，对你都会有莫大益处。全方位地理解大数据体系结构中的各个组件，并掌握它们之间的微妙差别，可在处理自己身边的大数据案例时，助你张弛有度，“恢恢乎，其于游刃必有余地矣!”</p>
<p>在过去的几年里，我阅读了很多不错的大数据文献，这些文献陪我成长，助我成功，使我成为一个具备良好教育背景的大数据专业人士。在这里，撰写此文的目的，不限于仅仅和大家分享这些很不错的文献，更重要的是，借此机会，想和大家一起，集众人之智慧，破解大数据开源系统之迷宫。</p>
<p>需要提醒的是，下文提及到的100篇参考文献（这些文献中大多都是一些开创性的研究论文），将会为你提供结构性的深度剖析，绝非泛泛而谈。我相信，这可从根本上帮助你深度理解大数据体系组件间的细微差别。但如果你打算“走马观花”般地快速过一遍，了解大数据为何物，对不起，这里可能会让你失望。</p>
<p>那么，准备好了吗？让我们走起！</p>
<p>在介绍这100篇文献之前，首先让我们看一下大数据处理的关键架构层（如图1所示）：</p>
<h1 id="关键架构层"><a href="#关键架构层" class="headerlink" title="关键架构层"></a>关键架构层</h1><p><img src="http://res.hillock.com.cn//559b280e4d25f.jpg" alt="enter image description here"></p>
<p>图1：大数据处理的关键架构层</p>
<ul>
<li>文件系统层：在这一层里，分布式文件系统需具备存储管理、容错处理、高可扩展性、高可靠性和高可用性等特性。</li>
<li>数据存储层：由于目前采集到的数据，十之有七八为非结构化和半结构化数据，数据的表现形式各异，有文本的、图像的、音频的、视频的等，因此常见的 数据存储也要对应有多种形式，有基于键值（Key-Value）的，有基于文档（Document），还有基于列（Column）和图表（Graph）的。如果采用单一的数据库引擎，“一刀切式”的满足所有类型的数据存储需求，通常会严重降低数据库管理的性能。因此，我们需要“兵来将挡，水来土掩”式的、多元的（<a href="http://bigbe.su/lectures/2014/15.3.pdf" target="_blank" rel="external">Polyglot</a>）【1】数据库解决方案（这就好比，如果“兵来了”和“水来了”，都要“将”去挡，遇到“兵”时，“将”可以“酣畅淋漓”，而遇到“水”时，还用“将”去挡，那这个“将”估计就要“舍生取义”了。文献【1】是一本有关NoSQL数据处理的图书）</li>
<li>资源管理层：这一层是为了提高资源的高利用率和吞吐量，以到达高效的资源管理与调度目的。</li>
<li>资源协调层： 在本层的系统，需要完成对资源的状态、分布式协调、一致性和资源锁实施管理。</li>
<li>计算框架层：在本层的计算框架非常庞杂，有很多高度专用的框架包含其内，有流式的，交互式的，实时的，批处理和迭代图的（Batch and Iterative Graph，BSP）等。为这些计算框架提供支撑的是运行时引擎，如<a href="http://datasys.cs.iit.edu/events/CCGrid2014/CCGrid-May25-Stoica.pdf" target="_blank" rel="external">BDAS</a>【2】(Spark) 和 Flink等（注：这里的BDAS是指“Berkeley Data Analytics Stack”，即伯克利数据分析栈。文献【2】为Spark核心作者Ion Stoica的讲座幻灯片文档）。</li>
<li>数据分析层：在这一层里，主要包括数据分析(消费)工具和一些数据处理函数库。这些工具和函数库，可提供描述性的、预测性的或统计性的数据分析功能及机器学习模块。</li>
<li>数据集成层：在这一层里，不仅包括管理数据分析工作流中用到的各种适用工具，除此之外，还包括对元数据（Metadata）管理的工具。</li>
<li>操作框架层：这一层提供可扩展的性能监测管理和基准测试框架。</li>
</ul>
<h2 id="架构的演进"><a href="#架构的演进" class="headerlink" title="架构的演进"></a>架构的演进</h2><p>减少数据生产者和消费者之间的处理延迟，一直是现代计算构架不断演进的主要动力。由此，诞生了实时和低延迟处理的计算构架，如Lambda和Kappa等，这类混合架构取长补短，架起传统的批处理层和交互式层之间连接的桥梁。</p>
<ul>
<li><a href="http://jameskinley.tumblr.com/post/37398560534/the-lambda-architecture-principles-for" target="_blank" rel="external">Lambda</a>【3】 -该架构是经典的大数据处理范式，是由南森马兹（Nathan Marz）提出的一个实时大数据处理框架。更多有关Lamda的信息，请读者访问Lambda官方网站。（注：文献【3】是由James Kinley在轻博客网站Tumblr发表的一篇博文：Lambda 架构：构架实时大数据系统的原则）。</li>
<li><a href="http://radar.oreilly.com/2014/07/questioning-the-lambda-architecture.html" target="_blank" rel="external">Kappa</a>【4】-该计算构架可视为Lambda的一个强有力替代者，Kappa将数据处理的上游移至流式层（注：文献【4】是一篇博客文章，作者是Jay Kreps是Linkedln的一名在线数据架构技术高管。Kreps认为，虽然Lambda构架的理念很有价值，但终究还是一个临时解决方案。他设计了一个替代架构Kappa，是基于他在Linkedin构建Kafka和Samza的经验设计而成）。</li>
<li><a href="http://www.vldb.org/pvldb/vol7/p1441-boykin.pdf" target="_blank" rel="external">SummingBird</a>【5】-这是一个参考模型，用来桥接在线处理模式和传统处理模式。Summingbird是由Twitter（推特）公司用Scala语言开发的、并开源的大规模数据处理框架，支持开发者以批处理模式（基于Hadoop）或流处理模式（基于Storm），或混合模式（即前两种模式的组合）以统一的方式执行代码。（注：文献【5】是Summingbird的主要设计者Oscar Boykin、Sam Ritchie等人于2014年发表于知名期刊PVLDB中论文，其中论文的二作Sam Ritchie大有来头，他是计算机科学界的传奇人物、C语言和Unix的设计者Dennis Ritchie的侄子）。</li>
</ul>
<p>在你尚未深入了解下面的各个具体的框架层次之前，建议你认真阅读一下下面的几篇非常有价值的文献，它们帮为你“恶补”一下诸如NoSQL（非结构化）数据存储、数据仓库大规模计算及分布式系统等相关领域的背景知识：</p>
<ul>
<li><a href="http://www.morganclaypool.com/doi/pdf/10.2200/S00516ED2V01Y201306CAC024" target="_blank" rel="external">计算中心即计算机</a>【6】（Data center as a computer）-文献【6】是威斯康星大学-麦迪逊分校Mark D. Hill教授主编的一个论文集式的图书，在这本图书中，收集了很多有关数据仓库大规模计算的论文（注：将数据中心视为一台计算机，与传统的高性能计算机有很大不同。计算中心的实例将以虚拟机或者容器的形式存在，计算资源的配置对于用户而言是透明的，这样就大幅降低系统部署的复杂度、并提高资源使用的灵活性）。</li>
<li><a href="http://www.cattell.net/datastores/Datastores.pdf" target="_blank" rel="external">非结构化（NOSQL）</a>数据存储【7】- 文献是由Rick Cattell撰写的论文，论文讨论了可扩展的结构化数据的、非结构化的（包括基于键值对的、基于文档的和面向列的）数据存储方案（注：NOSQL是支撑大数据应用的关键所在。事实上，将NOSQL翻译为“非结构化”不甚准确，因为NOSQL更为常见的解释是：Not Only SQL（不仅仅是结构化），换句话说，NOSQL并不是站在结构化SQL的对立面，而是既可包括结构化数据，也可包括非结构化数据）。</li>
<li><a href="http://www.christof-strauch.de/nosqldbs.pdf" target="_blank" rel="external">NoSQL学位论文</a>【8】-该文献是德国斯图加特传媒大学Christof Strauch撰写的学位论文，该论文对分布式系统和第一代非结构化系统提供了非常系统的背景知识介绍。</li>
<li><a href="http://webdocs.cs.ualberta.ca/~lengdong/papers/JCST14.pdf" target="_blank" rel="external">大规模数据管理</a>【9】-文献是加拿大阿尔伯塔大学的研究人员撰写的一篇综述，讨论了大数据应用程序的大规模数据管理系统，传统的数据库供应商与新兴的互联网企业，它们对大数据管理需求是不同的。文章的讨论范围涵盖很广，数据模型、系统结构及一致性模型，皆有涉及。 <a href="http://grail.csuohio.edu/~sschung/cis612/hadoopjoin_sigmod2010.pdf" target="_blank" rel="external">最终一致性（Eventual Consistency）</a>【10】：论文讨论了分布式系统中的各种不同的一致性模型。（注：原文给出的链接可能有误，因为根据所提供的链接下载而来的论文是关于“MapReduce中日志处理的Join算法”的综述文章，与“最终一致性”的讨论议题无关。这里推荐2篇新的相关论文：（1）综述文章：数据库最终一致性：最新的进展【10】new1；（2）微软研究人员2013年发表于SIGMOD的文章：“最终一致性的反思（Rethinking Eventual Consistency）【10】new2”。）</li>
<li><a href="http://www.cs.berkeley.edu/~rxin/db-papers/CAP.pdf" target="_blank" rel="external">CAP理论</a>【11】-文献以“CAP理论十二年回顾：”规则”已经变了”为题，探讨了CAP理论及其演化，是篇非常不错的介绍CAP理论的基础性论文（注：论文作者Eric Brewer是加州大学伯克利分校的知名计算机科学学者。该文首发于《Computer》杂志，随后又被InfoQ和IEEE再次发表。CAP理论断言，任何基于网络的数据共享系统，最多只能满足数据一致性（Consistency，C）、可用性（Availability ，A）、分区（Partition，P）容忍性这三要素中的两个要素。但通过显式处理分区，系统设计师可做到优化数据的一致性和可用性，进而取得三者之间的妥协与平衡）。</li>
</ul>
<p>在过去，在大规模数据处理上，传统的并行数据库管理系统（DBMS）和基于Map Reduce（映射-规约，以下简称MR）的批处理范式之间，曾发生激烈辩论，各持己见。并行数据库管理系统的<a href="http://database.cs.brown.edu/sigmod09/benchmarks-sigmod09.pdf" target="_blank" rel="external">支持者</a>【12】（注：由耶鲁大学、微软和麻省理工学院的研究人员于2009年发表在SIGMOD的一篇文章）和另外<a href="http://database.cs.brown.edu/papers/stonebraker-cacm2010.pdf" target="_blank" rel="external">一篇文献</a>【13】（注：2010年发表于《美国计算机学会通讯》上的论文：“MapReduce和并行数据库管理系统，是朋友还是敌人？”），被<a href="http://www.cs.princeton.edu/courses/archive/spr11/cos448/web/docs/week10_reading2.pdf" target="_blank" rel="external">MR的拥趸者</a>【14】（注：发表于美国计算机学会通讯的论文：MapReduce:一个弹性的数据处理工具）狠狠地给批驳了一番。</p>
<p>然而，令人讽刺的是，从那时起，Hadoop社区开始引入无共享的（Shared-Nothing）的MPP（大规模并行处理）风格的大数据处理模式，文献“<a href="http://www.vldb.org/pvldb/vol7/p1295-floratou.pdf" target="_blank" rel="external">Hadoop上的SQL</a>【15】”，便是例证。要知道，MPP是并行数据库管理系统（DBMS）的灵魂，这样，Map Reduce绕了一大圈，又似回到它当初离开的地方。</p>
<h1 id="文件系统层"><a href="#文件系统层" class="headerlink" title="文件系统层"></a>文件系统层</h1><p>由于文件系统层关注的焦点，开始向“低延时处理”方向转移，所以传统基于磁盘存储的文件系统，也开始向基于内存计算的文件系统转变 —— 这样做，会大大降低I / O操作和磁盘序列化带来的访问开销。Tachyon 和 Spark <a href="https://www.cs.berkeley.edu/~matei/papers/2012/nsdi_spark.pdf" target="_blank" rel="external">RDD</a>【16】就是朝这个方向演化的范例（注：这里RDD指的是弹性分布式数据集（Resilient Distributed Datasets），它是一种高度受限的共享内存模型，文献【16】由伯克利大学加州分校的Matei Zaharia等撰写的，他们提出了一种面向内存集群运算的容错抽象模型）。</p>
<ul>
<li><a href="http://static.googleusercontent.com/media/research.google.com/en/us/archive/gfs-sosp2003.pdf" target="_blank" rel="external">Google文件系统（GFS）</a>【17】-该文献是分布式文件系统的奠基之作，著名的Hadoop 分布式文件系统（HDFS），亦脱胎于GFS，基本上可视为GFS的一个简化实现版（注：文献【17】提出了一个可扩展的分布式文件系统GFS，可用于大型分布式数据密集型应用。文献认为，组件故障是常态而不是异常。其所提出的GFS，着眼在几个重要的目标，比如性能、可伸缩性、可靠性和可用性。GFS的新颖之处，并不在于它采用了多么令人惊艳的技术，而在于它能利用所提出的方案，采用廉价的商用机器，来构建高效的分布式文件系统。有用的创新，才是真的创新，GFS做到了！）。</li>
<li><a href="http://zoo.cs.yale.edu/classes/cs422/2014fa/readings/papers/shvachko10hdfs.pdf" target="_blank" rel="external">Hadoop</a> 文件系统【18】-该文献由雅虎公司的计算机科学家Konstantin Shvachko等人联合撰写的，论文给出了HDFS的进化历史背景及其架构的设计内涵，是了解Hadoop技术的经典之作。</li>
<li><a href="http://ceph.com/papers/weil-ceph-osdi06.pdf" target="_blank" rel="external">Ceph文件系统</a>【19】-Ceph是HDFS有力的<a href="https://www.usenix.org/legacy/publications/login/2010-08/openpdfs/maltzahn.pdf" target="_blank" rel="external">替代者</a>【20】（注：Ceph文件系统是加州大学圣克鲁兹分校（USSC）博士生Sage Weil博士期间的一项有关存储系统的研究项目。初出茅庐，略有小成。之后，在开源社区的推动下，Ceph逐渐羽翼渐丰，风云叱咤，功成名就，逐渐发展成为一个 Linux系统下 PB 级分布式文件系统。文献【19】是Weil本人在2006年顶级会议OSDI发表的有关Ceph的开山论文。文献【20】则是Weil率领他的一帮小伙伴们再次发文强调，Ceph是HDFS<a href="https://www.usenix.org/legacy/publications/login/2010-08/openpdfs/maltzahn.pdf" target="_blank" rel="external">强有力的替代者</a>）。</li>
<li><a href="http://www.cs.berkeley.edu/~haoyuan/papers/2014_socc_tachyon.pdf" target="_blank" rel="external">Tachyon</a>【21】–是一个高容错的分布式内存文件系统，其设计的核心内涵是，要满足当下“低延迟”的数据处理要求（注：Tachyon是在内存中处理缓存文件，允许文件以访问内存的速度在集群框架中进行可靠的共享，类似于Spark。Tachyon的吞吐量比HDFS高出100倍。Spark框架虽然也提供了强大的内存计算能力，但其没有提供内存文件的存储管理能力，而Tachyon则弥补了Spark的不足之处。文献【21】是伯克利大学加州分校和麻省理工学院的研究者联合撰写的，发表在2014年的 SoCC国际会议上，论文一作UC Berkeley AMP实验室博士生李浩源，他亦是Spark核心开发人员之一）。</li>
</ul>
<p>文件系统的演化历程，其实也见证了文件格式和压缩技术的发展历程。下面的参考文献，可以让你了解到，“面向行”或“面向列”存储格式各自的优缺点，并且还可让你了然文件存储技术发展的新趋势——嵌套式的面向列的存储格式，这种存储格式可极大提高大数据的处理效率。</p>
<p>当前，在文件系统阶段，数据管理的最大挑战之一就是，如何处理大数据中的数据冗余。纠删码（Erasure code）是很有创意的冗余保护机制，它可以减少三倍的冗余副本，还不会影响数据的可恢复性与可用性。</p>
<ul>
<li><a href="http://db.csail.mit.edu/projects/cstore/abadi-sigmod08.pdf" target="_blank" rel="external">面向列存储 vs. 面向列存储</a>【22】—该文献是是2008年发表于SIGMOD的一篇论文，该文对数据的布局、压缩及物化（materialization）策略都做了很不错的综述。 ＊ <a href="http://web.cse.ohio-state.edu/hpcs/WWW/HTML/publications/papers/TR-11-4.pdf" target="_blank" rel="external">RCFile</a>【23】-这是由Facebook数据基础设施小组和俄亥俄州立大学的华人学者共同提出的文件存储格式，他们走了一个“中庸之道”，充分吸取面向列和面向行存储模式的优点，扬长避短，提出了一种混合的数据存储结构PAX（注：目前这种以行/列混合存储技术已成功应用于 Facebook 等国内外大型互联网企业的生产性运行体系）。</li>
<li><a href="https://github.com/Parquet/parquet-mr/wiki/The-striping-and-assembly-algorithms-from-the-Dremel-paper" target="_blank" rel="external">Parquet</a>【24】- 这是一种面向行的存储格式，其设计理念源于谷歌 Dremel论文（注：Parquet主要用于 Hadoop 的生态系统中。文献【24】是Julien Dem在Github发表的一篇博客文章）。</li>
<li><a href="http://web.cse.ohio-state.edu/hpcs/WWW/HTML/publications/papers/TR-14-2.pdf" target="_blank" rel="external">ORCFile</a>【25】–这是一种被Hive（一种基于Hadoop的数据仓库工具）采用的、面向列存储的改进版存储格式（注：文献【25】是2014年发表于顶会SIGMOD的一篇学术论文）。</li>
<li><a href="http://www.ijritcc.org/IJRITCC%20Vol_2%20Issue_3/A%20Survey%20on%20Compression%20Algorithms%20%20in%20Hadoop.pdf" target="_blank" rel="external">压缩技术</a>【26】-这是是一篇阐述在Hadoop生态系统下的常见压缩算法的综述性文章，文章对常见的压缩算法和其适用场景以及它们的优缺点，做了非常不错的归纳总结。</li>
<li><a href="http://web.eecs.utk.edu/~plank/plank/papers/Login-2013.pdf" target="_blank" rel="external">纠删码技术（Erasure code）</a>【27】-这是一篇是田纳西大学EECS系教授James Plank撰写的、有关存储系统纠删码技术的入门级的文献。有关纠删码改进技术的阐述，读者可参阅来自南加州大学和Facebook的7名作者共同完成的论文<a href="http://anrg.usc.edu/~maheswaran/Xorbas.pdf" target="_blank" rel="external">《XORing Elephants: 面向大数据的新型纠删码技术【28】》</a>（注：文献【28】的作者开发了纠删码家族的新成员——基于XOR的本地副本存储LRC，该技术是面向Hadoop生态系统的，可显著减少修复数据时的I/O操作和存储开销）。</li>
</ul>
<h1 id="数据存储层"><a href="#数据存储层" class="headerlink" title="数据存储层"></a>数据存储层</h1><p>宽泛地讲，据对一致性（consistency）要求的强弱不同，分布式数据存储策略，可分为ACID和BASE两大阵营。ACID是指数据库事务具有的四个特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。ACID中的一致性要求比较强，事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。而BASE对一致性要求较弱，它的三个特征分别是：基本可用（Basically Available）, 软状态/柔性事务（Soft-state，即状态可以有一段时间的不同步）, 最终一致性（Eventual consistency）。BASE还进一步细分基于键值的，基于文档的和基于列和图形的 – 细分的依据取决于底层架构和所支持的数据结构（注：BASE完全不同于ACID模型，它以牺牲强一致性，获得基本可用性和柔性可靠性，并要求达到最终一致性）。</p>
<p>在数据存储层，还有很多类似的系统和某些系统的变种，这里，我仅仅列出较为出名的几个。如漏掉某些重要系统，还请谅解。</p>
<h1 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h1><h2 id="键值存储（Key-Value-Stores）"><a href="#键值存储（Key-Value-Stores）" class="headerlink" title="键值存储（Key Value Stores）"></a>键值存储（Key Value Stores）</h2><ul>
<li><p><a href="http://www.cs.ucsb.edu/~agrawal/fall2009/dynamo.pdf" target="_blank" rel="external">Dynamo</a>【29】– 这是由亚马逊工程师们设计的基于键值的高可用的分布式存储系统（注：Dynamo放弃了数据建模的能力，所有的数据对象采用最简单的Key-value模型存储，可简单地将Dynamo理解为一个巨大的Map。Dynamo是牺牲了部分一致性，来换取整个系统的高可用性）。</p>
</li>
<li><p><a href="https://www.cs.cornell.edu/projects/ladis2009/papers/lakshman-ladis2009.pdf" target="_blank" rel="external">Cassandra</a>【30】 – 这是由Facebook工程师设计的一个离散的分布式结构化存储系统，受亚马逊的Dynamo启发，Cassandra采用的是面向多维的键值或面向列的数据存储格式（注：Cassandra可用来管理分布在大量廉价服务器上的巨量结构化数据，并同时提供没有单点故障的高可用服务）。</p>
</li>
<li><p><a href="http://static.usenix.org/events/fast/tech/full_papers/Sumbaly.pdf" target="_blank" rel="external">Voldemort</a>【31】 –这又是一个受亚马逊的Dynamo启发的分布式存储作品，由全球最大的职业社交网站LinkedIn的工程师们开发而成（注：Voldemort，这个在《哈利·波特》中常被译作“伏地魔”的开源数据库，支撑起了LinkedIn的多种数据分析平台）。</p>
</li>
</ul>
<h2 id="面向列的存储（Column-Oriented-Stores）"><a href="#面向列的存储（Column-Oriented-Stores）" class="headerlink" title="面向列的存储（Column Oriented Stores）"></a>面向列的存储（Column Oriented Stores）</h2><ul>
<li><p><a href="http://static.googleusercontent.com/media/research.google.com/en/us/archive/bigtable-osdi06.pdf" target="_blank" rel="external">BigTable</a>【32】 –这是一篇非常经典的学术论文，阐述了面向列的分布式的数据存储方案，由谷歌荣誉出品。（注：Bigtable是一个基于Google文件系统的分布式数据存储系统，是为谷歌打拼天下的“三驾马车”之一，另外两驾马车分别是分布式锁服务系统Chubby和下文将提到的MapReduce）。</p>
</li>
<li><p><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.303.752&amp;rep=rep1&amp;type=pdf" target="_blank" rel="external">HBase</a>【33】 –目前还没有有关Hbase的定义性论文，这里的文献提供了一个有关HBase技术的概述性文档（注：Hbase是一个分布式的、面向列的开源数据库。其设计理念源自谷歌的 BigTable，用Java语言编写而成。文献【33】是一个有关Hbase的幻灯片文档）。</p>
</li>
<li><p><a href="http://www.hypertable.com/collateral/whitepaper-hypertable-architecture.pdf" target="_blank" rel="external">Hypertable</a>【34】-文献是一个有关“Hypertable”的技术白皮书，对该数据存储结构做了较为详细的介绍（注：Hypertable也是一个开源、高性能、可伸缩的数据库，它采用与Google的Bigtable类似的模型）。</p>
</li>
</ul>
<h2 id="面向文档的存储（Document-Oriented-Stores）"><a href="#面向文档的存储（Document-Oriented-Stores）" class="headerlink" title="面向文档的存储（Document Oriented Stores）"></a>面向文档的存储（Document Oriented Stores）</h2><ul>
<li><p><a href="https://media.readthedocs.org/pdf/couchdb/latest/couchdb.pdf" target="_blank" rel="external">CouchDB</a>【35】– 这是一款面向文档的、开源数据存储管理系统（注：文献【35】是一本Apache CouchDB的400多页的官方文档）。</p>
</li>
<li><p><a href="http://s3.amazonaws.com/info-mongodb-com/MongoDB_Architecture_Guide.pdf" target="_blank" rel="external">MongoDB</a>【36】 –是目前非常流行的一种非关系型(NoSQL)数据库（注：文献【36】是一个有关MongoDB的白皮书，对MongoDB结构做了很不错的介绍）。</p>
</li>
</ul>
<h2 id="面向图（Graph）的存储"><a href="#面向图（Graph）的存储" class="headerlink" title="面向图（Graph）的存储"></a>面向图（Graph）的存储</h2><ul>
<li><p><a href="http://info.neotechnology.com/rs/neotechnology/images/GraphDatabases.pdf" target="_blank" rel="external">Neo4j</a>【37】 –文献是Ian Robinson等撰写的图书《Graph Databases（图数据库）》（注：Neo4j是一款目前最为流行的高性能NoSQL 图数据库，它使用图来描述数据模型，把数据保存为图中的节点以及节点之间的关系。这是最流行的图数据库）。</p>
</li>
<li><p><a href="http://s3.thinkaurelius.com/docs/titan/0.9.0-M2/" target="_blank" rel="external">Titan</a>【38】 –文献是有关Titan的在线文档（Titan是一款Apache许可证框架下的分布式的开源图数据库，特别为存储和处理大规模图而做了大量优化）。</p>
</li>
</ul>
<h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h2><p>我注意到，现在很多开源社区正在悄悄发生变化，它们开始“亦步亦趋”地跟随谷歌的脚步。这也难怪，谷歌太牛，跟牛人混，近牛者牛 —— 下面4篇文献，有3篇来自于谷歌的“神来之笔”，他们解决了全球分布一致的数据存储问题。</p>
<ul>
<li><p><a href="http://www.cidrdb.org/cidr2011/Papers/CIDR11_Paper32.pdf" target="_blank" rel="external">Megastore</a>【39】 –这是一个构建于BigTable之上的、高可用的分布式存储系统，文献为有关Megastore的技术白皮书（注：Megastore在被谷歌使用了数年之后，相关技术信息才在2001年公布。CSDN网站亦有文献【39】的中文解读：Google Megastore分布式存储技术全揭秘）。</p>
</li>
<li><p><a href="http://static.googleusercontent.com/media/research.google.com/en/us/archive/spanner-osdi2012.pdf" target="_blank" rel="external">Spanner</a>【40】–这是由谷歌研发的、可扩展的、全球分布式的、同步复制数据库，支持SQL查询访问。（注：Spanner的“老爹”是Big Table，可以说，没有“大表”这个爹，就不可能有这个强有力的“扳手” 儿子。它是第一个把数据分布在全球范围内的系统，并且支持外部一致性的分布式事务）。</p>
</li>
<li><p><a href="http://www.vldb.org/pvldb/vol7/p1259-gupta.pdf" target="_blank" rel="external">MESA</a>【41】–亦是由谷歌研发的、跨地域复制(geo-replicated)、高可用的、可容错的、可扩展的近实时数据仓库系统（注：在2014年的VLDB 大会上，谷歌公布了他们的分析型数据仓库系统MESA，该系统主要用于存储Google互联网广告业务相关的关键衡量数据。文献【41】是VLDB的会议论文）。</p>
</li>
<li><p><a href="https://github.com/cockroachdb/cockroach/blob/master/docs/design.md" target="_blank" rel="external">CockroachDB</a>【42】–该系统是由Google前工程师Spencer Kimball领导开发的Spanner 的开源版本（注：这个项目的绰号是“螳螂（Cockroach）”，其寓意是“活得长久”，因为蟑螂是地球上生命力最强的生物之一，即使被砍下头颅，依然还能存活好几天！文献【42】是代码托管网站GitHub上对Cockroach的说明性文档）。</p>
</li>
</ul>
<h2 id="资源管理器层（Resource-Managers）"><a href="#资源管理器层（Resource-Managers）" class="headerlink" title="资源管理器层（Resource Managers）"></a>资源管理器层（Resource Managers）</h2><p>第一代Hadoop的生态系统，其资源管理是以整体单一的调度器起家的，其代表作品为YARN。而当前的调度器则是朝着分层调度的方向演进（Mesos则是这个方向的代表作），这种分层的调度方式，可以管理不同类型的计算工作负载，从而可获取更高的资源利用率和调度效率。</p>
<ul>
<li><p><a href="https://54e57bc8-a-62cb3a1a-s-sites.googlegroups.com/site/2013socc/home/program/a5-vavilapalli.pdf?attachauth=ANoY7co94J9PVjpjD5GD4z-S8e1O7YrLsqHssH7aeFReTJaoOBLbvLhq9HeDNb-PQz2jQvPUeQbDjJa2bctooZz5_zHCKWXAKZrYqAy_mVCLIQqU0Cc-sNQBHOJNsUTyVPfEdpHQ5yoIGVdIzoCnQwsFjbSX2ztS9b0OBNI2SjDCdvLE7Hsi5ktJINChoFa7w0ELgFvir4sEAJaL-G1qgmUglhOjVjHgwXYsqHH7FOPXrTVC-csZelo=&amp;attredirects=0" target="_blank" rel="external">YARN</a>【43】– 这是新一代的MapReduce计算框架，简称MRv2，它是在第一代MapReduce的基础上演变而来的（注：MRv2的设计初衷是，为了解决第一代Hadoop系统扩展性差、不支持多计算框架等问题。对国内用户而言，原文献下载链接可能会产生404错误，这里提供一个新文献：由2011年剥离自雅虎的Hadoop初创公司Hortonworks给出的<a href="http://hortonworks.com/wp-content/uploads/2013/12/Apache.Hadoop.YARN_.Sample.pdf" target="_blank" rel="external">官方文献</a>【43】new，阅读该文献也可对YARN有较为深入的理解。CSDN亦有对YARN详细解读的文章：<a href="http://file:///D:/iwork/CSDN-%E6%96%87%E7%AB%A0/04-big%20data/%E6%9B%B4%E5%BF%AB%E3%80%81%E6%9B%B4%E5%BC%BA%E2%80%94%E2%80%94%E8%A7%A3%E6%9E%90Hadoop%E6%96%B0%E4%B8%80%E4%BB%A3MapReduce%E6%A1%86%E6%9E%B6Yarn" target="_blank" rel="external">更快、更强——解析Hadoop新一代MapReduce框架Yarn</a>）。</p>
</li>
<li><p><a href="http://people.csail.mit.edu/matei/papers/2011/nsdi_mesos.pdf" target="_blank" rel="external">Mesos</a>【44】–这是一个开源的计算框架，可对多集群中的资源做弹性管理（注：Mesos诞生于UC Berkeley的一个研究项目，现为Apache旗下的一个开源项目，它是一个全局资源调度器。目前Twitter、 Apple等国外大公司正在使用Mesos管理集群资源，国内用户有豆瓣等。文献【44】是加州大学伯克利分校的研究人员发表于著名会议NSDI上的学术论文）。</p>
</li>
</ul>
<p>这些计算框架和调度器之间是松散耦合的，调度器的主要功能就是基于一定的调度策略和调度配置，完成作业调度，以达到工作负载均衡，使有限的资源有较高的利用率。</p>
<h2 id="调度器（Schedulers）"><a href="#调度器（Schedulers）" class="headerlink" title="调度器（Schedulers）"></a>调度器（Schedulers）</h2><p>作业调度器，通常以插件的方式加载于计算框架之上，常见的作业调度器有4种：</p>
<ul>
<li><p><a href="https://hadoop.apache.org/docs/stable1/capacity_scheduler.pdf" target="_blank" rel="external">计算能力调度器</a>【45】（Capacity Scheduler）-该文献是一个关于计算能力调度器的指南式文档，介绍了计算能力调度器的不同特性。</p>
</li>
<li><p><a href="http://www.valleytalk.org/wp-content/uploads/2013/03/fair_scheduler_design_doc.pdf" target="_blank" rel="external">公平调度器</a>【46】（FairShare Scheduler） -该文献是Hadoop的公平调度器设计文档，介绍了公平调度的各项特征（注：公平调度是一种赋予作业资源的方法，它提供了一个基于任务数的负载均衡机制，其目的是让所有的作业随着时间的推移，都能平均的获取等同的共享资源）。</p>
</li>
<li><p><a href="http://www.eecs.berkeley.edu/Pubs/TechRpts/2009/EECS-2009-55.pdf" target="_blank" rel="external">延迟调度</a>【47】（Delayed Scheduling） –该文献是加州大学伯克利分校的一份技术报告，报告介绍了公平调度器的延迟调度策略。</p>
</li>
<li><p><a href="http://arxiv.org/ftp/arxiv/papers/1207/1207.0780.pdf" target="_blank" rel="external">公平与能力调度器</a>【48】（Fair &amp; Capacity schedulers ）–该文献是一篇关于云环境下的Hadoop调度器的综述性论文。</p>
</li>
</ul>
<h2 id="协调器（Coordination）"><a href="#协调器（Coordination）" class="headerlink" title="协调器（Coordination）"></a>协调器（Coordination）</h2><p>在分布式数据系统中，协调器主要用于协调服务和进行状态管理。</p>
<ul>
<li><a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/paxos-simple.pdf" target="_blank" rel="external">Paxos</a>【49】 –文献【49】是经典论文“<a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/lamport-paxos.pdf" target="_blank" rel="external">The Part-Time Parliament（兼职的议会）</a>【50】” 的简化版。</li>
</ul>
<p>注：两篇文献的作者均是莱斯利·兰伯特（Leslie Lamport），此君是个传奇人物，科技论文写作常用编辑器LaTex，其中“La”就是来自其姓“Lamport”的前两个字母。Lamport目前是微软研究院首席研究员，2013年，因其在分布式计算理论领域做出的杰出贡献，荣获计算机领域最高奖——图灵奖。</p>
<p>牛人的故事特别多，Lamport亦是这样。就这两篇文献而言，Lamport的奇闻轶事都值得说道说道。光看其经典论文题目“<a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/lamport-paxos.pdf" target="_blank" rel="external">The Part-Time Parliament（兼职的议会</a>）【50】”，或许就让读者“一头雾水”，这是一篇计算机科学领域的论文吗？和读者一样感觉的可能还有期刊编辑。其实，早在1990年时，Lamport就提出Paxos算法，他虚构了一个希腊城邦Paxos及其议会，以此来形象比喻说明该算法的流程。论文投出后，期刊编辑建议Lamport，将论文用更加严谨的数学语言重新进行描述一下。可Lamport则认为，我的幽默，你不懂！拒绝修改。时隔八年之后的 1998年，Paxos算法才被伯乐期刊《ACM Transactions on Computer Systems》发表。由于Paxos算法本身过于复杂，且同行不理解自己的“幽默”， 于是，2001年Lamport就用简易语言撰写这篇文章，重新发表了该论文的<a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/paxos-simple.pdf" target="_blank" rel="external">简化版</a>【49】，即“Paxos made simple（Paxos变得简单）”。简化版的摘要更简单，就一句话：“Paxos算法，用简易英语说明之，很简单”，如果去掉中间的那个无故紧要的定语从句，就是“Paxos算法，很简单”。弄得你都来不及做深思状，摘要就完了。这…，这…，完全颠覆了我们常用的“三段论式（提问题、解问题、给结论）”的论文摘要写法啊。</p>
<p>后来，随着分布式系统的不断发展壮大，Paxos算法开始大显神威。Google的Chubby和Apache的Zookeeper，都是用Paxos作为其理论基础实现的。就这样， Paxos终于登上大雅之堂，它也为Lamport在2013年获得图灵奖，立下汗马功劳。从Lamport发表Paxos算法的小案例，我们可以看出：彪悍的人生，不需要解释。牛逼的论文，就可以任性！</p>
<ul>
<li><p><a href="http://static.googleusercontent.com/media/research.google.com/en/us/archive/chubby-osdi06.pdf" target="_blank" rel="external">Chubby</a>【51】– 该文献的作者是谷歌工程师Mike Burrows。Chubby系统本质上就是前文提到的Paxos的一个实现版本，主要用于谷歌分布式锁服务。（注：原文链接会出现404错误，CSDN网站有<a href="http://download.csdn.net/download/caohonxian/4602983" target="_blank" rel="external">Chubby论文的下载链接</a>）。</p>
</li>
<li><p><a href="https://www.usenix.org/legacy/event/usenix10/tech/full_papers/Hunt.pdf" target="_blank" rel="external">Zookeeper</a>【52】 –这是Apache Hadoop框架下的Chubby开源版本。它不仅仅提供简单地上锁服务，而事实上，它还是一个通用的分布式协调器，其设计灵感来自谷歌的Chubby（注：众所周知，分布式协调服务开发困难很大，分布式系统中的多进程间很容易发生条件竞争和死锁。ZooKeeper的开发动力就是减轻分布式应用开发的困难，使用户不必从零开始构建协调服务）。</p>
</li>
</ul>
<h2 id="计算框架（Computational-Frameworks）"><a href="#计算框架（Computational-Frameworks）" class="headerlink" title="计算框架（Computational Frameworks）"></a>计算框架（Computational Frameworks）</h2><p>运行时计算框架，可为不同种类的计算，提供运行时（runtime）环境。最常用的是运行时计算框架是Spark和Flink。</p>
<ul>
<li><p><a href="https://www.usenix.org/system/files/login/articles/zaharia.pdf" target="_blank" rel="external">Spark</a>【53】 –因Spark日益普及，加之其具备良好的多计算环境的适用性，它已对传统的Hadoop生态环境，形成了严峻的挑战（注：Spark是一个基于内存计算的开源的集群计算系统，其目的在于，让数据分析更加快速。Spark是由加州大学伯克利分校的AMP实验室采用Scala语言开发而成。Spark的内存计算框架，适合各种迭代算法和交互式数据分析，能够提升大数据处理的实时性和准确性，现已逐渐获得很多企业的支持，如阿里巴巴、百度、网易、英特尔等公司均是其用户）。</p>
</li>
<li><p><a href="http://events.linuxfoundation.org/sites/events/files/slides/flink_apachecon_small.pdf" target="_blank" rel="external">Flink</a>【54】 –这是一个非常类似于Spark的计算框架，但在迭代式数据处理上，比Spark更给力（注：目前大数据分析引擎Flink，已升级成为Apache顶级项目）。</p>
</li>
</ul>
<p>Spark和Flink都属于基础性的大数据处理引擎。具体的计算框架，大体上，可根据采用的模型及延迟的处理不同，来进行分门别类。</p>
<h2 id="批处理（Batch）"><a href="#批处理（Batch）" class="headerlink" title="批处理（Batch）"></a>批处理（Batch）</h2><ul>
<li><p><a href="http://static.googleusercontent.com/media/research.google.com/en/us/archive/mapreduce-osdi04.pdf" target="_blank" rel="external">MapReduce</a>【55】– 这是谷歌有关MapReduce的最早的学术论文（注：对于国内用户，点击原文献链接可能会产生404错误，CSDN网站有MapReduce论文的下载链接）。</p>
</li>
<li><p><a href="http://www.cs.arizona.edu/~bkmoon/papers/sigmodrec11.pdf" target="_blank" rel="external">MapReduce综述</a>【56】 –这是一篇过时、但依然值得一读的、有关MapReduce计算框架的综述性文章。</p>
</li>
</ul>
<h2 id="迭代式（BSP）"><a href="#迭代式（BSP）" class="headerlink" title="迭代式（BSP）"></a>迭代式（BSP）</h2><ul>
<li><p><a href="http://kowshik.github.io/JPregel/pregel_paper.pdf" target="_blank" rel="external">Pregel</a>【57】–这又是一篇谷歌出品的大手笔论文，主要描述了大规模图处理方法（注：Pregel是一种面向图算法的分布式编程框架，其采用的是迭代式的计算模型。它被称之为Google后Hadoop时代的新“三驾马车”之一。另外两驾马车分别是：“交互式”大数据分析系统Dremel和网络搜索引擎Caffeine）。</p>
</li>
<li><p><a href="http://researcher.ibm.com/researcher/files/us-heq/Large%20Scale%20Graph%20Processing%20with%20Apache%20Giraph.pdf" target="_blank" rel="external">Giraph</a>【58】 – 该系统建模于谷歌的Pregel，可视为Pregel的开源版本，它是一个基于 Hadoop架构的、可扩展的分布式迭代图处理系统。</p>
</li>
<li><p><a href="https://amplab.cs.berkeley.edu/wp-content/uploads/2014/02/graphx.pdf" target="_blank" rel="external">GraphX</a>【59】 –这是一个同时采用图并行计算和数据并行的计算框架（注：GraphX最先是加州大学伯克利分校AMPLab实验室的一个分布式图计算框架项目，后来整合到Spark中，成为其中的一个核心组件。GraphX最大的贡献在于，在Spark之上提供一栈式数据解决方案，可方便高效地完成图计算的一整套流水作业）。</p>
</li>
<li><p><a href="http://csl.skku.edu/papers/CS-TR-2010-330.pdf" target="_blank" rel="external">Hama</a>【60】– 是一个构建Hadoop之上的基于BSP模型的分布式计算引擎（注：</p>
</li>
</ul>
<p>Hama的运行环境需要关联 Zookeeper、HBase、HDFS 组件。Hama中最关键的技术，就是采用了BSP模型(Bulk Synchronous Parallel，即整体同步并行计算模型，又名大同步模型)。BSP模型是哈佛大学的计算机科学家Viliant和牛津大学的BillMcColl在1990年联合提出的，他们希望能像冯·诺伊曼体系结构那样，架起计算机程序语言和体系结构间的桥梁，故又称作桥模型(Bridge Model)。</p>
<ul>
<li><a href="http://www.vldb.org/pvldb/vol7/p1047-han.pdf" target="_blank" rel="external">开源图处理系统</a>【61】（Open source graph processing ）-这是滑铁卢大学的研究人员撰写的综述性文献，文献【61】对类Pregel（Pregel-like）的、基于BSP模型的图处理系统进行了实验性的比较。</li>
</ul>
<h2 id="流式（Streaming）"><a href="#流式（Streaming）" class="headerlink" title="流式（Streaming）"></a>流式（Streaming）</h2><ul>
<li><p><a href="https://www.ucviden.dk/portal/files/26907191/Survey_of_real_time_processing_systems_for_big_data_Draft_.pdf" target="_blank" rel="external">流式处理</a>【62】（Stream Processing）- 这是一篇非常棒的、有关面向大数据实时处理系统的综述性文章。</p>
</li>
<li><p><a href="https://cs.brown.edu/courses/cs227/papers/ss-storm.pdf" target="_blank" rel="external">Storm</a>【63】 – 这是一个大数据实时处理系统（注：Storm有时也被人们称为实时处理领域的Hadoop，它大大简化了面向庞大规模数据流的处理机制，从而在实时处理领域扮演着重要角色。文献【63】是Twitter工程师们在2014年发表于SIGMOD上的学术论文）。</p>
</li>
<li><p><a href="http://www.jfokus.se/jfokus15/preso/ApacheSamza.pdf" target="_blank" rel="external">Samza</a>【64】 -这是一款由Linkedin公司开发的分布式的流式数据处理框架（注：所谓流式数据，是指要在处理单位内得到的数据，这种方式更注重于实时性，流式数据有时也称为快数据）。</p>
</li>
<li><p><a href="http://people.csail.mit.edu/matei/papers/2013/sosp_spark_streaming.pdf" target="_blank" rel="external">Spark流</a>【65】（Spark Streaming） -该文献是加州大学伯克利分校的研究人员于2013年在著名操作系统会议SOSP上发表的学术论文，论文题目是《离散流：容错大规模流式计算》（注：这里的离散流是指一种微批处理构架，其桥接了传统的批处理和交互式处理。Spark Streaming是Spark 核心API的一个扩展，它并不会像Storm那样逐个处理数据流，而是在处理前，按时间间隔预先将其切分为很多小段的批处理作业）。</p>
</li>
</ul>
<h2 id="交互式（Interactive）"><a href="#交互式（Interactive）" class="headerlink" title="交互式（Interactive）"></a>交互式（Interactive）</h2><ul>
<li><p><a href="http://www.vldb.org/pvldb/vldb2010/papers/R29.pdf" target="_blank" rel="external">Dremel</a>【66】–这又是一篇由谷歌出品的经典论文，论文描述了如何处理“交互式”大数据的工作负载。该论文是多个基于Hadoop的开源SQL系统的理论基础（注：文献【66】写于2006年，“捂”藏4年之后，于2010年公布于众。文章针对MR交互式查询能力不足，提出了Dremel，阐述了Dremel的设计原理，并提供了部分测试报告）。</p>
</li>
<li><p><a href="http://www.cidrdb.org/cidr2015/Papers/CIDR15_Paper28.pdf" target="_blank" rel="external">Impala</a>【67】 –这是一个大规模并行处理（MPP）式 SQL 大数据分析引擎（注：</p>
</li>
</ul>
<p>Impala像Dremel一样，其借鉴了MPP（Massively Parallel Processing，大规模并行处理）并行数据库的思想，抛弃了MapReduce这个不太适合做SQL查询的范式，从而让Hadoop支持处理交互式的工作负载。本文作者阿尼尔马丹在LinkedIn上的博客原文，在此处的“MPI”系“MPP”笔误，读者可参阅文献【67】发现此问题）。</p>
<ul>
<li><p><a href="http://wiki.apache.org/incubator/DrillProposal?action=AttachFile&amp;do=get&amp;target=Drill%20slides.pdf" target="_blank" rel="external">Drill</a>【68】–这是谷歌 Dremel的开源版本（注：Drill是一个低延迟的、能对海量数据（包括结构化、半结构化及嵌套数据）实施交互式查询的分布式数据引擎）。</p>
</li>
<li><p><a href="http://www.cs.berkeley.edu/~matei/papers/2012/sigmod_shark_demo.pdf" target="_blank" rel="external">Shark</a>【69】 –该文献是2012年发表于SIGMOD的一篇学术论文，论文对Spark生态系统上的数据分析能力，给出了很深入的介绍（注：Shark是由加州伯克利大学AMPLab开发的大数据分析系统。Shark即“Hive on Spark”的含义，本质上是通过Hive的HQL解析，把HQL翻译成Spark上的RDD操作。然后通过Hive的元数据获，取数据库里的表信息。HDFS上的数据和文件，最后会由Shark获取，并放到Spark上运算。Shark基于 Scala语言的算子推导，可实现良好的容错机制，对执行失败的长/短任务，均能从上一个“快照点（Snapshot）”进行快速恢复）。</p>
</li>
<li><p><a href="http://people.csail.mit.edu/matei/papers/2013/sigmod_shark.pdf" target="_blank" rel="external">Shark</a>【70】–这是另外一篇很棒的于2013年发表在SIGMOD的学术论文，其深度解读在Apache Hive之上SQL访问机制（注：这篇文献描述了如何构建在Spark上构建SQL引擎——Shark。更重要的是，文章还讨论了之前在 Hadoop/MapReduce上实施SQL查询如此之慢的原因）。</p>
</li>
<li><p><a href="http://www.news.cs.nyu.edu/~jinyang/sp07/papers/dryad.pdf" target="_blank" rel="external">Dryad</a>【71】– 文献讨论了使用有向无环图(Directed Acycline Graph，DAG)来配置和执行并行数据流水线的方法（注：Dryad是一个通用的粗颗粒度的分布式计算和资源调度引擎，其核心特性之一，就是允许用户自己构建DAG调度拓扑图。文献【71】是微软于2007年在EuroSys国际会议上发布的学术论文）。</p>
</li>
<li><p><a href="http://www.datanubes.com/mediac/ApacheTezPrimer.pdf" target="_blank" rel="external">Tez</a>【72】 –其核心思想来源于Dryad，可视为利用Yarn(即MRv2)对Dryad的开源实现（注：Apache Tez是基于Hadoop Yarn之上的DAG计算框架。由Hadoop的二东家Hortonworks开发并提供主要技术支持。文献【72】是一个关于Tez的简要介绍文档）。</p>
</li>
<li><p><a href="https://www.cs.berkeley.edu/~sameerag/blinkdb_eurosys13.pdf" target="_blank" rel="external">BlinkDB</a>【73】–可在抽样数据上实现交互式查询，其呈现出的查询结果，附带有误差标识。</p>
</li>
</ul>
<p>（注：BlinkDB 是一个用于在海量数据上运行交互式 SQL 查询的大规模并行查询引擎。BlinkDB允许用户通过适当降低数据精度，对数据进行先采样后计算，其通过其独特的优化技术，实现了比Hive快百倍的交互式查询速度，而查询进度误差仅降低2~10%。</p>
<p>BlinkDB采用的策略，与大数据布道师，维克托·迈尔-舍恩伯格在其著作《大数据时代》中提到的观点，“要全体，不要抽样”，恰恰相反。</p>
<p>基于常识，我们知道：多了，你就快不了。好了，你就省不了。对大数据处理而言，也是这样。英特尔中国研究院院长吴甘沙认为，大体量、精确性和速度快，三者不可兼得，顶多取其二。如果要实现在大体量数据上的 “快”，就得想办法减少数据，而减少数据，势必要适度地降低分析精确性。</p>
<p>事实上，大数据并不见得越“大”越好，有时候一味的追求“大”是没有必要的。例如，在医疗健康领域，如果来监控某个病人的体温，可穿戴设备可以一秒钟采集一次数据，也可以一分钟采集一次数据，前者采集的数据总量比后者“大”60倍，但就监控病人身体状况而言，意义并不是太大。虽然后者的数据忽略了人体在一分钟内的变化，监控的精度有所下降，但对于完成监控病人健康状态这一目的而言，是可以接受的。）</p>
<h2 id="实时系统（RealTime）"><a href="#实时系统（RealTime）" class="headerlink" title="实时系统（RealTime）"></a>实时系统（RealTime）</h2><ul>
<li><p><a href="http://static.druid.io/docs/druid.pdf" target="_blank" rel="external">Druid</a>【74】 –这是一个开源的分布式实时数据分析和存储系统，旨在快速处理大规模的数据，并能做到快速查询和分析（注：文献【74】是2014年Druid创始人Eric Tschetter和中国工程师杨仿今等人在SIGMOD上发表的一篇论文）。</p>
</li>
<li><p><a href="https://github.com/linkedin/pinot/wiki/Architecture" target="_blank" rel="external">Pinot</a>【75】 –这是由LinkedIn公司出品的一个开源的、实时分布式的 OLAP数据分析存储系统，非常类似于前面提到的Druid，LinkedIn 使用它实现低延迟可伸缩的实时分析。（注：文献【75】是在GitHub上的有关Pinot的说明性文档）。</p>
</li>
</ul>
<h2 id="数据分析层（Data-Analysis）"><a href="#数据分析层（Data-Analysis）" class="headerlink" title="数据分析层（Data Analysis）"></a>数据分析层（Data Analysis）</h2><p>数据分析层中的工具，涵盖范围很广，从诸如SQL的声明式编程语言，到诸如Pig的过程化编程语言，均有涉及。另一方面，数据分析层中的库也很丰富，可支持常见的数据挖掘和机器学习算法，这些类库可拿来即用，甚是方便。</p>
<h2 id="工具（Tools）"><a href="#工具（Tools）" class="headerlink" title="工具（Tools）"></a>工具（Tools）</h2><ul>
<li><p><a href="http://infolab.stanford.edu/~olston/publications/sigmod08.pdf" target="_blank" rel="external">Pig</a>【76】 –这是一篇有关Pig Latin非常不错的综述文章（注：Pig Latin原是一种儿童黑话，属于是一种英语语言游戏，形式是在英语上加上一点规则使发音改变，让大人们听不懂，从而完成孩子们独懂的交流。文献【76】是雅虎的工程师们于2008年发表在SIGMOD的一篇论文，论文的题目是“Pig Latin：并不是太老外的一种数据语言”，言外之意，他们发明了一种数据处理的“黑话”——Pig Latin，一开始你可能不懂，等你熟悉了，就会发现这种数据查询语言的乐趣所在）。</p>
</li>
<li><p><a href="http://paperhub.s3.amazonaws.com/a7b584c04b61fabb8d10333e91989120.pdf" target="_blank" rel="external">Pig</a>【77】 – 这是另外一篇由雅虎工程师们撰写的有关使用Pig经验的论文，文章介绍了如果利用Pig在Map-Reduce上构建一个高水准的数据流分析系统。</p>
</li>
<li><p><a href="http://infolab.stanford.edu/~ragho/hive-icde2010.pdf" target="_blank" rel="external">Hive</a>【78】 –该文献是Facebook数据基础设施研究小组撰写的一篇学术论文，介绍了Hive的来龙去脉（注：Hive是一个建立于 Hadoop 上的数据仓库基础构架。它用来进行数据的提取、转化和加载（即Extract-Transform-Load ，ETL），它是一种可以存储、查询和分析存储在 Hadoop 中的大规模数据的机制）。</p>
</li>
<li><p><a href="http://www.vldb.org/pvldb/2/vldb09-938.pdf" target="_blank" rel="external">Hive</a>【79】–该文献是另外一篇有关Hive的值得一读的好论文。论文作者来自Facebook数据基础设施研究小组，在这篇论文里，可以帮助读者理解Hive的设计理念。</p>
</li>
<li><p><a href="http://phoenix.apache.org/presentations/OC-HUG-2014-10-4x3.pdf" target="_blank" rel="external">Phoenix</a>【80】 –它是 HBase 的 SQL 驱动（注：Phoenix可将 SQL 查询转成 HBase 的扫描及相应的动作。文献【80】是关于在Hbase上部署SQL的幻灯片文档）。</p>
</li>
<li><p><a href="http://www.ispras.ru/proceedings/docs/2012/23/isp_23_2012_285.pdf" target="_blank" rel="external">Map Reduce上的连接（join）算法</a>【81】–该文献介绍了在Hadoop环境下的各种并行连接算法，并对它们的性能作出系统性评测。</p>
</li>
<li><p><a href="http://grail.csuohio.edu/~sschung/cis612/hadoopjoin_sigmod2010.pdf" target="_blank" rel="external">Map Reduce上的连接算法</a>【82】 –这是威斯康星大学和IBM研究团队撰写的综述性文章，文章对在Map Reduce模型下的各种连接算法进行了综合比较。</p>
</li>
</ul>
<h2 id="库（Libraires）"><a href="#库（Libraires）" class="headerlink" title="库（Libraires）"></a>库（Libraires）</h2><ul>
<li><p><a href="http://stanford.edu/~rezab/sparkworkshop/slides/xiangrui.pdf" target="_blank" rel="external">MLlib</a>【83】–这是在Spark计算框架中对常用的机器学习算法的实现库，该库还包括相关的测试和数据生成器（注：文献【83】是MLlib的一个幻灯片说明文档）。</p>
</li>
<li><p><a href="http://files.meetup.com/3138542/SparkR-meetup.pdf" target="_blank" rel="external">SparkR</a>【84】–这是AMPLab发布的一个R开发包，为Apache Spark提供轻量级的前端（注：R是一种广泛应用于统计分析、绘图的语言及操作环境。文献【84】是有关SparkR的幻灯片文档）。</p>
</li>
<li><p><a href="http://openresearch.baidu.com/u/cms/www/201210/30144944cqmu.pdf" target="_blank" rel="external">Mahout</a>【85】 –这是一个功能强大的数据挖掘工具，是一个基于传统Map Reduce的分布式机器学习框架（注：Mahout的中文含义就是“驭象之人”，而Hadoop的Logo正是一头小黄象。很明显，这个库是帮助用户用好Hadoop这头难用的大象。文献【85】是有关Mahout的图书）。</p>
</li>
</ul>
<h2 id="数据集成层（Data-Integration）"><a href="#数据集成层（Data-Integration）" class="headerlink" title="数据集成层（Data Integration）"></a>数据集成层（Data Integration）</h2><p>数据集成框架提供了良好的机制，以协助高效地摄取和输出大数据系统之间的数据。从业务流程线到元数据框架，数据集成层皆有涵盖，从而提供全方位的数据在整个生命周期的管理和治理。</p>
<h2 id="摄入-消息传递（Ingest-Messaging）"><a href="#摄入-消息传递（Ingest-Messaging）" class="headerlink" title="摄入/消息传递（Ingest/Messaging）"></a>摄入/消息传递（Ingest/Messaging）</h2><ul>
<li><p><a href="https://blogs.apache.org/flume/entry/flume_ng_architecture" target="_blank" rel="external">Flume</a>【86】 –这是Apache旗下的一个分布式的、高可靠的、高可用的服务框架，可协助从分散式或集中式数据源采集、聚合和传输海量日志（注：文献【86】是Apache网站上有关Flume的一篇博客文章）。</p>
</li>
<li><p><a href="https://cwiki.apache.org/confluence/download/attachments/27361435/Cecho_Ting_SqoopBigDataTechCon.pdf?version=1&amp;modificationDate=1366107169000&amp;api=v2" target="_blank" rel="external">Sqoop</a>【87】–该系统主要用来在Hadoop和关系数据库中传递数据（注：Sqoop目前已成为Apache的顶级项目之一。通过Sqoop，可以方便地将数据从关系数据库导入到HDFS，或反之亦可。文献【87】是有关Sqoop的幻灯片说明文档）。</p>
</li>
<li><p><a href="http://notes.stephenholiday.com/Kafka.pdf" target="_blank" rel="external">Kafka</a>【88】 –这是由LinkedIn开发的一个分布式消息系统（注：由Scala编写而成的Kafka，由于可水平扩展、吞吐率高等特性，得到广泛应用。文献【88】是LindedIn的工程师们在2011年发表于NetDB的会议论文）。</p>
</li>
</ul>
<h2 id="ETL-工作流"><a href="#ETL-工作流" class="headerlink" title="ETL/工作流"></a>ETL/工作流</h2><p>ETL是数据抽取（Extract）、清洗（Cleaning）、转换（Transform）、装载（Load）的过程，是构建数据仓库的重要一环。</p>
<ul>
<li><p><a href="http://events.linuxfoundation.org/sites/events/files/slides/Simplifying%20Big%20Data%20with%20Apache%20Crunch.pdf" target="_blank" rel="external">Crunch</a>【89】–这是Apache旗下的一套Java API函数库，它能够大大简化编写、测试、运行MapReduce 处理工作流的程序（注：文献【89】是有关Crunch的幻灯片解释文档）。</p>
</li>
<li><p><a href="http://public-repo-1.hortonworks.com/HDP-LABS/Projects/Falcon/2.0.6.0-76/FalconHortonworksTechnicalPreview.pdf" target="_blank" rel="external">Falcon</a>【90】– 这是Apache旗下的Falcon大数据管理框架，可以帮助用户自动迁移和处理大数据集合（注：文献【90】是一份关于Falcon技术预览报告）。</p>
</li>
<li><p><a href="http://smokinn.com/files/cascading_notes/cascading.pdf" target="_blank" rel="external">Cascading</a>【91】 –这是一个架构在Hadoop上的API函数库，用来创建复杂的可容错的数据处理工作流（注：文献【91】是关于Hadoop上的Cascading的概论和技术随笔）。</p>
</li>
<li><p><a href="http://oozie.apache.org/docs/4.2.0/index.html" target="_blank" rel="external">Oozie</a>【92】–是一个工作流引擎，用来协助Hadoop作业管理（注：Oozie字面含义是驯象之人，其寓意和Mahout一样，帮助用户更好地搞定Hadoop这头大象。文献【92】是Apache网站上有关Oozie的官方文档）。</p>
</li>
</ul>
<h2 id="元数据（Metadata）"><a href="#元数据（Metadata）" class="headerlink" title="元数据（Metadata）"></a>元数据（Metadata）</h2><ul>
<li><a href="https://cwiki.apache.org/confluence/display/Hive/HCatalog+UsingHCat" target="_blank" rel="external">HCatalog</a>【93】– 它提供了面向Apache Hadoop的数据表和存储管理服务（注：Apache HCatalog提供一个共享的模式和数据类型的机制，它抽象出表，使用户不必关心数据怎么存储，并提供了可操作的跨数据处理工具。文献【93】是Apache网站有关Hcatalog的官方说明文档）。</li>
</ul>
<h2 id="序列化（Serialization）"><a href="#序列化（Serialization）" class="headerlink" title="序列化（Serialization）"></a>序列化（Serialization）</h2><ul>
<li><p><a href="http://homepages.lasige.di.fc.ul.pt/~vielmo/notes/2014_02_12_smalltalk_protocol_buffers.pdf" target="_blank" rel="external">Protocol Buffers</a>【94】 –由Google推广的一种与语言无关的、对结构化数据进行序列化和反序列化的机制（注：Protocol Buffers可用于通讯协议、数据存储等领域的语言及平台无关、可扩展的序列化结构数据格式。文献【94】是有关Protocol Buffers幻灯片文档）。</p>
</li>
<li><p><a href="http://mil-oss.org/resources/mil-oss-wg3_an-introduction-to-apache-avro_douglas-creager.pdf" target="_blank" rel="external">Avro</a>【95】 –这是一个建模于Protocol Buffers之上的、Hadoop生态系统中的子项目（注：Avro本身既是一个序列化框架，同时也实现了RPC的功能）。</p>
</li>
</ul>
<h2 id="操作框架（Operational-Frameworks）"><a href="#操作框架（Operational-Frameworks）" class="headerlink" title="操作框架（Operational Frameworks）"></a>操作框架（Operational Frameworks）</h2><p>最后，我们还需要一个操作性框架，来构建一套衡量标准和测试基准，从而来评价各种计算框架的性能优劣。在这个操作性框架中，还需要包括性能优化工具，借助它来平衡工作负载。</p>
<h2 id="监测管理框架（Monitoring-Frameworks）"><a href="#监测管理框架（Monitoring-Frameworks）" class="headerlink" title="监测管理框架（Monitoring Frameworks）"></a>监测管理框架（Monitoring Frameworks）</h2><ul>
<li><p><a href="http://opentsdb.net/overview.html" target="_blank" rel="external">OpenTSDB</a>【96】 –这是构建于HBase之上的实时性能评测系统（注：文献【96】提供了OpenTSDB的简要概述，介绍了OpenTSDB的工作机理）。</p>
</li>
<li><p><a href="https://issues.apache.org/jira/secure/attachment/12559939/Ambari_Architecture.pdf" target="_blank" rel="external">Ambari</a>【97】– 这是一款基于Web的系统，支持Apache Hadoop集群的供应、管理和监控（注：文献【97】阐述了Ambari架构的设计准则）。</p>
</li>
</ul>
<h2 id="基准测试（Benchmarking）"><a href="#基准测试（Benchmarking）" class="headerlink" title="基准测试（Benchmarking）"></a>基准测试（Benchmarking）</h2><ul>
<li><p><a href="http://research.ijais.org/volume7/number8/ijais14-451229.pdf" target="_blank" rel="external">YCSB</a>【98】 –该文献是一篇使用YCSB对NoSQL系统进行性能评估的期刊论文（注：YCSB是雅虎云服务基准测试（Yahoo! Cloud Serving Benchmark）的简写。见名知意，它是由雅虎出品的一款通用云服务性能测试工具）。</p>
</li>
<li><p><a href="https://hadoop.apache.org/docs/stable1/gridmix.pdf" target="_blank" rel="external">GridMix</a>【99】 –该系统通过运行大量合成的作业，对Hadoop系统进行基准测试，从而获得性能评价指标（注：文献是Apache网站有关GridMix的官方说明文档）。</p>
</li>
</ul>
<p>最后一篇文献是有关大数据基准测试的<a href="http://arxiv.org/ftp/arxiv/papers/1402/1402.5194.pdf" target="_blank" rel="external">综述文章</a>【100】，文章讨论了基准测试的最新技术进展以及所面临的几个主要挑战。</p>
<p>译者寄语：</p>
<p>在你迈步于大数据的旅途中，真心希望这些文献能助你一臂之力。但要知道，有关大数据的文献，何止千万，由于个人精力、能力有限，有些领域也不甚熟稔，故难免会挂一漏万。如有疏忽，漏掉你的大作，还请你海涵。最后，希望这些文献能给你带来“学而时习之，不亦乐乎”的快感！</p>
<p>译者介绍：张玉宏，博士。2012年毕业于电子科技大学，现执教于河南工业大学。中国计算机协会（CCF）会员，ACM/IEEE会员。主要研究方向为高性能计算、生物信息学，主编有《Java从入门到精通》一书。</p>
<p>原文来自：<a href="https://www.linkedin.com/pulse/100-open-source-big-data-architecture-papers-anil-madan" target="_blank" rel="external">LinkeDin</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SVN版本管理]]></title>
      <url>http://www.wulai.me/2015/05/29/svn-e7-89-88-e6-9c-ac-e7-ae-a1-e7-90-86/</url>
      <content type="html"><![CDATA[<h2 id="一、版本库结构"><a href="#一、版本库结构" class="headerlink" title="一、版本库结构"></a>一、版本库结构</h2><h3 id="1-1-项目在版本仓库中的目录"><a href="#1-1-项目在版本仓库中的目录" class="headerlink" title="1.1 项目在版本仓库中的目录"></a>1.1 项目在版本仓库中的目录</h3><p>trunk、branches、tags，这是一个项目在版本仓库中典型的目录布局。</p>
<ul>
<li>trunk：主干，如果说把一个软件项目从开始到消亡比作一个故事的话，主线情节都在这里被SVN记录着。</li>
<li>branches：分支，有很多种用法，比如：版本发布维护分支、新特性开发分支，甚至是缺陷修复分支等等。</li>
<li>tags：标签，或者叫快照，某个版本发布时候，都在这里留档。</li>
</ul>
<h3 id="1-2-示例如下图："><a href="#1-2-示例如下图：" class="headerlink" title="1.2 示例如下图："></a>1.2 示例如下图：</h3><h2 id="二、命令行"><a href="#二、命令行" class="headerlink" title="二、命令行"></a>二、命令行</h2><h3 id="2-1-svnadmin-create"><a href="#2-1-svnadmin-create" class="headerlink" title="2.1 svnadmin create"></a>2.1 svnadmin create</h3><p>创建版本库</p>
<h3 id="2-2-svn-cp"><a href="#2-2-svn-cp" class="headerlink" title="2.2 svn cp"></a>2.2 svn cp</h3><p>复制版本</p>
<h3 id="2-3-svn-branch"><a href="#2-3-svn-branch" class="headerlink" title="2.3 svn branch"></a>2.3 svn branch</h3><p>创建分支</p>
<h3 id="2-4-svn-merge"><a href="#2-4-svn-merge" class="headerlink" title="2.4 svn merge"></a>2.4 svn merge</h3><p>合并分支</p>
<h3 id="2-5-svn-tag"><a href="#2-5-svn-tag" class="headerlink" title="2.5 svn tag"></a>2.5 svn tag</h3>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[mac上eclipse 安装 javaHL时出错]]></title>
      <url>http://www.wulai.me/2015/05/28/176/</url>
      <content type="html"><![CDATA[<p>一、下载serf-1.3.8.tar.bz2出错</p>
<p>通过浏览器（可以翻出去）把serf-1.3.8.tar.bz2下载，更名为subversion–serf-1.3.8.tar.bz2<br>保存至/Library/Caches/Homebrew/subversion-1.8.13.tar.bz2路径下，就OK了～解决了shell不能翻出去的苦恼了～</p>
<p>二、出现zlib错误</p>
<pre><code>brew unlink zlib
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[如何管理阿里云无外网带宽的云主机]]></title>
      <url>http://www.wulai.me/2015/04/28/e5-a6-82-e4-bd-95-e7-ae-a1-e7-90-86-e9-98-bf-e9-87-8c-e4-ba-91-e6-97-a0-e5-a4-96-e7-bd-91-e5-b8-a6-e5-ae-bd-e7-9a-84-e4-ba-91-e4-b8-bb-e6-9c-ba/</url>
      <content type="html"><![CDATA[<p>可见，某些情况下还是值得这么做的。但开通主机之后，因为没有公网带宽，所以也给我们的使用带来了一些麻烦，这里讲一下我的解决办法。 没有公网，用不了外网的，无论上传还是下载，但在同一机房的其他主机，还是可以访问的，所以我们要做一个跳板，利用我们已有的云主机跳转。</p>
<p>这里要明确以下要点： 1、两台服务器必须在同一个数据中心，比如一台在杭州，一台在青岛，不在一个内网，肯定没法操作的；</p>
<p>2、两太服务器必须在同一个帐号下。不在同一个下面，默认有防火墙阻止，不能互相访问的，需要提交工单请客服设置；</p>
<p>技术上，通过Linux iptables，或者ssh转发都可以实现，iptables转发更简单，比如我们的主服务器，就是有公网带宽，可以访问外网的那一台， 一般我们通过22端口进行ssh操作。我们可以将2222端口转发到数据库服务器，在ssh工具里面就可以管理了。</p>
<p>首先，打开ip转发：</p>
<pre><code>echo 1 &amp;gt; /proc/sys/net/ipv4/ip_forward
`&lt;/pre&gt;

然后依次输入以下命令：

&gt; &gt; A机有公网IP ，内网IP为 10.160.39.22
</code></pre><blockquote>
<blockquote>
<pre><code>B机无公网IP ，内网IP为 10.160.30.11
</code></pre></blockquote>
</blockquote>
<pre><code>规则：

&lt;pre&gt;`iptables -t nat -A PREROUTING -p tcp --dport 2222 -j DNAT --to-destination 10.160.30.11:22
iptables -t nat -A POSTROUTING -d 10.160.30.11 -p tcp --dport 22 -j SNAT --to 10.160.39.22
</code></pre><p>然后保存、重启 service iptables save service iptables restart</p>
<p>现在，我们就能通过putty、xshell等工具管理了。ip地址填有公网ip的，端口填2222，其他如旧，很快就能登录上去了</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MYSQL服务无法启动：InnoDB: .\ibdata1 can&#039;t be opened in read-write mode]]></title>
      <url>http://www.wulai.me/2015/04/22/mysql-e6-9c-8d-e5-8a-a1-e6-97-a0-e6-b3-95-e5-90-af-e5-8a-a8-ef-bc-9ainnodb-ibdata1-cant-be-opened-in-read-write-mode/</url>
      <content type="html"><![CDATA[<p>今天在那做实验倒腾mysql数据库，后来发现服务无法启动，查看日志报错如下：</p>
<p>2015-01-07 17:48:54 9136 [ERROR] InnoDB: .\ibdata1 can’t be opened in read-write mode<br>2015-01-07 17:48:54 9136 [ERROR] InnoDB: The system tablespace must be writable!<br>2015-01-07 17:48:54 9136 [ERROR] Plugin ‘InnoDB’ init function returned error.<br>2015-01-07 17:48:54 9136 [ERROR] Plugin ‘InnoDB’ registration as a STORAGE ENGINE failed.<br>2015-01-07 17:48:54 9136 [ERROR] Unknown/unsupported storage engine: InnoDB<br>2015-01-07 17:48:54 9136 [ERROR] Aborting</p>
<p>解决方法：<br>1、打开任务管理器终止mysqld进程；<br>2、打开mysql安装目录的data文件夹，删除以下2个文件：<br>ib_logfile0和ib_logfile1</p>
<p>3、重新启动mysql</p>
<hr>
<p>Dylan    Presents.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[查看MySQL的错误日志的方法]]></title>
      <url>http://www.wulai.me/2015/04/22/e6-9f-a5-e7-9c-8bmysql-e7-9a-84-e9-94-99-e8-af-af-e6-97-a5-e5-bf-97-e7-9a-84-e6-96-b9-e6-b3-95/</url>
      <content type="html"><![CDATA[<p>我们经常在运行MySQL时会出一些错误，也经常被这些错误搞得晕头转向。当然解决这些问题的首要任务是找到日志信息。</p>
<p>MySQL的错误信息是在data目录下的，且文件名为<hostname>.err(<hostname>指的是主机名)，但由于每个人安装的环境不一样，或你忘记了data目录的所在位置，你可以通过下面方法查找。</hostname></hostname></p>
<pre><code>#hostname //获得主机名 
&amp;lt;hostname&amp;gt; 
#find / -name &amp;lt;hostname&amp;gt;.err 
..... 

#cd ... 

#vi &amp;lt;hostname&amp;gt;.err
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[如何查看apache,php,mysql的编译参数]]></title>
      <url>http://www.wulai.me/2015/03/20/e5-a6-82-e4-bd-95-e6-9f-a5-e7-9c-8bapachephpmysql-e7-9a-84-e7-bc-96-e8-af-91-e5-8f-82-e6-95-b0/</url>
      <content type="html"><![CDATA[<p>查看nginx编译参数：/usr/local/nginx/sbin/nginx -V</p>
<p>查看apache编译参数：cat /usr/local/apache2/build/config.nice</p>
<p>查看mysql编译参数：cat /usr/local/mysql/bin/mysqlbug | grep CONFIGURE_LINE</p>
<p>查看php编译参数：/usr/local/php/bin/php -i | grep configure</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[IE提交ajax提交304]]></title>
      <url>http://www.wulai.me/2014/12/30/ie-e6-8f-90-e4-ba-a4ajax-e6-8f-90-e4-ba-a4304/</url>
      <content type="html"><![CDATA[<p>增加cache</p>
<pre><code>$.ajax({  
    cache : false,  
    url : &quot;sendCode.html&quot;,  
    data : {phone : value}  
});  
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[php echo或者exit输出中文]]></title>
      <url>http://www.wulai.me/2014/12/19/php-echo-e6-88-96-e8-80-85exit-e8-be-93-e5-87-ba-e4-b8-ad-e6-96-87/</url>
      <content type="html"><![CDATA[<p>你这是中文乱码，原因是操作环境的编码和浏览器的编码不一致造成的 1. php文件本身的编码与网页的编码应匹配</p>
<p>a. 如果欲使用gb2312编码，那么php要输出头：header(“Content-Type: text/html; charset=gb2312”)，静态页面添加<meta http-equiv="Content-Type" content="text/html; charset=gb2312"><br>，所有文件的编码格式为ANSI，可用记事本打开，另存为选择编码为ANSI，覆盖源文件。</p>
<p>b. 如果欲使用utf-8编码，那么php要输出头 ：header(“Content-Type: text/html; charset=utf-8”)，静态页面添加<meta http-equiv="Content-Type" content="text/html; charset=utf-8"><br>，所有文件的编码格式为utf-8。保存为utf-8可能会有点麻烦，一般utf-8文件开头会有BOM，如果使用 session就会出问题，可用editplus来保存，在editplus中，工具-&gt;参数选择-&gt;文件-&gt;UTF-8签名，选择总是删除，再保存就可以去掉BOM信息了。</p>
<ol>
<li>php本身不是Unicode的，所有substr之类的函数得改成mb_substr（需要装mbstring扩展）；或者用iconv转码。</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[预排序遍历树算法(modified preorder tree traversal algorithm)]]></title>
      <url>http://www.wulai.me/2014/12/13/e9-a2-84-e6-8e-92-e5-ba-8f-e9-81-8d-e5-8e-86-e6-a0-91-e7-ae-97-e6-b3-95-e9-9d-9e-e9-80-92-e5-bd-92-e6-97-a0-e9-99-90-e6-9e-81-e5-88-86-e7-b1-bb-e7-ae-97-e6-b3-95-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0/</url>
      <content type="html"><![CDATA[<p>本文是我学习MySQL官方教程Managing Hierarchical Data in MySQL的笔记 多层数据结构估计所有的web开发者估计都不会陌生，各种软件的分类都是基于多层结构来设计的。 下面是一个典型的多层数据结构示意图：</p>
<p><a href="http://www.hillock.com.cn/wp-content/uploads/2014/12/thum-be1b6320354e5c0879737b855764e9d920100326152818.png" target="_blank" rel="external"><img src="http://www.hillock.com.cn/wp-content/uploads/2014/12/thum-be1b6320354e5c0879737b855764e9d920100326152818.png" alt="thum-be1b6320354e5c0879737b855764e9d920100326152818"></a></p>
<p>相关创建数据语句：</p>
<pre><code>CREATE TABLE category(
category_id INT AUTO_INCREMENT PRIMARY KEY,
name VARCHAR(20) NOT NULL,
parent INT DEFAULT NULL);

INSERT INTO category
VALUES(1,&apos;ELECTRONICS&apos;,NULL),(2,&apos;TELEVISIONS&apos;,1),(3,&apos;TUBE&apos;,2),
(4,&apos;LCD&apos;,2),(5,&apos;PLASMA&apos;,2),(6,&apos;PORTABLE ELECTRONICS&apos;,1),
(7,&apos;MP3 PLAYERS&apos;,6),(8,&apos;FLASH&apos;,7),
(9,&apos;CD PLAYERS&apos;,6),(10,&apos;2 WAY RADIOS&apos;,6);

SELECT * FROM category ORDER BY category_id;
`&lt;/pre&gt;

在这种数据结构中，各层之间通过字段 parent 来形成邻接表，我们查询某些层级的关系的时候一般都是通过递归的方式，遍历某个层级关系的SQL的查询次数会顺着层级的增加，想想在层级有20的时候，根据某个底层节点取它到顶层节点的查询次数吧。

为了解决这个问题，人们想出了嵌套集模型（The Nested Set Model），请看下图：

[![thum-90ef2a4a3357d5de8e8e0d1bc026294820100326152302](http://www.hillock.com.cn/wp-content/uploads/2014/12/thum-90ef2a4a3357d5de8e8e0d1bc026294820100326152302.png)](http://www.hillock.com.cn/wp-content/uploads/2014/12/thum-90ef2a4a3357d5de8e8e0d1bc026294820100326152302.png) 上图依然是表现的与图一相同的层级关系，但是却更换了一种表现形式 下面是新的关系表和数据（关系和数据与之前相同，但是表结构不一样）：

&lt;pre&gt;`CREATE TABLE nested_category (
category_id INT AUTO_INCREMENT PRIMARY KEY,
name VARCHAR(20) NOT NULL,
lft INT NOT NULL,
rgt INT NOT NULL,
deleted TINYINT(8)  NOT NULL DEFAULT &apos;0&apos;,
);

INSERT INTO nested_category
VALUES(1,&apos;ELECTRONICS&apos;,1,20),(2,&apos;TELEVISIONS&apos;,2,9),(3,&apos;TUBE&apos;,3,4),
(4,&apos;LCD&apos;,5,6),(5,&apos;PLASMA&apos;,7,8),(6,&apos;PORTABLE ELECTRONICS&apos;,10,19),
(7,&apos;MP3 PLAYERS&apos;,11,14),(8,&apos;FLASH&apos;,12,13),
(9,&apos;CD PLAYERS&apos;,15,16),(10,&apos;2 WAY RADIOS&apos;,17,18);

SELECT * FROM nested_category ORDER BY category_id;
`&lt;/pre&gt;

这里将 left,right 修改为 lft,rgt因为这两个词在MYSQL中属于关键字 下面我们将插入的数据标识在图上： [![thum-a618905c95b8d6aa42cf4c29f7d0546a20100326152746](http://www.hillock.com.cn/wp-content/uploads/2014/12/thum-a618905c95b8d6aa42cf4c29f7d0546a20100326152746.png)](http://www.hillock.com.cn/wp-content/uploads/2014/12/thum-a618905c95b8d6aa42cf4c29f7d0546a20100326152746.png) 同样，我们将数据标识在原来的结构上： [![thum-be1b6320354e5c0879737b855764e9d920100326152818](http://www.hillock.com.cn/wp-content/uploads/2014/12/thum-be1b6320354e5c0879737b855764e9d9201003261528181.png)](http://www.hillock.com.cn/wp-content/uploads/2014/12/thum-be1b6320354e5c0879737b855764e9d9201003261528181.png)

怎么样，是不是很明确了

下面使我自己标定一种形式，方便理解

&lt;pre&gt;`[1
      [2
           [3 4] 
           [5 6] 
           [7 8]
      9] 
      [10
           [11
                 [12 13]
           14]
           [15 16]
           [17 18]
      19]
20]
`&lt;/pre&gt;

遍历整个树，查询子集 条件：左边 &gt; 父级L， 右边 &amp;lt; 父级R

&lt;pre&gt;`SELECT node.name
FROM nested_category AS node,
nested_category AS parent
WHERE node.lft BETWEEN parent.lft AND parent.rgt
AND parent.name = &apos;ELECTRONICS&apos;
ORDER BY node.lft;
`&lt;/pre&gt;
</code></pre><ul>
<li>查询所有无分支的节点 条件：右边 = 左边L + 1<br><pre><code>SELECT name FROM nested_category WHERE rgt = lft + 1;</code></pre><p></p></li>
<li>查询某个字节点到根节点的路径<pre>`
SELECT parent.name    FROM nested_category AS node, nested_category AS parent    WHERE node.lft BETWEEN parent.lft AND parent.rgt AND node.name = 'FLASH' ORDER BY parent.lft;
`</pre></li>
<li>查询节点的深度<pre>`
SELECT node.name, (COUNT(parent.name) - 1) AS depth    FROM nested_category AS node, nested_category AS parent    WHERE node.lft BETWEEN parent.lft AND parent.rgt    GROUP BY node.name    ORDER BY node.lft;
`</pre></li>
<li>查询子节点的深度<pre>`
SELECT node.name, (COUNT(parent.name) - (sub_tree.depth + 1)) AS depth    FROM nested_category AS node, nested_category AS parent, nested_category AS sub_parent,      ( SELECT node.name, (COUNT(parent.name) - 1) AS depth      FROM nested_category AS node, nested_category AS parent      WHERE node.lft BETWEEN parent.lft AND parent.rgt AND node.name = 'PORTABLE ELECTRONICS'      GROUP BY node.name ORDER BY node.lft ) AS sub_tree
WHERE node.lft BETWEEN parent.lft AND parent.rgt AND node.lft BETWEEN sub_parent.lft AND sub_parent.rgt AND sub_parent.name = sub_tree.name GROUP BY node.name    ORDER BY node.lft;
`</pre></li>
<li>插入新节点 算法详解：<br> 1.所有分类 左边和右边的值 &gt; 插入节点的左边节点记录的右值 的全部 + 2     2.插入节点 左值 = 插入位置左边节点记录的右值 + 1， 右值 = 插入位置左边节点记录的右值 + 2    例子: 在 R = 9（L8, R9）与 L = 10（L10，R11） 节点之间插入一个新节点 那么所有 左值 和 右值 &gt; 9 的节点的左值和右值需要 + 2         例如新节点右边的节点（L10，R11）左值右值都需要 + 2 那么插入后的新值为 L12 R13 新节点的左值为 9 + 1 = 10 右值为 9 + 2 = 11 SQL语句实现<pre>`
LOCK TABLE nested_category WRITE;
SELECT @myRight := rgt FROM nested_category WHERE name = 'TELEVISIONS';
UPDATE nested_category SET rgt = rgt + 2 WHERE rgt > @myRight;
UPDATE nested_category SET lft = lft + 2 WHERE lft > @myRight;    INSERT INTO nested_category(name, lft, rgt) VALUES('GAME CONSOLES', @myRight + 1, @myRight + 2);
UNLOCK TABLES;
`</pre></li>
<li><p>删除新节点 删除节点的算法与添加一个节点的算法相反</p>
<p></p><p>删除一个没有子节点的节点</p>
<pre>`
LOCK TABLE nested_category WRITE; 
SELECT @myLeft := lft, @myRight := rgt, @myWidth := rgt - lft + 1 FROM nested_category WHERE name = 'GAME CONSOLES'; 
DELETE FROM nested_category WHERE lft BETWEEN @myLeft AND @myRight;
UPDATE nested_category SET rgt = rgt - @myWidth WHERE rgt > @myRight;
UPDATE nested_category SET lft = lft - @myWidth WHERE lft > @myRight;
UNLOCK TABLES;
`</pre>

<p>删除一个分支节点和它所有的子节点</p>
<pre>`
LOCK TABLE nested_category WRITE; 
SELECT @myLeft := lft, @myRight := rgt, @myWidth := rgt - lft + 1 FROM nested_category WHERE name = 'MP3 PLAYERS'; 
DELETE FROM nested_category WHERE lft BETWEEN @myLeft AND @myRight; 
UPDATE nested_category SET rgt = rgt - @myWidth WHERE rgt > @myRight; 
UPDATE nested_category SET lft = lft - @myWidth WHERE lft > @myRight; 
UNLOCK TABLES;
`</pre>

<p>删除一个节点后移动其字节点到</p>
<pre>`
LOCK TABLE nested_category WRITE; 
SELECT @myLeft := lft, @myRight := rgt, @myWidth := rgt - lft + 1 FROM nested_category WHERE name = 'PORTABLE ELECTRONICS';
DELETE FROM nested_category WHERE lft = @myLeft; 
UPDATE nested_category SET rgt = rgt - 1, lft = lft - 1 WHERE lft BETWEEN @myLeft AND @myRight;
UPDATE nested_category SET rgt = rgt - 2 WHERE rgt > @myRight; 
UPDATE nested_category SET lft = lft - 2 WHERE lft > @myRight; 
UNLOCK TABLES;
`</pre>

<h3 id="补充：移动一个分类"><a href="#补充：移动一个分类" class="headerlink" title="补充：移动一个分类"></a>补充：移动一个分类</h3><p>将分类5移动到分类9下面</p>
<pre>`LOCK TABLE nested_category WRITE;
SELECT @myLeft := lft, @myRight := rgt, @myWidth := rgt - lft + 1
FROM nested_category
WHERE  category_id = 5;
UPDATE nested_category SET deleted=2 WHERE lft BETWEEN @myLeft AND @myRight;
UPDATE nested_category SET rgt = rgt - @myWidth WHERE rgt > @myRight AND deleted=0;
UPDATE nested_category SET lft = lft - @myWidth WHERE lft > @myRight AND deleted=0;

SELECT @destLeft := lft,@destRight := rgt FROM nested_category WHERE  category_id = 9;

UPDATE nested_category SET rgt = rgt + @myWidth WHERE rgt > @destRight AND deleted=0;
UPDATE nested_category SET lft = lft + @myWidth WHERE lft > @destRight AND deleted=0;

UPDATE nested_category SET rgt = rgt -(@myLeft-@destRight) WHERE deleted=2;
UPDATE nested_category SET lft = lft -(@myLeft-@destRight) WHERE deleted=2;
UPDATE nested_category SET rgt = rgt + @myWidth WHERE category_id = 9;
UPDATE nested_category SET deleted=0 WHERE  deleted=2;
UNLOCK TABLES;
`</pre>

<p>将分类5移动到分类9前面</p>
<p><pre>`<br>SELECT @myLeft := lft, @myRight := rgt, @myWidth := rgt - lft + 1 FROM nested_category WHERE  category_id = 5;<br>UPDATE nested_category SET deleted=2 WHERE lft BETWEEN @myLeft AND @myRight;<br>UPDATE nested_category SET rgt = rgt - @myWidth WHERE rgt &gt; @myRight AND deleted=0;<br>UPDATE nested_category SET lft = lft - @myWidth WHERE lft &gt; @myRight AND deleted=0;</pre></p>
<p>SELECT @destLeft := lft,@destRight := rgt FROM nested_category WHERE  category_id = 9;</p>
<p>UPDATE nested_category SET rgt = rgt + @myWidth WHERE rgt &gt;= @destLeft  AND deleted=0;<br>UPDATE nested_category SET lft = lft + @myWidth WHERE lft &gt;= @destLeft AND deleted=0;</p>
<p>UPDATE nested_category SET rgt = rgt -(@myLeft-@destRight) WHERE deleted=2;<br>UPDATE nested_category SET lft = lft -(@myLeft-@destRight) WHERE deleted=2;<br>UPDATE nested_category SET deleted=0 WHERE  deleted=2;<br>UNLOCK TABLES;</p>
</li>
</ul>
<p>总结： 预排序遍历树算法的核心就是牺牲了写的性能来换取读取的性能 在你的开发的应用遇到此类问题的时（读压力 &gt; 写压力），尝试下使用预排序遍历树算法来提高你的程序的性能吧。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[nginx 全局变量对照]]></title>
      <url>http://www.wulai.me/2014/12/05/nginx-e5-85-a8-e5-b1-80-e5-8f-98-e9-87-8f-e5-af-b9-e7-85-a7/</url>
      <content type="html"><![CDATA[<p>remote_addr     客户端ip,如：192.168.4.2<br>binary_remote_addr  客户端ip（二进制)<br>remote_port     客户端port，如：50472<br>remote_user     已经经过Auth Basic Module验证的用户名<br>host            请求主机头字段，否则为服务器名称，如:dwz.stamhe.com<br>request         用户请求信息，如：GET /?_a=index&amp;_m=show&amp;count=10 HTTP/1.1<br>request_filename    当前请求的文件的路径名，由root或alias和URI request组合而成，如：/webserver/htdocs/dwz/index.php<br>status          请求的响应状态码,如:200<br>body_bytes_sent 响应时送出的body字节数数量。即使连接中断，这个数据也是精确的,如：40<br>content_length  请求头中的Content-length字段<br>content_type    请求头中的Content-Type字段<br>http_referer    引用地址<br>http_user_agent 客户端agent信息,如：Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.57 Safari/536.11<br>args            如：_a=index&amp;_m=show&amp;count=10<br>document_uri    与$uri相同,如：/index.php<br>document_root   针对当前请求的根路径设置值,如：/webserver/htdocs/dwz<br>hostname        如：centos53.localdomain<br>http_cookie     客户端cookie信息<br>cookie_COOKIE   cookie COOKIE变量的值<br>is_args         如果有$args参数，这个变量等于”?”，否则等于””，空值，如?<br>limit_rate      这个变量可以限制连接速率，0表示不限速<br>query_string    与$args相同,如：_a=index&amp;_m=show&amp;count=10<br>realpath_root   如：/webserver/htdocs/dwz<br>request_body     记录POST过来的数据信息<br>request_body_file   客户端请求主体信息的临时文件名<br>request_method  客户端请求的动作，通常为GET或POST,如：GET<br>request_uri     包含请求参数的原始URI，不包含主机名，如：”/foo/bar.php?arg=baz”。不能修改。如：/index.php?_a=index&amp;_m=show&amp;count=10<br>scheme          HTTP方法（如http，https）,如：http<br>uri             如：/index.php<br>request_completion  如果请求结束，设置为OK. 当请求未结束或如果该请求不是请求链串的最后一个时，为空(Empty)，如：OK<br>server_protocol 请求使用的协议，通常是HTTP/1.0或HTTP/1.1，如：HTTP/1.1<br>server_addr     服务器地址，在完成一次系统调用后可以确定这个值，如：192.168.4.129<br>server_name     服务器名称，如：dwz.stamhe.com<br>server_port     请求到达服务器的端口号,如：80</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[查看jquery版本]]></title>
      <url>http://www.wulai.me/2014/12/05/e6-9f-a5-e7-9c-8bjquery-e7-89-88-e6-9c-ac/</url>
      <content type="html"><![CDATA[<pre><code>alert($.fn.jquery);
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[11个重要的数据库设计规则]]></title>
      <url>http://www.wulai.me/2014/11/29/11-e4-b8-aa-e9-87-8d-e8-a6-81-e7-9a-84-e6-95-b0-e6-8d-ae-e5-ba-93-e8-ae-be-e8-ae-a1-e8-a7-84-e5-88-99/</url>
      <content type="html"><![CDATA[<p>英文原文： <a href="http://www.c-sharpcorner.com/UploadFile/shivprasadk/11-important-database-designing-rules/" target="_blank" rel="external">11 Important Database designing rules</a></p>
<h3 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h3><p>　　在您开始阅读这篇文章之前，我得明确地告诉您，我并不是一个数据库设计领域的大师。以下列出的 11 点是我对自己在平时项目实践和阅读中学习到的经验总结出来的个人见解。我个人认为它们对我的数据库设计提供了很大的帮助。实属一家之言，欢迎拍砖 : )</p>
<p>　　我之所以写下这篇这么完整的文章是因为，很多开发者一参与到数据库设计，就会很自然地把 “三范式” 当作银弹一样来使用。他们往往认为遵循这个规范就是数据库设计的唯一标准。由于这种心态，他们往往尽管一路碰壁也会坚持把项目做下去。</p>
<p>　　如果你对 “三范式” 不清楚，<a href="http://www.hillock.com.cn/?p=77" target="_blank" rel="external">请点击这里（FQ）</a>一步一步的了解什么是“三范式”。</p>
<p>　　大家都说标准规范是重要的指导方针并且也这么做着，但是把它当作石头上的一块标记来记着（死记硬背）还是会带来麻烦的。以下 11 点是我在数据库设计时最优先考虑的规则。</p>
<h3 id="规则-1：弄清楚将要开发的应用程序是什么性质的（OLTP-还是-OPAP）？"><a href="#规则-1：弄清楚将要开发的应用程序是什么性质的（OLTP-还是-OPAP）？" class="headerlink" title="规则 1：弄清楚将要开发的应用程序是什么性质的（OLTP 还是 OPAP）？"></a>规则 1：弄清楚将要开发的应用程序是什么性质的（OLTP 还是 OPAP）？</h3><p>　　当你要开始设计一个数据库的时候，你应该首先要分析出你为之设计的应用程序是什么类型的，它是 “事务处理型”（Transactional） 的还是 “分析型” （Analytical）的？你会发现许多开发人员采用标准化做法去设计数据库，而不考虑目标程序是什么类型的，这样做出来的程序很快就会陷入性能、客户定制化的问题当中。正如前面所说的，这里有两种应用程序类型， “基于事务处理” 和 “基于分析”，下面让我们来了解一下这两种类型究竟说的是什么意思。 　　事务处理型：这种类型的应用程序，你的最终用户更关注数据的增查改删（CRUD，Creating/Reading/Updating/Deleting）。这种类型更加官方的叫法是 “OLTP” 。</p>
<p>　　<strong>分析型：</strong> 这种类型的应用程序，你的最终用户更关注数据分析、报表、趋势预测等等功能。这一类的数据库的 “插入” 和 “更新” 操作相对来说是比较少的。它们主要的目的是更加快速地查询、分析数据。这种类型更加官方的叫法是 “OLAP” 。</p>
<p><a href="http://www.hillock.com.cn/wp-content/uploads/2014/11/2012041214001086.jpg" target="_blank" rel="external"><img src="http://www.hillock.com.cn/wp-content/uploads/2014/11/2012041214001086.jpg" alt="2012041214001086"></a></p>
<p>　　那么换句话说，如果你认为插入、更新、删除数据这些操作在你的程序中更为突出的话，那就设计一个规范化的表否则的话就去创建一个扁平的、不规范化的数据库结构。</p>
<p>　　以下这个简单的图表显示了像左边 Names 和 Address 这样的简单规范化的表，怎么通过应用不规范化结构来创建一个扁平的表结构。</p>
<p><a href="http://www.hillock.com.cn/wp-content/uploads/2014/11/2012041214003338.jpg" target="_blank" rel="external"><img src="http://www.hillock.com.cn/wp-content/uploads/2014/11/2012041214003338.jpg" alt="2012041214003338"></a></p>
<h3 id="规则-2：将你的数据按照逻辑意义分成不同的块，让事情做起来更简单"><a href="#规则-2：将你的数据按照逻辑意义分成不同的块，让事情做起来更简单" class="headerlink" title="规则 2：将你的数据按照逻辑意义分成不同的块，让事情做起来更简单"></a>规则 2：将你的数据按照逻辑意义分成不同的块，让事情做起来更简单</h3><p>　　这个规则其实就是 “三范式” 中的第一范式。违反这条规则的一个标志就是，你的查询使用了很多字符串解析函数</p>
<p>　　例如 substring、charindex 等等。若真如此，那就需要应用这条规则了。</p>
<p>　　比如你看到的下面图片上有一个有学生名字的表，如果你想要查询学生名字中包含“Koirala”，但不包含“Harisingh”的记录，你可以想象一下你将会得到什么样的结果。</p>
<p>　　所以更好的做法是将这个字段拆分为更深层次的逻辑分块，以便我们的表数据写起来更干净，以及优化查询。</p>
<p><a href="http://www.hillock.com.cn/wp-content/uploads/2014/11/2012041214010291.jpg" target="_blank" rel="external"><img src="http://www.hillock.com.cn/wp-content/uploads/2014/11/2012041214010291.jpg" alt="2012041214010291"></a></p>
<h3 id="规则-3：不要过度使用-“规则-2”"><a href="#规则-3：不要过度使用-“规则-2”" class="headerlink" title="规则 3：不要过度使用 “规则 2”"></a>规则 3：不要过度使用 “规则 2”</h3><p>　　开发者都是一群很可爱的生物。如果你告诉他们这是一条解决问题的正路，他们就会一直这么做下去，做到过了头导致了一些不必要的后果。这也可以应用于我们刚刚在前面提到的规则2。当你考虑字段分解时，先暂停一下，并且问问你自己是否真的需要这么做。正如所说的，分解应该是要符合逻辑的。</p>
<p>　　例如，你可以看到电话号码这个字段，你很少会把电话号码的 ISD 代码单独分开来操作（除非你的应用程序要求这么做）。所以一个很明智的决定就是让它保持原样，否则这会带来更多的问题。</p>
<p><a href="http://www.hillock.com.cn/wp-content/uploads/2014/11/2012041214012642.jpg" target="_blank" rel="external"><img src="http://www.hillock.com.cn/wp-content/uploads/2014/11/2012041214012642.jpg" alt="2012041214012642"></a></p>
<h3 id="规则-4：把重复、不统一的数据当成你最大的敌人来对待"><a href="#规则-4：把重复、不统一的数据当成你最大的敌人来对待" class="headerlink" title="规则 4：把重复、不统一的数据当成你最大的敌人来对待"></a>规则 4：把重复、不统一的数据当成你最大的敌人来对待</h3><p>　　集中那些重复的数据然后重构它们。我个人更加担心的是这些重复数据带来的混乱而不是它们占用了多少磁盘空间。</p>
<p>　　例如下面这个图表，你可以看到 “5th Standard” 和 “Fifth standard” 是一样的意思，它们是重复数据。现在你可能会说是由于那些录入者录入了这些重复的数据或者是差劲的验证程序没有拦住，让这些重复的数据进入到了你的系统。现在，如果你想导出一份将原本在用户眼里十分困惑的数据显示为不同实体数据的报告，该怎么做呢？</p>
<p><a href="http://www.hillock.com.cn/wp-content/uploads/2014/11/2012041214015638.jpg" target="_blank" rel="external"><img src="http://www.hillock.com.cn/wp-content/uploads/2014/11/2012041214015638.jpg" alt="2012041214015638"></a></p>
<p>　　解决方法之一是将这些数据完整地移到另外一个主表，然后通过外键引用过来。在下面这个图表中你可以看到我们是如何创建一个名为 “Standards”（课程级别） 的主表，然后同样地使用简单的外键连接过去。</p>
<p>　　 <a href="http://www.hillock.com.cn/wp-content/uploads/2014/11/2012041214022798.jpg" target="_blank" rel="external"><img src="http://www.hillock.com.cn/wp-content/uploads/2014/11/2012041214022798.jpg" alt="2012041214022798"></a></p>
<h3 id="规则-5：当心被分隔符分割的数据，它们违反了“字段不可再分”"><a href="#规则-5：当心被分隔符分割的数据，它们违反了“字段不可再分”" class="headerlink" title="规则 5：当心被分隔符分割的数据，它们违反了“字段不可再分”"></a>规则 5：当心被分隔符分割的数据，它们违反了“字段不可再分”</h3><p>　　前面的规则 2 即“第一范式”说的是避免 “重复组” 。下面这个图表作为其中的一个例子解释了 “重复组”是什么样子的。如果你仔细的观察 syllabus（课程） 这个字段，会发现在这一个字段里实在是填充了太多的数据了。像这些字段就被称为 “重复组” 了。如果我们又得必须使用这些数据，那么这些查询将会十分复杂并且我也怀疑这些查询会有性能问题。</p>
<p><a href="http://www.hillock.com.cn/wp-content/uploads/2014/11/2012041214025658.jpg" target="_blank" rel="external"><img src="http://www.hillock.com.cn/wp-content/uploads/2014/11/2012041214025658.jpg" alt="2012041214025658"></a></p>
<p>　　这些被塞满了分隔符的数据列需要特别注意，并且一个较好的办法是将这些字段移到另外一个表中，使用外键连接过去，同样地以便于更好的管理。</p>
<p><a href="http://www.hillock.com.cn/wp-content/uploads/2014/11/2012041214031733.jpg" target="_blank" rel="external"><img src="http://www.hillock.com.cn/wp-content/uploads/2014/11/2012041214031733.jpg" alt="2012041214031733"></a></p>
<p>　　那么，让我们现在就应用规则2（第一范式） “避免重复组” 吧。你可以看到上面这个图表，我创建了一个单独的 syllabus（课程） 表，然后使用 “多对多” 关系将它与 subject（科目） 表关联起来。</p>
<p>　　通过这个方法，主表（student 表）的 syllabus（课程） 字段就不再有重复数据和分隔符了。</p>
<h3 id="规则-6：当心那些仅仅部分依赖主键的列"><a href="#规则-6：当心那些仅仅部分依赖主键的列" class="headerlink" title="规则 6：当心那些仅仅部分依赖主键的列"></a>规则 6：当心那些仅仅部分依赖主键的列</h3><p><a href="http://www.hillock.com.cn/wp-content/uploads/2014/11/2012041214033858.jpg" target="_blank" rel="external"><img src="http://www.hillock.com.cn/wp-content/uploads/2014/11/2012041214033858.jpg" alt="2012041214033858"></a></p>
<p>　　留心注意那些仅仅部分依赖主键的列。例如上面这个图表，我们可以看到这个表的主键是 Roll No.+Standard。现在请仔细观察 syllabus 字段，可以看到 syllabus（课程） 字段仅仅关联（依赖） Standard（课程级别） 字段而不是直接地关联（依赖）某个学生（Roll No. 字段）。</p>
<p>　　Syllabus（课程） 字段关联的是学生正在学习的哪个课程级别（Standard 字段）而不是直接关联到学生本身。那如果明天我们要更新教学大纲（课程）的话还要痛苦地为每个同学也修改一下，这明显是不符合逻辑的（不正常的做法）。更有意义的做法是将这些字段从这个表移到另外一个表，然后将它们与 Standard（课程级别）表关联起来。</p>
<p>　　你可以看到我们是如何移动 syllabus（课程）字段并且同样地附上 Standard 表。</p>
<p>　　这条规则只不过是 “三范式” 里的 “第二范式”：“所有字段都必须完整地依赖主键而不是部分依赖”。 　　</p>
<h3 id="规则-7：仔细地选择派生列"><a href="#规则-7：仔细地选择派生列" class="headerlink" title="规则 7：仔细地选择派生列"></a>规则 7：仔细地选择派生列</h3><p><a href="http://www.hillock.com.cn/wp-content/uploads/2014/11/2012041214040275.jpg" target="_blank" rel="external"><img src="http://www.hillock.com.cn/wp-content/uploads/2014/11/2012041214040275.jpg" alt="2012041214040275"></a></p>
<p>　　如果你正在开发一个 OLTP 型的应用程序，那强制不去使用派生字段会是一个很好的思路，除非有迫切的性能要求，比如经常需要求和、计算的 OLAP 程序，为了性能，这些派生字段就有必要存在了。</p>
<p>　　通过上面的这个图表，你可以看到 Average 字段是如何依赖 Marks 和 Subjects 字段的。这也是冗余的一种形式。因此对于这样的由其他字段得到的字段，需要思考一下它们是否真的有必要存在。</p>
<p>　　这个规则也被称为 “三范式” 里的第三条：“不应该有依赖于非主键的列” 。 我的个人看法是不要盲目地运用这条规则，应该要看实际情况，冗余数据并不总是坏的。如果冗余数据是计算出来的，看看实际情况再来决定是否应用这第三范式。</p>
<h3 id="规则-8：如果性能是关键，不要固执地去避免冗余"><a href="#规则-8：如果性能是关键，不要固执地去避免冗余" class="headerlink" title="规则 8：如果性能是关键，不要固执地去避免冗余"></a>规则 8：如果性能是关键，不要固执地去避免冗余</h3><p><a href="http://www.hillock.com.cn/wp-content/uploads/2014/11/20120412140431791.jpg" target="_blank" rel="external"><img src="http://www.hillock.com.cn/wp-content/uploads/2014/11/20120412140431791.jpg" alt="2012041214043179"></a></p>
<p>　　不要把 “避免冗余” 当作是一条绝对的规则去遵循。如果对性能有迫切的需求，考虑一下打破常规。常规情况下你需要做多个表的连接操作，而在非常规的情况下这样的多表连接是会大大地降低性能的。 　　</p>
<h3 id="规则-9：多维数据是各种不同数据的聚合"><a href="#规则-9：多维数据是各种不同数据的聚合" class="headerlink" title="规则 9：多维数据是各种不同数据的聚合"></a>规则 9：多维数据是各种不同数据的聚合</h3><p>　　OLAP 项目主要是解决多维数据问题。比如你可以看看下面这个图表，你会想拿到每个国家、每个顾客、每段时期的销售额情况。简单的说你正在看的销售额数据包含了三个维度的交叉。</p>
<p><a href="http://www.hillock.com.cn/wp-content/uploads/2014/11/2012041214045413.jpg" target="_blank" rel="external"><img src="http://www.hillock.com.cn/wp-content/uploads/2014/11/2012041214045413.jpg" alt="2012041214045413"></a></p>
<p>　　为这种情况做一个实际的设计是一个更好的办法。简单的说，你可以创建一个简单的主要销售表，它包含了销售额字段，通过外键将其他所有不同维度的表连接起来。</p>
<p><a href="http://www.hillock.com.cn/wp-content/uploads/2014/11/2012041214051867.jpg" target="_blank" rel="external"><img src="http://www.hillock.com.cn/wp-content/uploads/2014/11/2012041214051867.jpg" alt="2012041214051867"></a></p>
<p><a href="http://www.hillock.com.cn/wp-content/uploads/2014/11/a15.jpg" target="_blank" rel="external"><img src="http://www.hillock.com.cn/wp-content/uploads/2014/11/a15.jpg" alt="a15"></a></p>
<h3 id="规则-10：将那些具有“名值表”特点的表统一起来设计"><a href="#规则-10：将那些具有“名值表”特点的表统一起来设计" class="headerlink" title="规则 10：将那些具有“名值表”特点的表统一起来设计"></a>规则 10：将那些具有“名值表”特点的表统一起来设计</h3><p>　　很多次我都遇到过这种 “名值表” 。 “名值表” 意味着它有一些键，这些键被其他数据关联着。比如下面这个图表，你可以看到我们有 Currency（货币型）和 Country（国家）这两张表。如果你仔细观察你会发现实际上这些表都只有键和值。</p>
<p><a href="http://www.hillock.com.cn/wp-content/uploads/2014/11/2012041214061280.jpg" target="_blank" rel="external"><img src="http://www.hillock.com.cn/wp-content/uploads/2014/11/2012041214061280.jpg" alt="2012041214061280"></a></p>
<p>　　对于这种表，创建一个主要的表，通过一个 Type（类型）字段来区分不同的数据将会更有意义。 　　</p>
<h3 id="规则-11：无限分级结构的数据，引用自己的主键作为外键"><a href="#规则-11：无限分级结构的数据，引用自己的主键作为外键" class="headerlink" title="规则 11：无限分级结构的数据，引用自己的主键作为外键"></a>规则 11：无限分级结构的数据，引用自己的主键作为外键</h3><p>　　我们会经常碰到一些无限父子分级结构的数据（树形结构？）。例如考虑一个多级销售方案的情况，一个销售人员之下可以有多个销售人员。注意到都是 “销售人员” 。也就是说数据本身都是一种。但是层级不同。这时候我们可以引用自己的主键作为外键来表达这种层级关系，从而达成目的。</p>
<p><a href="http://www.hillock.com.cn/wp-content/uploads/2014/11/2012041214063167.jpg" target="_blank" rel="external"><img src="http://www.hillock.com.cn/wp-content/uploads/2014/11/2012041214063167.jpg" alt="2012041214063167"></a></p>
<p>　　这篇文章的用意不是叫大家不要遵循范式，而是叫大家不要盲目地遵循范式。根据你的项目性质和需要处理的数据类型来做出正确的选择。</p>
<p><a href="http://www.hillock.com.cn/wp-content/uploads/2014/11/2012041214065062.jpg" target="_blank" rel="external"><img src="http://www.hillock.com.cn/wp-content/uploads/2014/11/2012041214065062.jpg" alt="2012041214065062"></a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Markdown: Basics （快速入门）]]></title>
      <url>http://www.wulai.me/2014/11/29/markdown-basics-ef-bc-88-e5-bf-ab-e9-80-9f-e5-85-a5-e9-97-a8-ef-bc-89/</url>
      <content type="html"><![CDATA[<p>&lt;&lt; <a href="http://wowubuntu.com" target="_blank" rel="external">访问 Wow!Ubuntu</a></p>
<p><strong>声明：</strong> 这份文档派生(fork)于<a href="http://markdown.tw/" target="_blank" rel="external">繁体中文版</a>，在此基础上进行了繁体转简体工作，并进行了适当的润色。此文档用 Markdown 语法编写，你可以到这里<a href="http://gitcafe.com/riku/Markdown-Syntax-CN/blob/master/basics.md" target="_blank" rel="external">查看它的源文件</a>。「繁体中文版的原始文件可以<a href="https://github.com/othree/markdown-syntax-zhtw/blob/master/basics.md" target="_blank" rel="external">查看这里</a>」–By @<a href="http://twitter.com/riku" target="_blank" rel="external">riku</a></p>
<p><strong>注：</strong> 本项目托管于 <a href="http://gitcafe.com/riku/Markdown-Syntax-CN/" target="_blank" rel="external">GitCafe</a>上，请通过”派生”和”合并请求”来帮忙改进本项目。</p>
<h1 id="Markdown-Basics-（快速入门）-点击查看完整语法说明"><a href="#Markdown-Basics-（快速入门）-点击查看完整语法说明" class="headerlink" title="Markdown: Basics （快速入门） / (点击查看完整语法说明)"></a>Markdown: Basics （快速入门） / (<a href="./index.html">点击查看完整语法说明</a>)</h1><h2 id="Getting-the-Gist-of-Markdown’s-Formatting-Syntax"><a href="#Getting-the-Gist-of-Markdown’s-Formatting-Syntax" class="headerlink" title="Getting the Gist of Markdown’s Formatting Syntax"></a>Getting the Gist of Markdown’s Formatting Syntax</h2><p>此页提供了 Markdown 的简单概念， <a href="http://gitcafe.com/riku/Markdown-Syntax-CN/blob/master/syntax.md" title="Markdown Syntax" target="_blank" rel="external">语法说明</a> 页提供了完整详细的文档，说明了每项功能。但是 Markdown 其实很简单就可以上手，此页文档提供了一些范例，并且每个范例都会提供输出的 HTML 结果。</p>
<p>其实直接试试看也是一个很不错的方法， <a href="http://daringfireball.net/projects/markdown/dingus" title="Markdown Dingus" target="_blank" rel="external">Dingus</a> 是一个网页应用程序，你可以把自已编写的 Markdown 文档转成 XHTML。</p>
<h2 id="段落、标题、区块代码"><a href="#段落、标题、区块代码" class="headerlink" title="段落、标题、区块代码"></a>段落、标题、区块代码</h2><p>一个段落是由一个以上的连接的行句组成，而一个以上的空行则会划分出不同的段落（空行的定义是显示上看起来像是空行，就被视为空行，例如有一行只有空白和 tab，那该行也会被视为空行），一般的段落不需要用空白或换行缩进。</p>
<p>Markdown 支持两种标题的语法，<a href="http://docutils.sourceforge.net/mirror/setext.html" target="_blank" rel="external">Setext</a> 和 <a href="http://www.aaronsw.com/2002/atx/" target="_blank" rel="external">atx</a> 形式。Setext 形式是用底线的形式，利用 <code>=</code> （最高阶标题）和 <code>-</code> （第二阶标题），Atx 形式在行首插入 1 到 6 个 <code>#</code> ，对应到标题 1 到 6 阶。</p>
<p>区块引用则使用 email 形式的 ‘<code>&amp;gt;</code>‘ 角括号。</p>
<p>Markdown 语法:</p>
<pre><code>A First Level Header
====================
A Second Level Header
---------------------

Now is the time for all good men to come to
the aid of their country. This is just a
regular paragraph.

The quick brown fox jumped over the lazy
dog&apos;s back.
### Header 3

&amp;gt; This is a blockquote.
&amp;gt; 
&amp;gt; This is the second paragraph in the blockquote.
&amp;gt;
&amp;gt; ## This is an H2 in a blockquote
`&lt;/pre&gt;

输出 HTML 为：

&lt;pre&gt;`&amp;lt;h1&amp;gt;A First Level Header&amp;lt;/h1&amp;gt;
&amp;lt;h2&amp;gt;A Second Level Header&amp;lt;/h2&amp;gt;
&amp;lt;p&amp;gt;Now is the time for all good men to come to
the aid of their country. This is just a
regular paragraph.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;The quick brown fox jumped over the lazy
dog&apos;s back.&amp;lt;/p&amp;gt;
&amp;lt;h3&amp;gt;Header 3&amp;lt;/h3&amp;gt;
&amp;lt;blockquote&amp;gt;
&amp;lt;p&amp;gt;This is a blockquote.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;This is the second paragraph in the blockquote.&amp;lt;/p&amp;gt;
&amp;lt;h2&amp;gt;This is an H2 in a blockquote&amp;lt;/h2&amp;gt;
&amp;lt;/blockquote&amp;gt;
`&lt;/pre&gt;

### 修辞和强调

Markdown 使用星号和底线来标记需要强调的区段。

Markdown 语法:

&lt;pre&gt;`Some of these words *are emphasized*.
Some of these words _are emphasized also_.
Use two asterisks for **strong emphasis**.
Or, if you prefer, __use two underscores instead__.
`&lt;/pre&gt;

输出 HTML 为:

&lt;pre&gt;`&amp;lt;p&amp;gt;Some of these words &amp;lt;em&amp;gt;are emphasized&amp;lt;/em&amp;gt;.
Some of these words &amp;lt;em&amp;gt;are emphasized also&amp;lt;/em&amp;gt;.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;Use two asterisks for &amp;lt;strong&amp;gt;strong emphasis&amp;lt;/strong&amp;gt;.
Or, if you prefer, &amp;lt;strong&amp;gt;use two underscores instead&amp;lt;/strong&amp;gt;.&amp;lt;/p&amp;gt;
`&lt;/pre&gt;

## 列表

无序列表使用星号、加号和减号来做为列表的项目标记，这些符号是都可以使用的，使用星号：

&lt;pre&gt;`* Candy.
* Gum.
* Booze.
`&lt;/pre&gt;

加号：

&lt;pre&gt;`+ Candy.
+ Gum.
+ Booze.
`&lt;/pre&gt;

和减号

&lt;pre&gt;`- Candy.
- Gum.
- Booze.
`&lt;/pre&gt;

都会输出 HTML 为：

&lt;pre&gt;`&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;Candy.&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Gum.&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Booze.&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
`&lt;/pre&gt;

有序的列表则是使用一般的数字接着一个英文句点作为项目标记：

&lt;pre&gt;`1\. Red
2\. Green
3\. Blue
`&lt;/pre&gt;

输出 HTML 为：

&lt;pre&gt;`&amp;lt;ol&amp;gt;
&amp;lt;li&amp;gt;Red&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Green&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Blue&amp;lt;/li&amp;gt;
&amp;lt;/ol&amp;gt;
`&lt;/pre&gt;

如果你在项目之间插入空行，那项目的内容会用 `&amp;lt;p&amp;gt;` 包起来，你也可以在一个项目内放上多个段落，只要在它前面缩排 4 个空白或 1 个 tab 。

&lt;pre&gt;`* A list item.

    With multiple paragraphs.

* Another item in the list.
`&lt;/pre&gt;

输出 HTML 为：

&lt;pre&gt;`&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;p&amp;gt;A list item.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;With multiple paragraphs.&amp;lt;/p&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;p&amp;gt;Another item in the list.&amp;lt;/p&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
`&lt;/pre&gt;

### 链接

Markdown 支援两种形式的链接语法： _行内_ 和 _参考_ 两种形式，两种都是使用角括号来把文字转成连结。

行内形式是直接在后面用括号直接接上链接：

&lt;pre&gt;`This is an [example link](http://example.com/).
`&lt;/pre&gt;

输出 HTML 为：

&lt;pre&gt;`&amp;lt;p&amp;gt;This is an &amp;lt;a href=&quot;http://example.com/&quot;&amp;gt;
example link&amp;lt;/a&amp;gt;.&amp;lt;/p&amp;gt;
`&lt;/pre&gt;

你也可以选择性的加上 title 属性：

&lt;pre&gt;`This is an [example link](http://example.com/ &quot;With a Title&quot;).
`&lt;/pre&gt;

输出 HTML 为：

&lt;pre&gt;`&amp;lt;p&amp;gt;This is an &amp;lt;a href=&quot;http://example.com/&quot; title=&quot;With a Title&quot;&amp;gt;
example link&amp;lt;/a&amp;gt;.&amp;lt;/p&amp;gt;
`&lt;/pre&gt;

参考形式的链接让你可以为链接定一个名称，之后你可以在文件的其他地方定义该链接的内容：

&lt;pre&gt;`I get 10 times more traffic from [Google][1] than from
[Yahoo][2] or [MSN][3].

[1]: http://google.com/ &quot;Google&quot;
[2]: http://search.yahoo.com/ &quot;Yahoo Search&quot;
[3]: http://search.msn.com/ &quot;MSN Search&quot;
`&lt;/pre&gt;

输出 HTML 为：

&lt;pre&gt;`&amp;lt;p&amp;gt;I get 10 times more traffic from &amp;lt;a href=&quot;http://google.com/&quot;
title=&quot;Google&quot;&amp;gt;Google&amp;lt;/a&amp;gt; than from &amp;lt;a href=&quot;http://search.yahoo.com/&quot;
title=&quot;Yahoo Search&quot;&amp;gt;Yahoo&amp;lt;/a&amp;gt; or &amp;lt;a href=&quot;http://search.msn.com/&quot;
title=&quot;MSN Search&quot;&amp;gt;MSN&amp;lt;/a&amp;gt;.&amp;lt;/p&amp;gt;
`&lt;/pre&gt;

title 属性是选择性的，链接名称可以用字母、数字和空格，但是不分大小写：

&lt;pre&gt;`I start my morning with a cup of coffee and
[The New York Times][NY Times].

[ny times]: http://www.nytimes.com/
`&lt;/pre&gt;

输出 HTML 为：

&lt;pre&gt;`&amp;lt;p&amp;gt;I start my morning with a cup of coffee and
&amp;lt;a href=&quot;http://www.nytimes.com/&quot;&amp;gt;The New York Times&amp;lt;/a&amp;gt;.&amp;lt;/p&amp;gt;
`&lt;/pre&gt;

### 图片

图片的语法和链接很像。

行内形式（title 是选择性的）：

&lt;pre&gt;`![alt text](/path/to/img.jpg &quot;Title&quot;)
`&lt;/pre&gt;

参考形式：

&lt;pre&gt;`![alt text][id]

[id]: /path/to/img.jpg &quot;Title&quot;
`&lt;/pre&gt;

上面两种方法都会输出 HTML 为：

&lt;pre&gt;`&amp;lt;img src=&quot;/path/to/img.jpg&quot; alt=&quot;alt text&quot; title=&quot;Title&quot; /&amp;gt;
`&lt;/pre&gt;

### 代码

在一般的段落文字中，你可以使用反引号 ``` 来标记代码区段，区段内的 `&amp;amp;`、`&amp;lt;` 和 `&amp;gt;` 都会被自动的转换成 HTML 实体，这项特性让你可以很容易的在代码区段内插入 HTML 码：

&lt;pre&gt;`I strongly recommend against using any `&amp;lt;blink&amp;gt;` tags.

I wish SmartyPants used named entities like `&amp;amp;mdash;`
instead of decimal-encoded entites like `&amp;amp;#8212;`.
`&lt;/pre&gt;

输出 HTML 为：

&lt;pre&gt;`&amp;lt;p&amp;gt;I strongly recommend against using any
&amp;lt;code&amp;gt;&amp;amp;lt;blink&amp;amp;gt;&amp;lt;/code&amp;gt; tags.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;I wish SmartyPants used named entities like
&amp;lt;code&amp;gt;&amp;amp;amp;mdash;&amp;lt;/code&amp;gt; instead of decimal-encoded
entites like &amp;lt;code&amp;gt;&amp;amp;amp;#8212;&amp;lt;/code&amp;gt;.&amp;lt;/p&amp;gt;
`&lt;/pre&gt;

如果要建立一个已经格式化好的代码区块，只要每行都缩进 4 个空格或是一个 tab 就可以了，而 `&amp;amp;`、`&amp;lt;` 和 `&amp;gt;` 也一样会自动转成 HTML 实体。

Markdown 语法:

&lt;pre&gt;`If you want your page to validate under XHTML 1.0 Strict,
you&apos;ve got to put paragraph tags in your blockquotes:

&amp;lt;blockquote&amp;gt;
&amp;lt;p&amp;gt;For example.&amp;lt;/p&amp;gt;
&amp;lt;/blockquote&amp;gt;
`&lt;/pre&gt;

输出 HTML 为：

&lt;pre&gt;`&amp;lt;p&amp;gt;If you want your page to validate under XHTML 1.0 Strict,
you&apos;ve got to put paragraph tags in your blockquotes:&amp;lt;/p&amp;gt;
&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;&amp;amp;lt;blockquote&amp;amp;gt;
&amp;amp;lt;p&amp;amp;gt;For example.&amp;amp;lt;/p&amp;amp;gt;
&amp;amp;lt;/blockquote&amp;amp;gt;
&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[数据库设计三大范式]]></title>
      <url>http://www.wulai.me/2014/11/29/e6-95-b0-e6-8d-ae-e5-ba-93-e8-ae-be-e8-ae-a1-e4-b8-89-e5-a4-a7-e8-8c-83-e5-bc-8f/</url>
      <content type="html"><![CDATA[<p>为了建立冗余较小、结构合理的数据库，设计数据库时必须遵循一定的规则。在关系型数据库中这种规则就称为范式。范式是符合某一种设计要求的总结。要想设计一个结构合理的关系型数据库，必须满足一定的范式。</p>
<p>在实际开发中最为常见的设计范式有三个：</p>
<h3 id="1．第一范式-确保每列保持原子性"><a href="#1．第一范式-确保每列保持原子性" class="headerlink" title="1．第一范式(确保每列保持原子性)"></a>1．第一范式(确保每列保持原子性)</h3><p>第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。</p>
<p>第一范式的合理遵循需要根据系统的实际需求来定。比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。这样设计才算满足了数据库的第一范式，如下表所示。 <a href="http://www.hillock.com.cn/wp-content/uploads/2014/11/2012040114023352.png" target="_blank" rel="external"><img src="http://www.hillock.com.cn/wp-content/uploads/2014/11/2012040114023352.png" alt="2012040114023352"></a> 上表所示的用户信息遵循了第一范式的要求，这样在对用户使用城市进行分类的时候就非常方便，也提高了数据库的性能。</p>
<h3 id="2．第二范式-确保表中的每列都和主键相关"><a href="#2．第二范式-确保表中的每列都和主键相关" class="headerlink" title="2．第二范式(确保表中的每列都和主键相关)"></a>2．第二范式(确保表中的每列都和主键相关)</h3><p>第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。</p>
<p>比如要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键，如下表所示。 <a href="http://www.hillock.com.cn/wp-content/uploads/2014/11/2012040114063976.png" target="_blank" rel="external"><img src="http://www.hillock.com.cn/wp-content/uploads/2014/11/2012040114063976.png" alt="2012040114063976"></a></p>
<p><strong>订单信息表</strong></p>
<p>这样就产生一个问题：这个表中是以订单编号和商品编号作为联合主键。这样在该表中商品名称、单位、商品价格等信息不与该表的主键相关，而仅仅是与商品编号相关。所以在这里违反了第二范式的设计原则。</p>
<p>而如果把这个订单信息表进行拆分，把商品信息分离到另一个表中，把订单项目表也分离到另一个表中，就非常完美了。如下所示。</p>
<p><a href="http://www.hillock.com.cn/wp-content/uploads/2014/11/2012040114082156.png" target="_blank" rel="external"><img src="http://www.hillock.com.cn/wp-content/uploads/2014/11/2012040114082156.png" alt="2012040114082156"></a></p>
<p>这样设计，在很大程度上减小了数据库的冗余。如果要获取订单的商品信息，使用商品编号到商品信息表中查询即可。</p>
<h3 id="3．第三范式-确保每列都和主键列直接相关-而不是间接相关"><a href="#3．第三范式-确保每列都和主键列直接相关-而不是间接相关" class="headerlink" title="3．第三范式(确保每列都和主键列直接相关,而不是间接相关)"></a>3．第三范式(确保每列都和主键列直接相关,而不是间接相关)</h3><p>第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。</p>
<p>比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。如下面这两个表所示的设计就是一个满足第三范式的数据库表。 <a href="http://www.hillock.com.cn/wp-content/uploads/2014/11/2012040114105477.png" target="_blank" rel="external"><img src="http://www.hillock.com.cn/wp-content/uploads/2014/11/2012040114105477.png" alt="2012040114105477"></a> 这样在查询订单信息的时候，就可以使用客户编号来引用客户信息表中的记录，也不必在订单信息表中多次输入客户信息的内容，减小了数据冗余。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Markdown 语法说明 (简体中文版)]]></title>
      <url>http://www.wulai.me/2014/11/29/markdown-e8-af-ad-e6-b3-95-e8-af-b4-e6-98-8e-e7-ae-80-e4-bd-93-e4-b8-ad-e6-96-87-e7-89-88/</url>
      <content type="html"><![CDATA[<p>&lt;&lt; <a href="http://wowubuntu.com" target="_blank" rel="external">访问 Wow!Ubuntu</a></p>
<p><strong>NOTE:</strong> This is Simplelified  Chinese Edition Document of Markdown Syntax. If you are seeking for English Edition Document. Please refer to <a href="http://daringfireball.net/projects/markdown/syntax" target="_blank" rel="external">Markdown: Syntax</a>.</p>
<p><strong>声明：</strong> 这份文档派生(fork)于<a href="http://markdown.tw/" target="_blank" rel="external">繁体中文版</a>，在此基础上进行了繁体转简体工作，并进行了适当的润色。此文档用 Markdown 语法编写，你可以到这里<a href="http://gitcafe.com/riku/Markdown-Syntax-CN/blob/master/syntax.md" target="_blank" rel="external">查看它的源文件</a>。「繁体中文版的原始文件可以<a href="https://github.com/othree/markdown-syntax-zhtw/blob/master/syntax.md" target="_blank" rel="external">查看这里</a> 。」–By @<a href="http://twitter.com/riku" target="_blank" rel="external">riku</a></p>
<p><strong>注：</strong> 本项目托管于 <a href="http://gitcafe.com/riku/Markdown-Syntax-CN/" target="_blank" rel="external">GitCafe</a>上，请通过”派生”和”合并请求”来帮忙改进本项目。</p>
<h1 id="Markdown-语法说明-简体中文版-点击查看快速入门"><a href="#Markdown-语法说明-简体中文版-点击查看快速入门" class="headerlink" title="Markdown 语法说明 (简体中文版) / (点击查看快速入门)"></a>Markdown 语法说明 (简体中文版) / (<a href="./basic.html">点击查看快速入门</a>)</h1><ul>
<li><p><a href="#overview">概述</a></p>
<pre><code>*   [宗旨](#philosophy)
</code></pre><ul>
<li><a href="#html">兼容 HTML</a></li>
<li><a href="#autoescape">特殊字符自动转换</a></li>
</ul>
</li>
<li><p><a href="#block">区块元素</a></p>
<pre><code>*   [段落和换行](#p)
</code></pre><ul>
<li><a href="#header">标题</a></li>
<li><a href="#blockquote">区块引用</a></li>
<li><a href="#list">列表</a></li>
<li><a href="#precode">代码区块</a></li>
<li><a href="#hr">分隔线</a></li>
</ul>
</li>
<li><p><a href="#span">区段元素</a></p>
<pre><code>*   [链接](#link)
</code></pre><ul>
<li><a href="#em">强调</a></li>
<li><a href="#code">代码</a></li>
<li><a href="#img">图片</a></li>
</ul>
</li>
<li><p><a href="#misc">其它</a></p>
<pre><code>*   [反斜杠](#backslash)
</code></pre><ul>
<li><a href="#autolink">自动链接</a></li>
</ul>
</li>
<li><a href="#acknowledgement">感谢</a></li>
<li><a href="#editor">Markdown 免费编辑器</a></li>
</ul>
<hr>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="宗旨"><a href="#宗旨" class="headerlink" title="宗旨"></a>宗旨</h3><p>Markdown 的目标是实现「易读易写」。</p>
<p>可读性，无论如何，都是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML 格式的影响，包括 <a href="http://docutils.sourceforge.net/mirror/setext.html" target="_blank" rel="external">Setext</a>、<a href="http://www.aaronsw.com/2002/atx/" target="_blank" rel="external">atx</a>、<a href="http://textism.com/tools/textile/" target="_blank" rel="external">Textile</a>、<a href="http://docutils.sourceforge.net/rst.html" target="_blank" rel="external">reStructuredText</a>、<a href="http://www.triptico.com/software/grutatxt.html" target="_blank" rel="external">Grutatext</a> 和 <a href="http://ettext.taint.org/doc/" target="_blank" rel="external">EtText</a>，而最大灵感来源其实是纯文本电子邮件的格式。</p>
<p>总之， Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。比如：在文字两旁加上星号，看起来就像&#42;强调&#42;。Markdown 的列表看起来，嗯，就是列表。Markdown 的区块引用看起来就真的像是引用一段文字，就像你曾在电子邮件中见过的那样。</p>
<h3 id="兼容-HTML"><a href="#兼容-HTML" class="headerlink" title="兼容 HTML"></a>兼容 HTML</h3><p>Markdown 语法的目标是：成为一种适用于网络的<em>书写</em>语言。</p>
<p>Markdown 不是想要取代 HTML，甚至也没有要和它相近，它的语法种类很少，只对应 HTML 标记的一小部分。Markdown 的构想<em>不是</em>要使得 HTML 文档更容易书写。在我看来， HTML 已经很容易写了。Markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种<em>发布</em>的格式，Markdown 是一种<em>书写</em>的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围。</p>
<p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。</p>
<p>要制约的只有一些 HTML 区块元素――比如 <code>&amp;lt;div&amp;gt;</code>、<code>&amp;lt;table&amp;gt;</code>、<code>&amp;lt;pre&amp;gt;</code>、<code>&amp;lt;p&amp;gt;</code> 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的 <code>&amp;lt;p&amp;gt;</code> 标签。</p>
<p>例子如下，在 Markdown 文件里加上一段 HTML 表格：</p>
<pre><code>这是一个普通段落。

&amp;lt;table&amp;gt;
    &amp;lt;tr&amp;gt;
        &amp;lt;td&amp;gt;Foo&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;

这是另一个普通段落。
`&lt;/pre&gt;

请注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。比如，你在 HTML 区块内使用 Markdown 样式的`*强调*`会没有效果。

HTML 的区段（行内）标签如 `&amp;lt;span&amp;gt;`、`&amp;lt;cite&amp;gt;`、`&amp;lt;del&amp;gt;` 可以在 Markdown 的段落、列表或是标题里随意使用。依照个人习惯，甚至可以不用 Markdown 格式，而直接采用 HTML 标签来格式化。举例说明：如果比较喜欢 HTML 的 `&amp;lt;a&amp;gt;` 或 `&amp;lt;img&amp;gt;` 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图像标签语法。

和处在 HTML 区块标签间不同，Markdown 语法在 HTML 区段标签间是有效的。

### 特殊字符自动转换

在 HTML 文件中，有两个字符需要特殊处理： `&amp;lt;` 和 `&amp;amp;` 。 `&amp;lt;` 符号用于起始标签，`&amp;amp;` 符号则用于标记 HTML 实体，如果你只是想要显示这些字符的原型，你必须要使用实体的形式，像是 `&amp;amp;lt;` 和 `&amp;amp;amp;`。

`&amp;amp;` 字符尤其让网络文档编写者受折磨，如果你要打「`AT&amp;amp;T`」 ，你必须要写成「`AT&amp;amp;amp;T`」。而网址中的 `&amp;amp;` 字符也要转换。比如你要链接到：

&lt;pre&gt;`http://images.google.com/images?num=30&amp;amp;q=larry+bird
`&lt;/pre&gt;

你必须要把网址转换写为：

&lt;pre&gt;`http://images.google.com/images?num=30&amp;amp;amp;q=larry+bird
`&lt;/pre&gt;

才能放到链接标签的 `href` 属性里。不用说也知道这很容易忽略，这也可能是 HTML 标准检验所检查到的错误中，数量最多的。

Markdown 让你可以自然地书写字符，需要转换的由它来处理好了。如果你使用的 `&amp;amp;` 字符是 HTML 字符实体的一部分，它会保留原状，否则它会被转换成 `&amp;amp;amp`;。

所以你如果要在文档中插入一个版权符号 `©`，你可以这样写：

&lt;pre&gt;`&amp;amp;copy;
`&lt;/pre&gt;

Markdown 会保留它不动。而若你写：

&lt;pre&gt;`AT&amp;amp;T
`&lt;/pre&gt;

Markdown 就会将它转为：

&lt;pre&gt;`AT&amp;amp;amp;T
`&lt;/pre&gt;

类似的状况也会发生在 `&amp;lt;` 符号上，因为 Markdown 允许 [兼容 HTML](#html) ，如果你是把 `&amp;lt;` 符号作为 HTML 标签的定界符使用，那 Markdown 也不会对它做任何转换，但是如果你写：

&lt;pre&gt;`4 &amp;lt; 5
`&lt;/pre&gt;

Markdown 将会把它转换为：

&lt;pre&gt;`4 &amp;amp;lt; 5
`&lt;/pre&gt;

不过需要注意的是，code 范围内，不论是行内还是区块， `&amp;lt;` 和 `&amp;amp;` 两个符号都_一定_会被转换成 HTML 实体，这项特性让你可以很容易地用 Markdown 写 HTML code （和 HTML 相对而言， HTML 语法中，你要把所有的 `&amp;lt;` 和 `&amp;amp;` 都转换为 HTML 实体，才能在 HTML 文件里面写出 HTML code。）

* * *

## 区块元素

### 段落和换行

一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。

「由一个或多个连续的文本行组成」这句话其实暗示了 Markdown 允许段落内的强迫换行（插入换行符），这个特性和其他大部分的 text-to-HTML 格式不一样（包括 Movable Type 的「Convert Line Breaks」选项），其它的格式会把每个换行符都转成 `&amp;lt;br /&amp;gt;` 标签。

如果你_确实_想要依赖 Markdown 来插入 `&amp;lt;br /&amp;gt;` 标签的话，在插入处先按入两个以上的空格然后回车。

的确，需要多费点事（多加空格）来产生 `&amp;lt;br /&amp;gt;` ，但是简单地「每个换行都转换为 `&amp;lt;br /&amp;gt;`」的方法在 Markdown 中并不适合， Markdown 中 email 式的 [区块引用](#blockquote) 和多段落的 [列表](#list) 在使用换行来排版的时候，不但更好用，还更方便阅读。

### 标题

Markdown 支持两种标题的语法，类 [Setext](http://docutils.sourceforge.net/mirror/setext.html) 和类 [atx](http://www.aaronsw.com/2002/atx/) 形式。

类 Setext 形式是用底线的形式，利用 `=` （最高阶标题）和 `-` （第二阶标题），例如：

&lt;pre&gt;`This is an H1
=============

This is an H2
-------------
`&lt;/pre&gt;

任何数量的 `=` 和 `-` 都可以有效果。

类 Atx 形式则是在行首插入 1 到 6 个 `#` ，对应到标题 1 到 6 阶，例如：

&lt;pre&gt;`# 这是 H1

## 这是 H2

###### 这是 H6
`&lt;/pre&gt;

你可以选择性地「闭合」类 atx 样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上 `#`，而行尾的 `#` 数量也不用和开头一样（行首的井字符数量决定标题的阶数）：

&lt;pre&gt;`# 这是 H1 #

## 这是 H2 ##

### 这是 H3 ######
`&lt;/pre&gt;

### 区块引用 Blockquotes

Markdown 标记区块引用是使用类似 email 中用 `&amp;gt;` 的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 `&amp;gt;` ：

&lt;pre&gt;`&amp;gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
&amp;gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
&amp;gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.
&amp;gt; 
&amp;gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
&amp;gt; id sem consectetuer libero luctus adipiscing.
`&lt;/pre&gt;

Markdown 也允许你偷懒只在整个段落的第一行最前面加上 `&amp;gt;` ：

&lt;pre&gt;`&amp;gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.

&amp;gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
id sem consectetuer libero luctus adipiscing.
`&lt;/pre&gt;

区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 `&amp;gt;` ：

&lt;pre&gt;`&amp;gt; This is the first level of quoting.
&amp;gt;
&amp;gt; &amp;gt; This is nested blockquote.
&amp;gt;
&amp;gt; Back to the first level.
`&lt;/pre&gt;

引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：

&lt;pre&gt;`&amp;gt; ## 这是一个标题。
&amp;gt; 
&amp;gt; 1\.   这是第一行列表项。
&amp;gt; 2\.   这是第二行列表项。
&amp;gt; 
&amp;gt; 给出一些例子代码：
&amp;gt; 
&amp;gt;     return shell_exec(&quot;echo $input | $markdown_script&quot;);
`&lt;/pre&gt;

任何像样的文本编辑器都能轻松地建立 email 型的引用。例如在 BBEdit 中，你可以选取文字后然后从选单中选择_增加引用阶层_。

### 列表

Markdown 支持有序列表和无序列表。

无序列表使用星号、加号或是减号作为列表标记：

&lt;pre&gt;`*   Red
*   Green
*   Blue
`&lt;/pre&gt;

等同于：

&lt;pre&gt;`+   Red
+   Green
+   Blue
`&lt;/pre&gt;

也等同于：

&lt;pre&gt;`-   Red
-   Green
-   Blue
`&lt;/pre&gt;

有序列表则使用数字接着一个英文句点：

&lt;pre&gt;`1\.  Bird
2\.  McHale
3\.  Parish
`&lt;/pre&gt;

很重要的一点是，你在列表标记上使用的数字并不会影响输出的 HTML 结果，上面的列表所产生的 HTML 标记为：

&lt;pre&gt;`&amp;lt;ol&amp;gt;
&amp;lt;li&amp;gt;Bird&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;McHale&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Parish&amp;lt;/li&amp;gt;
&amp;lt;/ol&amp;gt;
`&lt;/pre&gt;

如果你的列表标记写成：

&lt;pre&gt;`1\.  Bird
1\.  McHale
1\.  Parish
`&lt;/pre&gt;

或甚至是：

&lt;pre&gt;`3\. Bird
1\. McHale
8\. Parish
`&lt;/pre&gt;

你都会得到完全相同的 HTML 输出。重点在于，你可以让 Markdown 文件的列表数字和输出的结果相同，或是你懒一点，你可以完全不用在意数字的正确性。

如果你使用懒惰的写法，建议第一个项目最好还是从 1\. 开始，因为 Markdown 未来可能会支持有序列表的 start 属性。

列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。

要让列表看起来更漂亮，你可以把内容用固定的缩进整理好：

&lt;pre&gt;`*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
    Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
    viverra nec, fringilla in, laoreet vitae, risus.
*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.
    Suspendisse id sem consectetuer libero luctus adipiscing.
`&lt;/pre&gt;

但是如果你懒，那也行：

&lt;pre&gt;`*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
viverra nec, fringilla in, laoreet vitae, risus.
*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.
Suspendisse id sem consectetuer libero luctus adipiscing.
`&lt;/pre&gt;

如果列表项目间用空行分开，在输出 HTML 时 Markdown 就会将项目内容用 `&amp;lt;p&amp;gt;` 
标签包起来，举例来说：

&lt;pre&gt;`*   Bird
*   Magic
`&lt;/pre&gt;

会被转换为：

&lt;pre&gt;`&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;Bird&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Magic&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
`&lt;/pre&gt;

但是这个：

&lt;pre&gt;`*   Bird

*   Magic
`&lt;/pre&gt;

会被转换为：

&lt;pre&gt;`&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;p&amp;gt;Bird&amp;lt;/p&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;p&amp;gt;Magic&amp;lt;/p&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
`&lt;/pre&gt;

列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符：

&lt;pre&gt;`1\.  This is a list item with two paragraphs. Lorem ipsum dolor
    sit amet, consectetuer adipiscing elit. Aliquam hendrerit
    mi posuere lectus.

    Vestibulum enim wisi, viverra nec, fringilla in, laoreet
    vitae, risus. Donec sit amet nisl. Aliquam semper ipsum
    sit amet velit.

2\.  Suspendisse id sem consectetuer libero luctus adipiscing.
`&lt;/pre&gt;

如果你每行都有缩进，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许：

&lt;pre&gt;`*   This is a list item with two paragraphs.

    This is the second paragraph in the list item. You&apos;re
only required to indent the first line. Lorem ipsum dolor
sit amet, consectetuer adipiscing elit.

*   Another item in the same list.
`&lt;/pre&gt;

如果要在列表项目内放进引用，那 `&amp;gt;` 就需要缩进：

&lt;pre&gt;`*   A list item with a blockquote:

    &amp;gt; This is a blockquote
    &amp;gt; inside a list item.
`&lt;/pre&gt;

如果要放代码区块的话，该区块就需要缩进_两次_，也就是 8 个空格或是 2 个制表符：

&lt;pre&gt;`*   一列表项包含一个列表区块：

        &amp;lt;代码写在这&amp;gt;
`&lt;/pre&gt;

当然，项目列表很可能会不小心产生，像是下面这样的写法：

&lt;pre&gt;`1986\. What a great season.
`&lt;/pre&gt;

换句话说，也就是在行首出现_数字-句点-空白_，要避免这样的状况，你可以在句点前面加上反斜杠。

&lt;pre&gt;`1986\. What a great season.
`&lt;/pre&gt;

### 代码区块

和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 `&amp;lt;pre&amp;gt;` 和 `&amp;lt;code&amp;gt;` 标签来把代码区块包起来。

要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入：

&lt;pre&gt;`这是一个普通段落：

    这是一个代码区块。
`&lt;/pre&gt;

Markdown 会转换成：

&lt;pre&gt;`&amp;lt;p&amp;gt;这是一个普通段落：&amp;lt;/p&amp;gt;

&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;这是一个代码区块。
&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;
`&lt;/pre&gt;

这个每行一阶的缩进（4 个空格或是 1 个制表符），都会被移除，例如：

&lt;pre&gt;`Here is an example of AppleScript:

    tell application &quot;Foo&quot;
        beep
    end tell
`&lt;/pre&gt;

会被转换为：

&lt;pre&gt;`&amp;lt;p&amp;gt;Here is an example of AppleScript:&amp;lt;/p&amp;gt;

&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;tell application &quot;Foo&quot;
    beep
end tell
&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;
`&lt;/pre&gt;

一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。

在代码区块里面， `&amp;amp;` 、 `&amp;lt;` 和 `&amp;gt;` 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，再加上缩进就可以了，剩下的 Markdown 都会帮你处理，例如：

&lt;pre&gt;`    &amp;lt;div class=&quot;footer&quot;&amp;gt;
        &amp;amp;copy; 2004 Foo Corporation
    &amp;lt;/div&amp;gt;
`&lt;/pre&gt;

会被转换为：

&lt;pre&gt;`&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;&amp;amp;lt;div class=&quot;footer&quot;&amp;amp;gt;
    &amp;amp;amp;copy; 2004 Foo Corporation
&amp;amp;lt;/div&amp;amp;gt;
&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;
`&lt;/pre&gt;

代码区块中，一般的 Markdown 语法不会被转换，像是星号便只是星号，这表示你可以很容易地以 Markdown 语法撰写 Markdown 语法相关的文件。

### 分隔线

你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：

&lt;pre&gt;`* * *

***

*****

- - -

---------------------------------------
`&lt;/pre&gt;

* * *

## 区段元素

### 链接

Markdown 支持两种形式的链接语法： _行内式_和_参考式_两种形式。

不管是哪一种，链接文字都是用 [方括号] 来标记。

要建立一个_行内式_的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如：

&lt;pre&gt;`This is [an example](http://example.com/ &quot;Title&quot;) inline link.

[This link](http://example.net/) has no title attribute.
`&lt;/pre&gt;

会产生：

&lt;pre&gt;`&amp;lt;p&amp;gt;This is &amp;lt;a href=&quot;http://example.com/&quot; title=&quot;Title&quot;&amp;gt;
an example&amp;lt;/a&amp;gt; inline link.&amp;lt;/p&amp;gt;

&amp;lt;p&amp;gt;&amp;lt;a href=&quot;http://example.net/&quot;&amp;gt;This link&amp;lt;/a&amp;gt; has no
title attribute.&amp;lt;/p&amp;gt;
`&lt;/pre&gt;

如果你是要链接到同样主机的资源，你可以使用相对路径：

&lt;pre&gt;`See my [About](/about/) page for details.   
`&lt;/pre&gt;

_参考式_的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记：

&lt;pre&gt;`This is [an example][id] reference-style link.
`&lt;/pre&gt;

你也可以选择性地在两个方括号中间加上一个空格：

&lt;pre&gt;`This is [an example] [id] reference-style link.
`&lt;/pre&gt;

接着，在文件的任意处，你可以把这个标记的链接内容定义出来：

&lt;pre&gt;`[id]: http://example.com/  &quot;Optional Title Here&quot;
`&lt;/pre&gt;

链接内容定义的形式为：
</code></pre><ul>
<li>方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字</li>
<li>接着一个冒号</li>
<li>接着一个以上的空格或制表符</li>
<li>接着链接的网址</li>
<li><p>选择性地接着 title 内容，可以用单引号、双引号或是括弧包着</p>
<p>下面这三种链接的定义都是相同：</p>
<p><pre>`[foo]: <a href="http://example.com/" target="_blank" rel="external">http://example.com/</a>  “Optional Title Here”<br>[foo]: <a href="http://example.com/" target="_blank" rel="external">http://example.com/</a>  ‘Optional Title Here’</pre></p>
</li>
</ul>
<pre><code>[foo]: http://example.com/  (Optional Title Here)
`&lt;/pre&gt;

**请注意：**有一个已知的问题是 Markdown.pl 1.0.1 会忽略单引号包起来的链接 title。

链接网址也可以用尖括号包起来：

&lt;pre&gt;`[id]: &amp;lt;http://example.com/&amp;gt;  &quot;Optional Title Here&quot;
`&lt;/pre&gt;

你也可以把 title 属性放到下一行，也可以加一些缩进，若网址太长的话，这样会比较好看：

&lt;pre&gt;`[id]: http://example.com/longish/path/to/resource/here
    &quot;Optional Title Here&quot;
`&lt;/pre&gt;

网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。

链接辨别标签可以有字母、数字、空白和标点符号，但是并_不_区分大小写，因此下面两个链接是一样的：

&lt;pre&gt;`[link text][a]
[link text][A]
`&lt;/pre&gt;

_隐式链接标记_功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让 &quot;Google&quot; 链接到 google.com，你可以简化成：

&lt;pre&gt;`[Google][]
`&lt;/pre&gt;

然后定义链接内容：

&lt;pre&gt;`[Google]: http://google.com/
`&lt;/pre&gt;

由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词：

&lt;pre&gt;`Visit [Daring Fireball][] for more information.
`&lt;/pre&gt;

然后接着定义链接：

&lt;pre&gt;`[Daring Fireball]: http://daringfireball.net/
`&lt;/pre&gt;

链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。

下面是一个参考式链接的范例：

&lt;pre&gt;`I get 10 times more traffic from [Google] [1] than from
[Yahoo] [2] or [MSN] [3].

  [1]: http://google.com/        &quot;Google&quot;
  [2]: http://search.yahoo.com/  &quot;Yahoo Search&quot;
  [3]: http://search.msn.com/    &quot;MSN Search&quot;
`&lt;/pre&gt;

如果改成用链接名称的方式写：

&lt;pre&gt;`I get 10 times more traffic from [Google][] than from
[Yahoo][] or [MSN][].

  [google]: http://google.com/        &quot;Google&quot;
  [yahoo]:  http://search.yahoo.com/  &quot;Yahoo Search&quot;
  [msn]:    http://search.msn.com/    &quot;MSN Search&quot;
`&lt;/pre&gt;

上面两种写法都会产生下面的 HTML。

&lt;pre&gt;`&amp;lt;p&amp;gt;I get 10 times more traffic from &amp;lt;a href=&quot;http://google.com/&quot;
title=&quot;Google&quot;&amp;gt;Google&amp;lt;/a&amp;gt; than from
&amp;lt;a href=&quot;http://search.yahoo.com/&quot; title=&quot;Yahoo Search&quot;&amp;gt;Yahoo&amp;lt;/a&amp;gt;
or &amp;lt;a href=&quot;http://search.msn.com/&quot; title=&quot;MSN Search&quot;&amp;gt;MSN&amp;lt;/a&amp;gt;.&amp;lt;/p&amp;gt;
`&lt;/pre&gt;

下面是用行内式写的同样一段内容的 Markdown 文件，提供作为比较之用：

&lt;pre&gt;`I get 10 times more traffic from [Google](http://google.com/ &quot;Google&quot;)
than from [Yahoo](http://search.yahoo.com/ &quot;Yahoo Search&quot;) or
[MSN](http://search.msn.com/ &quot;MSN Search&quot;).
`&lt;/pre&gt;

参考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字符，但是用行内形式的却会增加到 176 个字元，如果是用纯 HTML 格式来写，会有 234 个字元，在 HTML 格式中，标签比文本还要多。

使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断。

### 强调

Markdown 使用星号（`*`）和底线（`_`）作为标记强调字词的符号，被 `*` 或 `_` 包围的字词会被转成用 `&amp;lt;em&amp;gt;` 标签包围，用两个 `*` 或 `_` 包起来的话，则会被转成 `&amp;lt;strong&amp;gt;`，例如：

&lt;pre&gt;`*single asterisks*

_single underscores_

**double asterisks**

__double underscores__
`&lt;/pre&gt;

会转成：

&lt;pre&gt;`&amp;lt;em&amp;gt;single asterisks&amp;lt;/em&amp;gt;

&amp;lt;em&amp;gt;single underscores&amp;lt;/em&amp;gt;

&amp;lt;strong&amp;gt;double asterisks&amp;lt;/strong&amp;gt;

&amp;lt;strong&amp;gt;double underscores&amp;lt;/strong&amp;gt;
`&lt;/pre&gt;

你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。

强调也可以直接插在文字中间：

&lt;pre&gt;`un*frigging*believable
`&lt;/pre&gt;

但是**如果你的 `*` 和 `_` 两边都有空白的话，它们就只会被当成普通的符号**。

如果要在文字前后直接插入普通的星号或底线，你可以用反斜线：

&lt;pre&gt;`\*this text is surrounded by literal asterisks\*
`&lt;/pre&gt;

### 代码

如果要标记一小段行内代码，你可以用反引号把它包起来（```），例如：

&lt;pre&gt;`Use the `printf()` function.
`&lt;/pre&gt;

会产生：

&lt;pre&gt;`&amp;lt;p&amp;gt;Use the &amp;lt;code&amp;gt;printf()&amp;lt;/code&amp;gt; function.&amp;lt;/p&amp;gt;
`&lt;/pre&gt;

如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段：

&lt;pre&gt;```There is a literal backtick (`) here.``
`&lt;/pre&gt;

这段语法会产生：

&lt;pre&gt;`&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;There is a literal backtick (`) here.&amp;lt;/code&amp;gt;&amp;lt;/p&amp;gt;
`&lt;/pre&gt;

代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号：

&lt;pre&gt;`A single backtick in a code span: `` ` ``

A backtick-delimited string in a code span: `` `foo` ``
`&lt;/pre&gt;

会产生：

&lt;pre&gt;`&amp;lt;p&amp;gt;A single backtick in a code span: &amp;lt;code&amp;gt;`&amp;lt;/code&amp;gt;&amp;lt;/p&amp;gt;

&amp;lt;p&amp;gt;A backtick-delimited string in a code span: &amp;lt;code&amp;gt;`foo`&amp;lt;/code&amp;gt;&amp;lt;/p&amp;gt;
`&lt;/pre&gt;

在代码区段内，`&amp;amp;` 和尖括号**都**会被自动地转成 HTML 实体，这使得插入 HTML 原始码变得很容易，Markdown 会把下面这段：

&lt;pre&gt;`Please don&apos;t use any `&amp;lt;blink&amp;gt;` tags.
`&lt;/pre&gt;

转为：

&lt;pre&gt;`&amp;lt;p&amp;gt;Please don&apos;t use any &amp;lt;code&amp;gt;&amp;amp;lt;blink&amp;amp;gt;&amp;lt;/code&amp;gt; tags.&amp;lt;/p&amp;gt;
`&lt;/pre&gt;

你也可以这样写：

&lt;pre&gt;``&amp;amp;#8212;` is the decimal-encoded equivalent of `&amp;amp;mdash;`.
`&lt;/pre&gt;

以产生：

&lt;pre&gt;`&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;&amp;amp;amp;#8212;&amp;lt;/code&amp;gt; is the decimal-encoded
equivalent of &amp;lt;code&amp;gt;&amp;amp;amp;mdash;&amp;lt;/code&amp;gt;.&amp;lt;/p&amp;gt;
`&lt;/pre&gt;

### 图片

很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。

Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： _行内式_和_参考式_。

行内式的图片语法看起来像是：

&lt;pre&gt;`![Alt text](/path/to/img.jpg)

![Alt text](/path/to/img.jpg &quot;Optional title&quot;)
`&lt;/pre&gt;

详细叙述如下：
</code></pre><ul>
<li>一个惊叹号 <code>!</code></li>
<li>接着一个方括号，里面放上图片的替代文字</li>
<li><p>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上<br>选择性的 ‘title’ 文字。</p>
<p>参考式的图片语法则长得像这样：</p>
<pre>`![Alt text][id]
`</pre>

<p>「id」是图片参考的名称，图片参考的定义方式则和连结参考一样：</p>
<pre>`[id]: url/to/image  "Optional title attribute"
`</pre>

<p>到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 <code>&amp;lt;img&amp;gt;</code> 标签。</p>
<hr>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h3><p>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：</p>
<pre>`&lt;http://example.com/&gt;
`</pre>

<p>Markdown 会转为：</p>
<pre>`&lt;a href="http://example.com/"&gt;http://example.com/&lt;/a&gt;
`</pre>

<p>邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如：</p>
<pre>`&lt;address@example.com&gt;
`</pre>

<p>Markdown 会转成：</p>
<pre>`&lt;a href="&amp;#x6D;&amp;#x61;i&amp;#x6C;&amp;#x74;&amp;#x6F;:&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;
&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;
&amp;#109;"&gt;&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;
&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;&amp;#109;&lt;/a&gt;
`</pre>

<p>在浏览器里面，这段字串（其实是 <code>&amp;lt;a href=&quot;mailto:address@example.com&quot;&amp;gt;address@example.com&amp;lt;/a&amp;gt;</code>）会变成一个可以点击的「address@example.com」链接。</p>
<p>（这种作法虽然可以糊弄不少的机器人，但并不能全部挡下来，不过总比什么都不做好些。不管怎样，公开你的信箱终究会引来广告信件的。）</p>
<h3 id="反斜杠"><a href="#反斜杠" class="headerlink" title="反斜杠"></a>反斜杠</h3><p>Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 <code>&amp;lt;em&amp;gt;</code> 标签），你可以在星号的前面加上反斜杠：</p>
<pre>`\*literal asterisks\*
`</pre>

<p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p>
<p><pre><code>\   反斜线</code>   反引号</pre></p>
<ul>
<li>星号<br>_   底线<br>{}  花括号<br>[]  方括号<br>()  括弧<h1 id="井字号"><a href="#井字号" class="headerlink" title="井字号"></a>井字号</h1></li>
</ul>
<ul>
<li>加号</li>
</ul>
<ul>
<li>减号<br>.   英文句点<br>!   惊叹号</li>
</ul>
</li>
</ul>
<h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p>感谢 <a href="https://twitter.com/#!/leafy7382" target="_blank" rel="external">leafy7382</a> 协助翻译，<a href="http://iamhlb.com/" target="_blank" rel="external">hlb</a>、<a href="http://twitter.com/randylien" target="_blank" rel="external">Randylien</a> 帮忙润稿，<a href="https://twitter.com/#!/ethantw" target="_blank" rel="external">ethantw</a> 的<a href="http://ethantw.net/projects/han/" target="_blank" rel="external">汉字标准格式・CSS Reset</a>， <a href="http://kidwm.net/" target="_blank" rel="external">WM</a> 回报文字错误。</p>
<p>感谢 <a href="https://github.com/fenprace" target="_blank" rel="external">fenprace</a>，<a href="https://github.com/addv" target="_blank" rel="external">addv</a>。</p>
<hr>
<h2 id="Markdown-免费编辑器"><a href="#Markdown-免费编辑器" class="headerlink" title="Markdown 免费编辑器"></a>Markdown 免费编辑器</h2><p>Windows 平台</p>
<ul>
<li><a href="http://markdownpad.com/" target="_blank" rel="external">MarkdownPad</a></li>
<li><a href="http://code52.org/DownmarkerWPF/" target="_blank" rel="external">MarkPad</a></li>
</ul>
<p>Linux 平台</p>
<ul>
<li><a href="http://sourceforge.net/p/retext/home/ReText/" target="_blank" rel="external">ReText</a></li>
</ul>
<p>Mac 平台</p>
<ul>
<li><a href="http://mouapp.com/" target="_blank" rel="external">Mou</a></li>
</ul>
<p>在线编辑器</p>
<ul>
<li><a href="http://markable.in/" target="_blank" rel="external">Markable.in</a></li>
<li><a href="http://dillinger.io/" target="_blank" rel="external">Dillinger.io</a></li>
</ul>
<p>浏览器插件</p>
<ul>
<li><a href="https://chrome.google.com/webstore/detail/oknndfeeopgpibecfjljjfanledpbkog" target="_blank" rel="external">MaDe</a> (Chrome)</li>
</ul>
<p>高级应用</p>
<ul>
<li><a href="http://www.sublimetext.com/2" target="_blank" rel="external">Sublime Text 2</a> + <a href="http://ttscoff.github.com/MarkdownEditing/" target="_blank" rel="external">MarkdownEditing</a> / <a href="http://lucifr.com/2012/07/12/markdownediting-for-sublime-text-2/" target="_blank" rel="external">教程</a></li>
</ul>
<p>&#42;** 如有更好的 Markdown 免费编辑器推荐，请到<a href="https://gitcafe.com/riku/Markdown-Syntax-CN/tickets/1" target="_blank" rel="external">这里反馈</a>，谢谢！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[APC缓存简介]]></title>
      <url>http://www.wulai.me/2014/11/28/73/</url>
      <content type="html"><![CDATA[<p>1、APC缓存简介 APC，全称是Alternative PHP Cache，官方翻译叫”可选PHP缓存”。它为我们提供了缓存和优化PHP的中间代码的框架。 APC的缓存分两部分:系统缓存和用户数据缓存。 系统缓存 它是指APC把PHP文件源码的编译结果缓存起来，然后在每次调用时先对比时间标记。如果未过期，则使用缓存的中间代码运行。默认缓存 3600s(一小时)。但是这样仍会浪费大量CPU时间。因此可以在php.ini中设置system缓存为永不过期(apc.ttl=0)。不过如果这样设置，改运php代码后需要重启WEB服务器。目前使用较多的是指此类缓存。 用户数据缓存 缓存由用户在编写PHP代码时用apc_store和apc_fetch函数操作读取、写入的。如果数据量不大的话，可以一试。如果数据量大，使用类似memcache此类的更加专著的内存缓存方案会更好 缓存key生成规则 APC的缓存中的每个slot都会有一个key，key是 apc_cache_key_t结构体类型，除了key相关的属性，关键是h字段的生成。 h字段决定了此元素落于slots数组的哪一个位置。对于用户缓存和系统缓存，其生成规则不同。 用户缓存通过apc_cache_make_user_key函数生成key。通过用户传递进来的key字符串，依赖PHP内核中的hash函数（PHP的hashtable所使用的hash函数：zend_inline_hash_func），生成h值。 系统缓存通过apc_cache_make_file_key函数生成key。通过APC的配置项apc.stat的开关来区别对待不同的方案。在打开的情况下，即 apc.stat= On 时，如果被更新则自动重新编译和缓存编译后的内容。此时的h值是文件的device和inode相加所得的值。在关闭的情况下，即apc.stat=off时，当文件被修改后，如果要使更新的内容生效，则必须重启Web服务器。此时h值是根据文件的路径地址生成，并且这里的路径是绝对路径。即使你是使用的相对路径，也会查找PG(include_path)定位文件，以取得绝对路径，所以使用绝对路径会跳过检查，可以提高代码的效率。 添加缓存过程 以用户缓存为例，apc_add函数用于给APC缓存中添加内容。如果key参数为字符串中，APC会根据此字符串生成key，如果key参数为数组，APC会遍历整个数组，生成key。根据这些key，APC会调用&#95;apc&#95;store将值存储到缓存中。由于这是用户缓存，当前使用的缓存为apc_user_cache。执行写入操作的是apc_cache_make_user_entry函数，其最终调用apc_cache_user_insert执行遍历查询和写入操作。与此对应，系统缓存使用apc_cache_insert执行写入操作，其最终都会调用&#95;apc&#95;cache_insert。 不管是用户缓存还是系统缓存，大体的执行过程类似，步骤如下：</p>
<p>通过求余操作，定位当前key的在slots数组中的位置： cache-&gt;slots[key.h % cache-&gt;num_slots]; 在定位到slots数组中的位置后，遍历当前key对应的slot链表，如果存在slot的key和要写入的key匹配或slot过期，清除当前slot。 在最后一个slot的后面插入新的slot。 2、APC模块安装 WINDOWS 第一步：下载php_apc.dll 在<a href="http://pecl.php.net/package/apc" target="_blank" rel="external">http://pecl.php.net/package/apc</a> 要与php版本对应 将php_apc.dll放入你的ext目录</p>
<p>第二步：让php.ini支持apc扩展模块。 然后打开php.ini 加入：</p>
<p>extension=php_apc.dll</p>
<p>apc.rfc1867 = on</p>
<p>apc.max_file_size = 100M</p>
<p>upload_max_filesize = 100M</p>
<p>post_max_size = 100M</p>
<p>//以上参数可自己定义</p>
<p>第三步：检查是否支持PHP APC apc_store apc_fetch PHP APC 配置参数 把相关的配置放在一起解释。</p>
<p>apc.enabled=1 apc.enabled默认值是1，你可设成0禁用APC。如果你设置为0的时候，同样把extension=apc.so也注释掉（这样可以节约内存资源）。一旦启用了APC功能，则会缓存Opcodes到共享内存。</p>
<p>apc.shm_segments = 1</p>
<p>总结 1,使用Spinlocks锁机制，能够达到最佳性能。</p>
<p>2,APC提供了apc.php，用于监控与管理APC缓存。不要忘记修改管理员名和密码</p>
<p>3,APC默认通过mmap匿名映射创建共享内存，缓存对象都存放在这块”大型”的内存空间。由APC自行管理该共享内存</p>
<p>4,我们需要通过统计调整apc.shm_size、apc.num_files_hints、apc.user_entries_hint的值。直到最佳</p>
<p>5,好吧，我承认apc.stat = 0 可以获得更佳的性能。要我做什么都可以接受.</p>
<p>6,PHP预定义常量，可以使用apc_define_constants()函数。不过据APC开发者介绍说pecl hidef性能更佳，抛异define吧，它是低效的。</p>
<p>7,函数apc_store()，对于系统设置等PHP变量，生命周期是整个应用(从httpd守护进程直到httpd守护进程关闭)，使用APC比Memcached会更好。必竟不要经过网络传输协议tcp。</p>
<p>8,APC不适于通过函数apc_store()缓存频繁变更的用户数据，会出现一些奇异现象。</p>
<p>LIUNX wget <a href="http://pecl.php.net/get/APC-3.1.8.tgz" target="_blank" rel="external">http://pecl.php.net/get/APC-3.1.8.tgz</a></p>
<p>tar -zxvf APC-3.1.8.tgz cd APC-3.1.8</p>
<p>/usr/local/php/bin/phpize</p>
<p>./configure –enable-apc –enable-mmap –enable-apc-spinlocks –disable-apc-pthreadmutex –with-php-config=/usr/local/php/bin/php-config</p>
<p>make</p>
<p>sudo make install</p>
<p>在/usr/local/php/etc/php.ini 加入</p>
<p>extension = “apc.so” ;</p>
<p>;APC setting</p>
<p>apc.enabled = 1</p>
<p>apc.shm_segments = 1</p>
<p>apc.shm_size = 64M</p>
<p>apc.optimization = 1</p>
<p>apc.num_files_hint = 0</p>
<p>apc.ttl = 0</p>
<p>apc.gc_ttl = 3600</p>
<p>apc.cache_by_default = on</p>
<p>重启apache 或者 /usr/local/php/sbin/php-fpm restart</p>
<p>查看phpinfo apc</p>
<p>下面引用www.initphp.com 框架的APC缓存类 initphp框架之APC缓存类 [php] &lt;?php if (!defined(‘IS_INITPHP’)) exit(‘Access Denied!’); /<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong> <em> InitPHP 2.0 国产PHP开发框架 Dao-APC缓存 不适合频繁写入的缓存数据 </em>——————————————————————————- <em> 版权所有: CopyRight By initphp.com </em> 您可以自由使用该源码，但是在使用过程中，请保留作者信息。尊重他人劳动成果就是尊重自己 <em>——————————————————————————- </em> $Author:zhuli <em> $Dtime:2011-10-09 <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></em>/ class apcInit {</p>
<pre><code>/**
 * Apc缓存-设置缓存
 * 设置缓存key，value和缓存时间
 * @param  string $key   KEY值
 * @param  string $value 值
 * @param  string $time  缓存时间
 */ 
public function set_cache($key, $value, $time = 0) {  
    if ($time == 0) $time = null; //null情况下永久缓存 
    return apc_store($key, $value, $time);; 
} 

/**
 * Apc缓存-获取缓存
 * 通过KEY获取缓存数据
 * @param  string $key   KEY值
 */ 
public function get_cache($key) { 
    return apc_fetch($key); 
} 

/**
 * Apc缓存-清除一个缓存
 * 从memcache中删除一条缓存
 * @param  string $key   KEY值
 */ 
public function clear($key) { 
    return apc_delete($key); 
} 

/**
 * Apc缓存-清空所有缓存
 * 不建议使用该功能
 * @return
 */ 
public function clear_all() { 
    apc_clear_cache(&apos;user&apos;); //清除用户缓存 
    return apc_clear_cache(); //清楚缓存 
} 

/**
 * 检查APC缓存是否存在
 * @param  string $key   KEY值
 */ 
public function exists($key) { 
    return apc_exists($key); 
} 

/**
 * 字段自增-用于记数
 * @param string $key  KEY值
 * @param int    $step 新增的step值
 */ 
public function inc($key, $step) { 
    return apc_inc($key, (int) $step); 
} 

/**
 * 字段自减-用于记数
 * @param string $key  KEY值
 * @param int    $step 新增的step值
 */ 
public function dec($key, $step) { 
    return apc_dec($key, (int) $step); 
} 

/**
 * 返回APC缓存信息
 */ 
public function info() { 
    return apc_cache_info(); 
} 
</code></pre><p>}</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[微信公共账号测试号申请]]></title>
      <url>http://www.wulai.me/2014/11/18/e5-be-ae-e4-bf-a1-e5-85-ac-e5-85-b1-e8-b4-a6-e5-8f-b7-e6-b5-8b-e8-af-95-e5-8f-b7-e7-94-b3-e8-af-b7/</url>
      <content type="html"><![CDATA[<p><code>http://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login</code></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CentOS中SSH连接中文乱码]]></title>
      <url>http://www.wulai.me/2014/11/17/centos-e4-b8-adssh-e8-bf-9e-e6-8e-a5-e4-b8-ad-e6-96-87-e4-b9-b1-e7-a0-81/</url>
      <content type="html"><![CDATA[<p>CentOS 6 ，在SSH时回显中文乱码，则：</p>
<p>修改 /etc/sysconfig/i18n 文件</p>
<p>命令：</p>
<pre><code>vi /etc/sysconfig/i18n
`&lt;/pre&gt;

将里面的文字 最终修改为：

&lt;pre&gt;`LANG=&quot;zh_CN.GB18030&quot;
LANGUAGE=&quot;zh_CN.GB18030:zh_CN.GB2312:zh_CN&quot;
SUPPORTED=&quot;zh_CN.UTF-8:zh_CN:zh:en_US.UTF-8:en_US:en&quot;
SYSFONT=&quot;lat0-sun16&quot;
</code></pre><p>最后，断开重连SSH就可以了，进入用date命令既可查看效果</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CentOS系统iptables如何打开端口和查看规则]]></title>
      <url>http://www.wulai.me/2014/11/16/centos-e7-b3-bb-e7-bb-9fiptables-e5-a6-82-e4-bd-95-e6-89-93-e5-bc-80-e7-ab-af-e5-8f-a3-e5-92-8c-e6-9f-a5-e7-9c-8b-e8-a7-84-e5-88-99/</url>
      <content type="html"><![CDATA[<p>CentOS安装好如果希望开放其他端口的话，需要打开所需端口,比如打开http的默认端口80</p>
<p>编辑iptables</p>
<pre><code>root:vi /etc/sysconfig/iptables 
`&lt;/pre&gt;

添加

&lt;pre&gt;`-A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT
`&lt;/pre&gt;

重新启动服务

&lt;pre&gt;`/sbin/service iptables restart 
`&lt;/pre&gt;

查看端口是否开放

&lt;pre&gt;`/sbin/iptables -L -n
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[解决LNMP下提示fileinfo插件没安装（PHP安装fileinfo扩展教程）]]></title>
      <url>http://www.wulai.me/2014/11/15/e8-a7-a3-e5-86-b3lnmp-e4-b8-8b-e6-8f-90-e7-a4-bafileinfo-e6-8f-92-e4-bb-b6-e6-b2-a1-e5-ae-89-e8-a3-85-ef-bc-88php-e5-ae-89-e8-a3-85fileinfo-e6-89-a9-e5-b1-95-e6-95-99-e7-a8-8b-ef-bc-89/</url>
      <content type="html"><![CDATA[<p>编译并安装fileinfo插件</p>
<pre><code>cd /root/lnmp1.0-full/php-5.3.17/ext/fileinfo
/usr/local/php/bin/phpize
./configure --with-php-config=/usr/local/php/bin/php-config
make &amp;amp;&amp;amp; make install
`&lt;/pre&gt;

在PHP配置中添加fileinfo插件
用vim编辑php.ini

&lt;pre&gt;`vim /usr/local/php/etc/php.ini
`&lt;/pre&gt;

找到 &quot;;extension=php_bz2.dll&quot; 这一行
在其上面添加一行：

&lt;pre&gt;`extension = fileinfo.so
`&lt;/pre&gt;

然后重启lnmp

&lt;pre&gt;`/root/lnmp restart
</code></pre><p>结束！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[linux下删除所有.svn目录]]></title>
      <url>http://www.wulai.me/2014/11/12/linux-e4-b8-8b-e5-88-a0-e9-99-a4-e6-89-80-e6-9c-89-svn-e7-9b-ae-e5-bd-95/</url>
      <content type="html"><![CDATA[<p>linux下删除所有.svn目录方法为</p>
<pre><code>find . -type d -name &quot;.svn&quot;|xargs rm -rf
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[(转)LNMP整合安装Redmine2.3实录]]></title>
      <url>http://www.wulai.me/2014/11/07/e8-bd-aclnmp-e6-95-b4-e5-90-88-e5-ae-89-e8-a3-85redmine2-3-e5-ae-9e-e5-bd-95/</url>
      <content type="html"><![CDATA[<p>自上一次在LNMP环境下安装过Redmine之后发表了《LNMP下安装Redmine2.3手记》，Inhu决定再一次尝试。因为上一次Inhu是通过折中的办法，也就是利用bitnami+lnmp这种做法实现的。现在我再一次决定在LNMP环境下不利用任何的一键安装包安装Redmine。</p>
<p>首先，我在这里不得不声明几点。</p>
<p>服务器系统时Centos6，试过在Centos5下安装，但由于软件库等各种问题最后在安装ImageMagick的时候失败了。所以建议大家使用Centos6。</p>
<p>首先，我们都安装好了Lnmp（一键安装，没修改任何配置目录的情况下）后。开始实施我们的Redmine安装了。</p>
<h3 id="1-安装ruby环境"><a href="#1-安装ruby环境" class="headerlink" title="1 安装ruby环境"></a>1 安装ruby环境</h3><p>执行以下命令：</p>
<pre><code>yum -y install zlib-devel curl-devel openssl-devel apr-devel apr-util-devel mysql-devel ImageMagick ImageMagick-devel rdoc gcc-c++ ruby ruby-devel 
`&lt;/pre&gt;

上面的命令是安装各种要用到的软件包，这时候Ruby应该是装好的了，你可以通过命令:

&lt;pre&gt;`ruby –v 
`&lt;/pre&gt;

进行查看Ruby的版本。当安装完以后我们实行第二步。

### 2 安装 RubyGems

访问：http://rubygems.org/pages/download

然后下载zip包或者tar包，然后解压出来后，进入目录执行以下命令：

&lt;pre&gt;`ruby setup.rb gem -v gem install passenger
`&lt;/pre&gt;

如果是国内主机的话，建议使用

&lt;pre&gt;`http://ruby.taobao.org/
`&lt;/pre&gt;

淘宝提供的一个RubyGems源。如何使用网站上面有详细说明，如果是国外主机就无需设置了。 然后执行以下命令：

&lt;pre&gt;`passenger-install-nginx-module
`&lt;/pre&gt;

这时候我们的操作步骤应该是： 填入lnmp目录下的Nginx源目录.例如:

&lt;pre&gt;`&amp;gt; /root/download/lnmp1.0-full/nginx-1.2.7
&amp;gt; /usr/local/nginx 
`&lt;/pre&gt;

如果需要IPV6的话，在设置配置参数的时候加上 –with-ipv6 然后猛的回车，看到一大堆的编译安装、编译安装了，如无意外就安装成功了。然后它会高亮提示你如何设置Nginx。

&lt;pre&gt;`http {
       ...
        passenger_root /usr/lib/ruby/gems/1.8/gems/passenger-4.0.5; 
        passenger_ruby /usr/bin/ruby; ... 
     }
`&lt;/pre&gt;

到这里，Web的容器环境已经配好了。 然后我们把下载好的Redmine解压出来，放到 /home/www/ 下。

然后进入config目录，复制修改 database.yml.example 文件。

&lt;pre&gt;`cd /home/www/redmine/config cp database.yml.example database.yml
vi database.yml
`&lt;/pre&gt;

修改这个database.yml的时候我们在修改DBname、账户、密码外还要注意的是我们要加一句，如下面的例子：

&lt;pre&gt;`production:
adapter: mysql2
database: redmine
host: localhost
username: -u
password: “-p”
encoding: utf8
socket: /tmp/mysql.sock
`&lt;/pre&gt;

除了production外，我都用 “#”注释掉了。因为用不着。然后去创建数据库了，这里不多说。
然后我们返回上一级目录，修改GemFile。

&lt;pre&gt;`cd ..
vi Gemfile
`&lt;/pre&gt;

在Gemfile第二行开始添加以下内容(可以不添加)：

&lt;pre&gt;`gem &quot;rake&quot;, &quot;10.0.4&quot;
gem &quot;rack&quot;, &quot;1.4.5&quot;
gem &quot;rubytree&quot;, &quot;0.8.3&quot;, :require =&amp;gt; &quot;tree&quot;
gem &quot;RedCloth&quot;, &quot;~&amp;gt;4.2.9&quot;, :require =&amp;gt; &quot;redcloth&quot; # for CodeRay    
gem &quot;mysql&quot;
`&lt;/pre&gt;

添加完之后，执行：

&lt;pre&gt;`gem install bundle
bundle install --without development test
`&lt;/pre&gt;

经过一轮等待后，可以看到成功的界面了吗？没看到，遇到问题了？慢慢搜索解决吧。哈哈
等等……Redmine还没有安装成功呢！
好了，然后执行以下指令吧：

&lt;pre&gt;`rake generate_secret_token
RAILS_ENV=production rake db:migrate
RAILS_ENV=production rake redmine:load_default_data
`&lt;/pre&gt;

非root用户需要添加用户

&lt;pre&gt;`mkdir -p tmp tmp/pdf public/plugin_assets
sudo chown -R redmine:redmine files log tmp public/plugin_assets
sudo chmod -R 755 files log tmp public/plugin_assets
`&lt;/pre&gt;

启动服务

&lt;pre&gt;`ruby script/rails server webrick -e production
`&lt;/pre&gt;

很好，这时应该能测试通过了。那么现在就要去配置Nginx了，在lnmp那里创建一个vHost，然后修改vHost配置文件如下：

&lt;pre&gt;`server {
         listen 81;
         server_name pm.techoinfo.com;
         index index.html index.htm index.php;
         root /home/www/redmine/public;
         passenger_enabled on;
         access_log  /home/wwwlogs/y.log  y;
    }
</code></pre><p>恩恩，就这样大功告成了。记住，Root的目录是指向 redmine 下的 public 目录哦，别搞错了！</p>
<p>如果在安装过程有问题，可以留言给我，因为我也遇到过很多问题。各种环境不一样各种问题啊。<br>原文:<a href="http://inhu.net/install-redmine-with-lnmp.html" target="_blank" rel="external">http://inhu.net/install-redmine-with-lnmp.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[js或css后加?v= 版本号的用法]]></title>
      <url>http://www.wulai.me/2014/10/20/js-e6-88-96css-e5-90-8e-e5-8a-a0v-e7-89-88-e6-9c-ac-e5-8f-b7-e7-9a-84-e7-94-a8-e6-b3-95/</url>
      <content type="html"><![CDATA[<pre><code>&amp;lt;span style=&quot;font-size:14px;&quot;&amp;gt;css和js带参数（形如.css?v=与.js?v= 或 .css?version=与.js?version= ）  

&amp;lt;script type=”text/javascript” src=”jb51.js?version=1.2.6″&amp;gt;&amp;lt;/script&amp;gt;  
&amp;lt;link rel=’stylesheet’ href=’base.css?version=2.3.3′ type=’text/css’ /&amp;gt;  
</code></pre><p>使用参数有两种可能：</p>
<p>第一、脚本并不存在，而是服务端动态生成的，因此带了个版本号，以示区别。  即上面代码对于文件来说 等价于</p>
<pre><code>&lt;script type=”text/javascript” src=”jb51.js”&gt;&lt;/script&gt;

&lt;link rel=’stylesheet’ href=’base.css’ type=’text/css’ /&gt;
</code></pre><p>但浏览器会认为他是 该文件的某个版本！</p>
<p>第二、客户端会缓存这些css或js文件，因此每次升级了js或css文件后，改变版本号，客户端浏览器就会重新下载新的js或css文件 ，刷性缓存的作用。大家可能有时候发现修改了样式或者js，刷新的时候不变，就是客户端缓存了css或者js文件，因此加上参数还是有好处的！</p>
<p>第二种情况最多，也可能两种同时存在。 </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Xenu-网站死链接检测权威工具]]></title>
      <url>http://www.wulai.me/2014/10/18/xenu-e7-bd-91-e7-ab-99-e6-ad-bb-e9-93-be-e6-8e-a5-e6-a3-80-e6-b5-8b-e6-9d-83-e5-a8-81-e5-b7-a5-e5-85-b7/</url>
      <content type="html"><![CDATA[<p>Xenu 是一款深受业界好评，并被广泛使用的死链接检测工具。</p>
<p>时常检测网站并排除死链接，对网站的 SEO 非常重要，因为大量死链接存在会降低用户和搜索引擎对网站的信任。</p>
<p>我们推荐的死链接检测工具 Xenu 主要具有以下特征：</p>
<p>需要下载安装，不到1M大小，用户界面非常简洁，操作简单。 检测彻底：能够检测到图片、框架、插件、背景、样式表、脚本和 java 程序中的链接。 报告形式合理多样，死链接一目了然。 提供出现死链接的网页，方便扫除导出链接错误。 能够侦测重定向URL 可以选择是否侦测站外链接。 对于小型简单网站，可以用来制作HTML格式网站地图。</p>
<p>死链接检测工具 Xenu 下载地址：<a href="http://home.snafu.de/tilman/XENU.ZIP" target="_blank" rel="external">http://home.snafu.de/tilman/XENU.ZIP</a></p>
<p>不懂英文者使用指南：</p>
<p>下载，并安装。 打开后，出现 Tips and Tricks 窗口，点击 Close 按钮。 点击左上第二行第一个按钮。 出现一个对话框，在对话框第一行，写入自己的URL。如：<a href="http://chenyanshi.com" target="_blank" rel="external">http://chenyanshi.com</a> 按底部的“OK”，就完成了。 报告结果中，出现红色的部分即是死链接。 原创文章，转载请注明： 转载自RICKYCHEN</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[DenyHosts]]></title>
      <url>http://www.wulai.me/2014/09/30/denyhosts/</url>
      <content type="html"><![CDATA[<h3 id="DenyHosts介绍"><a href="#DenyHosts介绍" class="headerlink" title="DenyHosts介绍"></a>DenyHosts介绍</h3><p>DenyHosts是Python语言写的一个程序，它会分析sshd的日志文件（/var/log/secure），当发现重 复的攻击时就会记录IP到/etc/hosts.deny文件，从而达到自动屏IP的功能。</p>
<h3 id="DenyHosts应用"><a href="#DenyHosts应用" class="headerlink" title="DenyHosts应用"></a>DenyHosts应用</h3><p>当你的linux服务器暴露在互联网之中，该服务器将会遭到互联网上的扫描软件进行扫描，并试图猜测SSH登录口令。</p>
<p>你会发现，每天会有多条SSH登录失败纪录。那些扫描工具将对你的服务器构成威胁，你必须设置复杂登录口令，并将尝试多次登录失败的IP给阻止掉，让其在一段时间内不能访问该服务器。</p>
<p>用DenyHosts可以阻止试图猜测SSH登录口令，它会分析/var/log/secure等日志文件，当发现同一IP在进行多次SSH密码尝试时就会记录IP到/etc/hosts.deny文件，从而达到自动屏蔽该IP的目的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[mysql修改字符集]]></title>
      <url>http://www.wulai.me/2014/09/11/mysql-e4-bf-ae-e6-94-b9-e5-ad-97-e7-ac-a6-e9-9b-86/</url>
      <content type="html"><![CDATA[<pre><code>ALTER TABLE `games` DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MongoDB安装]]></title>
      <url>http://www.wulai.me/2014/09/01/mongodb-e5-ae-89-e8-a3-85/</url>
      <content type="html"><![CDATA[<h3 id="MongoDB安装"><a href="#MongoDB安装" class="headerlink" title="MongoDB安装"></a>MongoDB安装</h3><pre><code>wget -c http://fastdl.mongodb.org/linux/mongodb-linux-i686-2.4.1.tgz ; 
tar zxvf mongodb-src-r2.4.1.tar.gz 
mv mongodb-linux-i686-2.4.1 /usr/local/mongodb/ 
/usr/local/mongodb/bin/mongod --dbpath=/usr/local/mongodb/data/ --logpath=/usr/local/mongodb/dblogs --fork 
`&lt;/pre&gt;

### 启动以后可以查看mongodb进程树

&lt;pre&gt;`pstree -p |grep mongod 
`&lt;/pre&gt;

### 可能出现的问题：

问题一：

&lt;pre&gt;`-bash: /usr/local/bin/mongo: /lib/ld-linux.so.2: bad ELF interpreter: 没有那个文件或目录
`&lt;/pre&gt;

解决办法：

&lt;pre&gt;`yum install ld-linux.so.2
`&lt;/pre&gt;

问题二：

&lt;pre&gt;`mongo: error while loading shared libraries: libstdc++.so.6: cannot open shared object file: No such file or directory
`&lt;/pre&gt;

解决办法：

&lt;pre&gt;`yum whatprovides libstdc++.so.6 
yum install llibstdc++.so.6
`&lt;/pre&gt;

#### PHP MongoDB 扩展

&lt;pre&gt;`cd /usr/local/src
wget -c http://pecl.php.net/get/mongo-1.4.4.tgz
tar -xzvf ./mongo-1.4.4.tgz
cd ./mongo-1.4.4
/usr/local/php/bin/phpize # 利用PHP的 phpize 命令来安装扩展
./configure --with-php-config=/usr/local/php/bin/php-config
make &amp;amp;&amp;amp; make install
`&lt;/pre&gt;

完成后，编辑你 php.ini 文件增加一行。

&lt;pre&gt;`extension=mongo.so
</code></pre><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>关闭注意 这里禁止使用 kill -9 PID 关闭mongodb进程，会导致mongod.lock导致再一次无法开启mongodb，必须删除mongod.lock再能开启 可以使用pkill mongod 或者 killall mongod 来结束mongodb进程 出处：<a href="http://www.crackedzone.com" target="_blank" rel="external">http://www.crackedzone.com</a> 完成后，请编辑你php.ini文件增加一行 extension=mongo.so 一般默认的编译php的ini文件在 /usr/local/php/etc/php.ini 重启你的web服务器或者php-fpm，打印phpinfo，如果看到mongo项表，那么mongodb的扩展安装成功了</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[nginx+php 显示php]]></title>
      <url>http://www.wulai.me/2014/08/28/nginxphp-e6-98-be-e7-a4-baphp/</url>
      <content type="html"><![CDATA[<h2 id="修改php-ini"><a href="#修改php-ini" class="headerlink" title="修改php.ini"></a>修改php.ini</h2><pre><code>short_open_tag = On
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[让wordpress主题绕开对google的依赖]]></title>
      <url>http://www.wulai.me/2014/08/21/e8-ae-a9wordpress-e4-b8-bb-e9-a2-98-e7-bb-95-e5-bc-80-e5-af-b9google-e7-9a-84-e4-be-9d-e8-b5-96/</url>
      <content type="html"><![CDATA[<p>终于有个借着写技术博客顺便吐槽GFW的机会了。每当网速很快，却偏偏不能谷歌搜索，好不容易搜到个跟问题十分匹配的网站，结果点进去菊花转了几百圈页面还是加载不出来，这显然是件让人很蛋疼的事情。虽然我学会了安装和配置翻墙神器goagent，但我仍然为很多很多很多不会翻墙和不愿意或者没钱买vpn的人叫一下委屈，其实会弄goagent这种的除了少数的一些个搞技术的一般人也弄不来。还有，即使是弄goagent，一，它也是很费时的，配置麻烦，偶尔还要更新程序，二，最近装新系统，准备下载goagent和浏览器代理插件的时候发现，goagent的程序托管在google仓库，proxyswitch要去google应用商店下，但问题是尼玛要访问google的东西你得先翻墙啊~为了能翻墙得先翻墙才行，悖论啊~ 呃。。好了，吐槽结束。该说正事儿了。对了，不知道GFW的去谷歌吧，哦不对，还是去百度吧，谷歌怕你上不去呢。 事情是这样的，基于wordpress的网站里面的主题会用到google的资源，比如我的<a href="http://sudodev.cn/" target="_blank" rel="external">blog站</a>用的twentytwelve主题就引用了谷歌的字体，里面就有个这样的链接:<a href="http://fonts.googleapis.com/css?family=Open+Sans:400italic,700italic,400,700&amp;subset=latin,latin-ext" target="_blank" rel="external">http://fonts.googleapis.com/css?family=Open+Sans:400italic,700italic,400,700&amp;subset=latin,latin-ext</a> 由于身在天朝的原因，你在访问我的blog的时候就会由于浏览器请求不到这个资源而一直在转菊花（loading加载），运气好只能显示部分图片信息，字看不见，而且是永远看不见那种，除非你像我一样翻墙了。好，既然是这样，那我们把它要请求的东西都下载到服务器上，把链接换成内部链接就好了。here we go:</p>
<div class="md-section-divider"><br></div>

<h2 id="1-46-离线资源"><a href="#1-46-离线资源" class="headerlink" title="1&#46;离线资源"></a>1&#46;离线资源</h2><ul>
<li>把这个网站对应的css下载下来，给它取个名字，比如我叫他googlefonts.css。</li>
<li>打开那个css文件，你会发现里面还有一些url是指向google的，分别都下载下来放在一起。比如我把css文件和里面的四个woff的url对应的字体文件都下下来放到了一个叫fonts的文件夹。</li>
<li>修改那个googlefonts.css文件中指向google的url。由于你把离线下来的那些woff文件放在该css同一个目录，所以你把/前面的所有内容都去掉，留个文件名即可</li>
<li>把fonts文件夹放在对应主题的目录里。比如我放在wp-content/twentytwelve/css/下面</li>
</ul>
<div class="md-section-divider"><br></div>

<h2 id="2-46-修改引用url-原来主题上的url是指向google的，现在要将它改成指向内部的css文件，即前面的googlefonts-css文件。那么去哪里改呢？我是在主题目录里执行"><a href="#2-46-修改引用url-原来主题上的url是指向google的，现在要将它改成指向内部的css文件，即前面的googlefonts-css文件。那么去哪里改呢？我是在主题目录里执行" class="headerlink" title="2&#46;修改引用url ,原来主题上的url是指向google的，现在要将它改成指向内部的css文件，即前面的googlefonts.css文件。那么去哪里改呢？我是在主题目录里执行"></a>2&#46;修改引用url ,原来主题上的url是指向google的，现在要将它改成指向内部的css文件，即前面的googlefonts.css文件。那么去哪里改呢？我是在主题目录里执行</h2><p><code>grep googleapis . -r</code>找到的，是在wp-content/twentytwelve/functions.php文件里。在</p>
<div class="md-section-divider"><br></div>

<ol>
<li><code>&amp;lt;span class=&quot;pln&quot; style=&quot;color: #000000;&quot;&gt;$font_url &amp;lt;/span&gt;&amp;lt;span class=&quot;pun&quot; style=&quot;color: #666600;&quot;&gt;=&amp;lt;/span&gt;&amp;lt;span class=&quot;pln&quot; style=&quot;color: #000000;&quot;&gt; add_query_arg&amp;lt;/span&gt;&amp;lt;span class=&quot;pun&quot; style=&quot;color: #666600;&quot;&gt;(&amp;lt;/span&gt;&amp;lt;span class=&quot;pln&quot; style=&quot;color: #000000;&quot;&gt; $query_args&amp;lt;/span&gt;&amp;lt;span class=&quot;pun&quot; style=&quot;color: #666600;&quot;&gt;,&amp;lt;/span&gt;&amp;lt;span class=&quot;str&quot; style=&quot;color: #008800;&quot;&gt;&quot;$protocol://fonts.googleapis.com/css&quot;&amp;lt;/span&gt;&amp;lt;span class=&quot;pun&quot; style=&quot;color: #666600;&quot;&gt;);&amp;lt;/span&gt;</code></li>
</ol>
<p>后面加两句</p>
<div class="md-section-divider"><br></div>

<ol>
<li><code>&amp;lt;span class=&quot;pln&quot; style=&quot;color: #000000;&quot;&gt;$filePath &amp;lt;/span&gt;&amp;lt;span class=&quot;pun&quot; style=&quot;color: #666600;&quot;&gt;=&amp;lt;/span&gt;&amp;lt;span class=&quot;pln&quot; style=&quot;color: #000000;&quot;&gt; dirname&amp;lt;/span&gt;&amp;lt;span class=&quot;pun&quot; style=&quot;color: #666600;&quot;&gt;(&amp;lt;/span&gt;&amp;lt;span class=&quot;pln&quot; style=&quot;color: #000000;&quot;&gt;__FILE__&amp;lt;/span&gt;&amp;lt;span class=&quot;pun&quot; style=&quot;color: #666600;&quot;&gt;).&amp;lt;/span&gt;&amp;lt;span class=&quot;str&quot; style=&quot;color: #008800;&quot;&gt;&quot;/css/fonts/googlefonts.css&quot;&amp;lt;/span&gt;&amp;lt;span class=&quot;pun&quot; style=&quot;color: #666600;&quot;&gt;;&amp;lt;/span&gt;</code></li>
<li><code>&amp;lt;span class=&quot;pln&quot; style=&quot;color: #000000;&quot;&gt;$font_url &amp;lt;/span&gt;&amp;lt;span class=&quot;pun&quot; style=&quot;color: #666600;&quot;&gt;=&amp;lt;/span&gt;&amp;lt;span class=&quot;str&quot; style=&quot;color: #008800;&quot;&gt;&quot;/&quot;&amp;lt;/span&gt;&amp;lt;span class=&quot;pun&quot; style=&quot;color: #666600;&quot;&gt;.&amp;lt;/span&gt;&amp;lt;span class=&quot;pln&quot; style=&quot;color: #000000;&quot;&gt;substr&amp;lt;/span&gt;&amp;lt;span class=&quot;pun&quot; style=&quot;color: #666600;&quot;&gt;(&amp;lt;/span&gt;&amp;lt;span class=&quot;pln&quot; style=&quot;color: #000000;&quot;&gt;$filePath&amp;lt;/span&gt;&amp;lt;span class=&quot;pun&quot; style=&quot;color: #666600;&quot;&gt;,&amp;lt;/span&gt;&amp;lt;span class=&quot;pln&quot; style=&quot;color: #000000;&quot;&gt; strpos&amp;lt;/span&gt;&amp;lt;span class=&quot;pun&quot; style=&quot;color: #666600;&quot;&gt;(&amp;lt;/span&gt;&amp;lt;span class=&quot;pln&quot; style=&quot;color: #000000;&quot;&gt;$filePath&amp;lt;/span&gt;&amp;lt;span class=&quot;pun&quot; style=&quot;color: #666600;&quot;&gt;,&amp;lt;/span&gt;&amp;lt;span class=&quot;str&quot; style=&quot;color: #008800;&quot;&gt;&quot;wp-content&quot;&amp;lt;/span&gt;&amp;lt;span class=&quot;pun&quot; style=&quot;color: #666600;&quot;&gt;));&amp;lt;/span&gt;</code></li>
</ol>
<p>好了，网站已经彻底摆脱了对google的依赖，马麻再也不用担心访问我的网站只能看到转菊花了~ ：）</p>
<blockquote>
<p>你可能会眨巴着你一双无辜的水汪汪的大眼睛，问：你连谷歌都不上去又怎么离线它的css资源呢，这不也是悖论吗？我微风中头一甩，待额头上整齐的头发潇洒平安的降落在头的一侧的时候，答：当然是先把墙给翻了再做这件事喽，傻瓜~</p>
</blockquote>
<div class="md-section-divider"><br></div>

<h2 id="另：网站中添加的谷歌analytics的js代码不会对网页加载产生影响。因为它是动态写上去，等网站发起对ga-js的请求的时候，网页中该请求的东西都请求完了。所以不会影响，只是有墙的情况下，由于ga-js请求不到，会影响google-analytics对你网站流量监控的准确性。-lt-转载于：http-sudodev-cn-articles-354-html-gt"><a href="#另：网站中添加的谷歌analytics的js代码不会对网页加载产生影响。因为它是动态写上去，等网站发起对ga-js的请求的时候，网页中该请求的东西都请求完了。所以不会影响，只是有墙的情况下，由于ga-js请求不到，会影响google-analytics对你网站流量监控的准确性。-lt-转载于：http-sudodev-cn-articles-354-html-gt" class="headerlink" title="另：网站中添加的谷歌analytics的js代码不会对网页加载产生影响。因为它是动态写上去，等网站发起对ga.js的请求的时候，网页中该请求的东西都请求完了。所以不会影响，只是有墙的情况下，由于ga.js请求不到，会影响google analytics对你网站流量监控的准确性。     &lt;转载于：http://sudodev.cn/articles/354.html&gt;"></a>另：网站中添加的谷歌analytics的js代码不会对网页加载产生影响。因为它是动态写上去，等网站发起对ga.js的请求的时候，网页中该请求的东西都请求完了。所以不会影响，只是有墙的情况下，由于ga.js请求不到，会影响google analytics对你网站流量监控的准确性。     &lt;转载于：<a href="http://sudodev.cn/articles/354.html&gt;" target="_blank" rel="external">http://sudodev.cn/articles/354.html&gt;</a></h2>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[过滤javascript,html标签很重要]]></title>
      <url>http://www.wulai.me/2014/08/21/e8-bf-87-e6-bb-a4javascripthtml-e6-a0-87-e7-ad-be-e5-be-88-e9-87-8d-e8-a6-81/</url>
      <content type="html"><![CDATA[<div class="title" style="color: #000000;"><br><br>#<br>    过滤javascript,html标签很重要<br><br></div>

<div class="meta" style="font-style: italic; color: #000000;"><br>  张映 发表于 2010-09-26 分类目录： <a href="http://blog.51yip.com/category/php" title="查看 php 的全部文章" target="_blank" rel="external">php</a><br></div>

<div class="entry" style="color: #000000;"><br>  用户输入的东西是不可信认的，例如，用户注册，用户评论等，这样的数据，你不光要做好防sql的注入，还要防止JS的注入,html的注入。   <strong>一，javascript注入的危害</strong> 举个简单的例子，我在一个网站留言了，并且这个网站没有对JS进行过滤,我在留言中加入以下内容 <div class="dp-highlighter"><br>    <div class="bar"><br>      <div class="tools" style="color: silver;"><br>        <a href="http://blog.51yip.com/php/1031.html#" target="_blank" rel="external">查看</a><a href="http://blog.51yip.com/php/1031.html#" target="_blank" rel="external">复制</a><a href="http://blog.51yip.com/php/1031.html#" target="_blank" rel="external">打印</a><a href="http://blog.51yip.com/php/1031.html#" target="_blank" rel="external">?</a><br>      </div><br>    </div>

<ol>
<li><span style="color: black;"><script language="javascript">  </span></li>
<li><span style="color: black;"> <span class="keyword" style="font-weight: bold; color: #006699;">for</span>(i=0;i&gt;=0;i++){  </span></li>
<li><span style="color: black;"> alert(<span class="string" style="color: blue;">‘我弹’</span>);  </span></li>
<li><span style="color: black;"> }  </span></li>
<li><p><span style="color: black;"> </script>  </span><br></li></ol></div> 上面的代码虽然简单，可是可以无限循环，并且会一直弹东西出来，让人感觉很不爽，直到浏览器没有响应为止。浏览您网站的人，第一反应肯定是这个网站有病毒。 解决办法 <p></p>
<div class="dp-highlighter"><br><div class="bar"><br>  <div class="tools" style="color: silver;"><br>    <a href="http://blog.51yip.com/php/1031.html#" target="_blank" rel="external">查看</a><a href="http://blog.51yip.com/php/1031.html#" target="_blank" rel="external">复制</a><a href="http://blog.51yip.com/php/1031.html#" target="_blank" rel="external">打印</a><a href="http://blog.51yip.com/php/1031.html#" target="_blank" rel="external">?</a><br>  </div><br></div>

<li><p><span style="color: black;"><span class="vars">$comment</span> = preg_replace(<span class="string" style="color: blue;">“/&lt;[^&gt;&lt;]<em>script[^&gt;&lt;]</em>&gt;/i”</span>,<span class="string" style="color: blue;">‘’</span>,<span class="vars">$comment</span>);  </span><br></p></li></div> 把里面的javascript标签去掉就行了。 <p></p>
<p><strong>二，html注入的危害</strong> 1，容易引起页面错乱，对用户输入html标签不做处理的话，在读取的时候，很有可能就会破坏页面的布局。 2，影响seo，做seo的人都知道，pr高的网址，如果有链接，链到你的网站的话，可以加大自己网站的权重，这也是为什么有那么多人喜欢在高pr网站灌水的原因了。如果你没有对html标签进行处理的话，我输入以下内容 <div class="dp-highlighter"></div></p>
<div class="bar"><br>  <div class="tools" style="color: silver;"><br>    <a href="http://blog.51yip.com/php/1031.html#" target="_blank" rel="external">查看</a><a href="http://blog.51yip.com/php/1031.html#" target="_blank" rel="external">复制</a><a href="http://blog.51yip.com/php/1031.html#" target="_blank" rel="external">打印</a><a href="http://blog.51yip.com/php/1031.html#" target="_blank" rel="external">?</a><br>  </div><br></div>

<li><p><span style="color: black;"><span class="tag" style="font-weight: bold; color: #006699;">&lt;</span><span class="tag-name" style="font-weight: bold; color: #006699;">a</span> <span class="attribute" style="color: red;">href</span>=<span class="attribute-value" style="color: blue;">“<a href="http://XXX.com" target="_blank" rel="external">http://XXX.com</a>“</span> <span class="attribute" style="color: red;">style</span>=<span class="attribute-value" style="color: blue;">“display:none;”</span><span class="tag" style="font-weight: bold; color: #006699;">&gt;</span>XXX.COM<span class="tag" style="font-weight: bold; color: #006699;">&lt;/</span><span class="tag-name" style="font-weight: bold; color: #006699;">a</span><span class="tag" style="font-weight: bold; color: #006699;">&gt;</span>  </span><br></p></li></div> XXX.COM是个不河蟹网站,政府肯定会河蟹的,如果你的网站有链接到这样的网址,很有可能导致,你网站权重降低. 危害肯定不止这二个,因此要对这些html标签进行处理 <p></p>
<div class="dp-highlighter"><br><div class="bar"><br>  <div class="tools" style="color: silver;"><br>    <a href="http://blog.51yip.com/php/1031.html#" target="_blank" rel="external">查看</a><a href="http://blog.51yip.com/php/1031.html#" target="_blank" rel="external">复制</a><a href="http://blog.51yip.com/php/1031.html#" target="_blank" rel="external">打印</a><a href="http://blog.51yip.com/php/1031.html#" target="_blank" rel="external">?</a><br>  </div><br></div>

<li><p><span style="color: black;"><span class="vars">$comment</span> = preg_replace(<span class="string" style="color: blue;">“/&lt;[\/!]<em>?[^&lt;&gt;]</em>?&gt;/si”</span>,<span class="string" style="color: blue;">‘’</span>,<span class="vars">$comment</span>);  </span><br></p></li></div> 过滤的方法有好多，也可以直接把&lt;&gt;这样的符号转义掉，或者直接删除掉都是可以的。   <p></p>
<p><strong>转载请注明 作者:海底苍鹰 地址:<a href="http://blog.51yip.com/php/1031.html" target="_blank" rel="external">http://blog.51yip.com/php/1031.html</a></strong><br></p>


]]></content>
    </entry>
    
  
  
</search>
